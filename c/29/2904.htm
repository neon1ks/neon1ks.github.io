<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Неформальная теория языка С - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#29">Содержание</a> | <a href="2903.htm">&lt;&lt;&lt;</a> | <a href="2905.htm">&gt;&gt;&gt;</a><hr>
<h1>Неформальная теория языка С</h1>
<p class="t">Перед тем как приступить к разработке интерпретатора языка С, необходимо уяснить структуру языка С. Формальное определение языка С (например, в стандарте ANSI/ISO) очень длинное, к тому же в нем довольно много зашифрованных для неискушенного читателя положений. Однако совершенно формальное определение языка С для разработки интерпретатора не понадобится, потому что этот язык является довольно прямолинейным. Полное формальное определение языка С необходимо для создания коммерческого компилятора, а для Little С оно не является необходимым. (Фактически, в одной главе невозможно изложить формальный синтаксис, определяющий С; это заняло бы целую книгу.)
<p class="tj">Эта глава предназначена для широкого круга читателей. Она не была задумана как формальное введение в теорию структурированных языков в целом и языка С в частности. Поэтому здесь некоторые концепции изложены упрощенно и разработка интерпретатора подмножества С ведется так, что от читатели не потребуется формальная подготовка по теории языков (структурной лингвистике).
<p class="tj">Несмотря на это для реализации и понимания интерпретатора Little С некоторые сведения об определении языка все же необходимы. Материал, изложенный далее, является вполне достаточным для наших целей. Желающим ознакомиться с более формализованным изложением материала следует обратиться к стандарту ANSI/ISO языка С.
<p class="tj">Все программы на С представляют собой набор из одной или более функций плюс глобальные переменные (если они есть). <em>Функция</em> состоит из спецификатора типа функции, имени функции, списка параметров и блока операторов, ассоциированного с функцией. <em>Блок</em> начинается скобкой <kbd>{</kbd>, за которой следует последовательность из одного или нескольких операторов, и заканчивается скобкой <kbd>}</kbd>. Оператор языка С либо начинается с одного из зарезервированных слов, например <kbd>if</kbd>, либо является выражением. (Что представляет собой выражение, будет рассмотрено в следующем разделе.) Изложенные выше порождающие правила могут быть сведены в следующую таблицу:
<pre>
программа       -&gt; набор функций плюс глобальные переменные
функция         -&gt; спецификатор список_параметров блок_операторов
блок_операторов -&gt; { последовательность_операторов }
оператор        -&gt; зарезервированное_слово, выражение или блок_операторов
</pre>
<p class="tj">Выполнение любой программы на С начинается вызовом функции <kbd>main()</kbd> и кончается последней закрывающейся скобкой <kbd>}</kbd> или первым оператором <kbd>return</kbd>, встретившимся в <kbd>main()</kbd>, если до этого не встретились <kbd>exit()</kbd> или <kbd>abort()</kbd>. Любая другая функция программы должна быть непосредственно или косвенно вызвана функцией <kbd>main()</kbd>. Таким образом, выполнение программы начинается с началом выполнения <kbd>main()</kbd> и кончается выходом из нее. Интерпретатор Little С именно так и работает.
<h2>Выражения языка С</h2>
<p class="tj">В языке С роль выражений несколько шире, чем в других языках программирования. В общем случае в программе на С оператор может начинаться с зарезервированного слова языка С, например, <kbd>while</kbd> или <kbd>switch</kbd>, а может и не начинаться с него. Для удобства дальнейшего изложения все операторы, начинающиеся с зарезервированного слова языка С, будем называть <em>операторами с зарезервированным словом</em>. Все остальные операторы (не начинающиеся с зарезервированного слова) будем называть <em>операторами-выражениями</em>. Таким образом, все следующие операторы языка С являются операторами-выражениями:
<pre>
count = 100;              /* Строка 1 */
sample = i / 22 * (c-10); /* Строка 2 */
printf("Этo выражение");  /* Строка 3 */
</pre>
<p class="tj">Рассмотрим каждый из этих операторов-выражений подробно. В языке С знак равенства является <em>оператором присваивания</em><sup><a href="#11" id="1">[1]</a></sup>. Здесь оператор присваивания работает не так, как, например, в BASIC. В языке BASIC значение, вычисленное в правой части знака равенства, присваивается переменной в левой части, однако, и это весьма существенно, это значение не является значением оператора присваивания. В то же время в языке С знак равенства является оператором присваивания и значение результата оператора присваивания равно значению, полученному в правой части. Следовательно, в языке С оператор присваивания фактически является <em>выражением присваивания</em>. Оператор присваивания имеет значение, поэтому он является выражением. Именно по этой причине правильными являются, например, следующие выражения:
<pre>
а = b = с = 100;
printf("%d", a=4+5);
</pre>
<p class="tj">Эти выражения в языке С допустимы, потому что присваивание является оператором, имеющим значение, как и любая другая операция.
<p class="tj">Продолжим рассмотрение предыдущего примера. Строка 2 содержит более сложное присваивание. В строке 3 вызывается функция <kbd>printf()</kbd>, выводящая на экран строку. В языке С все функции базовых типов, отличных от <kbd>void</kbd>, возвращают значение независимо от того, определен тип явно или нет. Следовательно, вызов функции, возвращающей значение, является выражением, имеющим значение, опять же независимо от того, присваивается оно чему-либо или нет. Вызов функции, не возвращающей значения (определенной со спецификатором <kbd>void</kbd>), также является выражением, однако его результат имеет тип <kbd>void</kbd>.
<h2>Определение значения выражения</h2>
<p class="tj">Перед тем как приступить к разработке программы, способной правильно вычислить значение выражения, нужно дать более формальное определение выражения. Фактически в каждом языке программирования выражения определяются рекурсивно с помощью порождающих правил, или продукций. Интерпретатор Little С поддерживает следующие операции: +, -, *, /, %, =, операторы сравнения (&lt;, ==, &gt; и так далее) и скобки. В языке Little С выражения определяются с помощью следующих порождающих правил:
<pre>
выражение           -&gt; [присваивание] [значение_переменной]
присваивание        -&gt; именующее_выражение = значение_переменной
именующее_выражение -&gt; переменная
значение_переменной -&gt; часть [оператор_сравнения часть]
часть               -&gt; терм [+терм] [-терм]
терм                -&gt; множитель [*множитель] [/множитель] [%множитель]
множитель           -&gt; [+ или -] атом
атом                -&gt; переменная, константа, функция, или(выражение)
</pre>
<p class="tj">Здесь термин <em>оператор_сравнения</em> может обозначать любой из операторов сравнения. Термины <em>именующее_выражение</em> и <em>значение_переменной</em> означают объекты в левой и правой частях оператора присваивания. Старшинство оператора определяется порождающим правилом. Чем выше старшинство оператора, тем ниже в списке операторов он расположен.
<p class="tj">Рассмотрим применение порождающих правил на примере вычисления выражения
<pre>count = 10 - 5 * 3;</pre>
<p class="tj">Сначала применяется правило 1, разделяющее выражение на три части:
<pre>
      count                =              10-5*3
        ^                  ^                 ^
        |                  |                 |
именующее_выражение   присваивание   значение_переменной
</pre>
<p class="tj">Поскольку значение нетерминала <em>значение_переменной</em> не содержит операторов сравнения, то оно может быть сгенерировано в результате применения порождающего правила для нетерминала <em>терм</em>:
<pre>
 10        -        5*3
  ^        ^         ^
  |        |         |
терм     минус     терм
</pre>
<p class="tj">Несомненно, второй терм составлен из двух множителей: 5 и 3. Эти два множителя являются константами, они порождаются с помощью порождающих правил более низкого уровня.
<p class="tj">Теперь, чтобы вычислить значение выражения, будем двигаться, следуя порождающим правилам, в обратном направлении. Сначала выполняется умножение 5*3, что дает 15. Потом это значение вычитается из 10, получается -5. И, наконец, последний шаг — присваивание этого значения переменной <kbd>count</kbd>, оно же является значением всего выражения.
<p class="tj">При создании интерпретатора Little С в первую очередь нужно построить алгоритмический эквивалент рассмотренной только что процедуры вычисления выражения.
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Сам знак равенства является, конечно, знаком операции присваивания.
</blockquote>
<p>
</p>
<hr><a href="../main.htm#29">Содержание</a> | <a href="2903.htm">&lt;&lt;&lt;</a> | <a href="2905.htm">&gt;&gt;&gt;</a>


</body></html>