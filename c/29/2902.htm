<!DOCTYPE HTML>
<html lang="ru">
<HEAD>
<TITLE>Определение языка Little C - cправочник по Си</TITLE>
<meta charset="utf-8"> 
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#29">Содержание</A> | <A href="2901.htm">&lt;&lt;&lt;</A> | <A href="2903.htm">&gt;&gt;&gt;</A><HR>
<H1>Определение языка Little C</H1>








<P class="tj">Количество зарезервированных слов языка С невелико, однако это богатый и мощный язык. Чтобы описать интерпретатор полного С и его реализацию, понадобился бы значительно больший объем, чем одна глава. Интерпретатор Little C (Малый С) предназначен для интерпретации довольно узкого подмножества С, включающего, тем не менее, многие важные средства языка. При определении конкретного состава подмножества языка Little С использовались два главных критерия:
<UL type=square>
<LI class="t">Неотделимо ли данное средство от языка?
<LI class="t">Необходимо ли оно для демонстрации важных аспектов языка?
</UL>
<P class="tj">Например, такие средства, как рекурсивные функции, глобальные и локальные переменные удовлетворяют обоим критериям. Интерпретатор Little С поддерживает все три вида циклов (наличие всех их, конечно, не обязательно в соответствии с первым критерием, но необходимо в соответствии со вторым критерием). Однако оператор <KBD>switch</KBD> не включен в интерпретатор, потому что он не является обязательным (он красив, но не необходим) и не иллюстрирует ничего такого, что нельзя было бы проиллюстрировать с помощью оператора <KBD>if</KBD> (который включен в интерпретатор). Реализация оператора <KBD>switch</KBD> оставлена читателю в качестве самостоятельного упражнения.
<P class="tj">Исходя из этих соображений, в интерпретатор Little С включены следующие средства языка:
<UL type=square>
<LI class="t">Параметризованные функции с локальными переменными
<LI class="t">Рекурсия
<LI class="t">Оператор <KBD>if</KBD>
<LI class="t">Циклы <KBD>do-while</KBD>, <KBD>while</KBD> и <KBD>for</KBD>
<LI class="t">Локальные и глобальные переменные типов <KBD>int</KBD> и <KBD>char</KBD>
<LI class="t">Параметры функций типов <KBD>int</KBD> и <KBD>char</KBD>
<LI class="t">Целые и символьные константы
<LI class="t">Строковые константы (ограниченная реализация)
<LI class="t">Оператор <KBD>return</KBD> (как со значением, так и без него)
<LI class="t">Ограниченный набор стандартных библиотечных функций
<LI class="t">Операторы <KBD>+</KBD>, <KBD>-</KBD>, <KBD>*</KBD>, <KBD>/</KBD>, <KBD>%</KBD>, <KBD>&lt;</KBD>, <KBD>&gt;</KBD>, <KBD>&lt;=</KBD>, <KBD>&gt;=</KBD>, <KBD>==</KBD>, <KBD>!=</KBD>, унарный <KBD>-</KBD>, унарный <KBD>+</KBD>
<LI class="t">Функции, возвращающие целое значение
<LI class="t">Комментарии вида <KBD>/*...*/</KBD>
</UL>
<P class="tj">Хоть этот набор и кажется небольшим, однако для его реализации требуется довольно объемный исходный текст программы. Одна из причин этого заключается в том, что при выполнении программы непосредственной работе интерпретатора предшествует значительная подготовительная работа программы, что обусловлено структурированностью языка.
<H2>Ограничение языка Little C</H2>
<P class="tj">Исходный текст программы интерпретатора Little С довольно длинный, фактически, длиннее, чем следовало бы помещать в книгу. С целью упрощения этого текста в грамматику Little С введены некоторые ограничения. Первое ограничение заключается в том, что телом операторов <KBD>if</KBD>, <KBD>while</KBD>, <KBD>do</KBD> и <KBD>for</KBD> может быть только блок, заключенный в фигурные скобки. Если телом является единственный оператор, он также должен быть заключен в фигурные скобки. Например, интерпретатор Little С не сможет правильно обработать следующий фрагмент программы:
<PRE>
for(a=0; a&lt;10; a=a+1)
  for(b=0; b&lt;10; b-b+1)
    for(c=0; с&lt;10; с=с+1)
      puts("привет");

if (...)
  if (...) х = 10;
</PRE>
<P class="tj">Этот фрагмент должен быть написан так:
<PRE>
for(a=0; a&lt;10; a=a+1) {
  for(b=0; b&lt;10; b-b+1) {
    for(c=0; с&lt;10; с=с+1) {
      puts("привет");
    }
  }
}
if (...) {
  if (...) {
    х = 10;
  }
}
</PRE>
<P class="tj">Благодаря этому ограничению интерпретатору легче найти конец участка программы, составляющего тело одного из операторов управления программой. К тому же, поскольку чаше всего операторы управления программой обрабатывают именно блок, это ограничение не выглядит слишком обременительным. При желании читатель может самостоятельно устранить это ограничение.
<P class="tj">Другое ограничение заключается в том, что не поддерживаются прототипы функций. Предполагается, что все функции возвращают тип <KBD>int</KBD>, разрешен возвращаемый тип <KBD>char</KBD>, но он преобразуется в <KBD>int</KBD>. Проверка правильности типа параметра не выполняется.
<P class="tj">Все локальные переменные должны быть объявлены в самом начале функции, сразу после открывающейся фигурной скобки. Локальные переменные не могут быть объявлены внутри какого-либо блока. Поэтому следующая функция в языке Little С является неправильной:
<PRE>
int myfunc()
{
   int i; /* это допустимо */
   if(1) {
     int i; /* в языке Little С это не допустимо */
   }
}
</PRE>
<P class="tj">Здесь объявление переменной <KBD>i</KBD> внутри блока <KBD>if</KBD> для интерпретатора Little С является недопустимым. Требование объявления локальных переменных только в начале функции немного упрощает реализацию интерпретатора. Для читателя не составит большого труда устранить это ограничение.
<P class="tj">И, наконец, последнее ограничение: определение каждой функции должно начинаться с зарезервированного слова <KBD>char</KBD> или <KBD>int</KBD>. Следовательно, интерпретатор Little С не поддерживает традиционное правило "<KBD>int</KBD> по умолчанию". Таким образом, следующее объявление является правильным:
<PRE>
int main()
{
   /* ... */
}
</PRE>
<P class="t">однако следующее объявление в языке Little С неправильное:
<PRE>
main()
{
   /* ... */
}
</PRE>
<P class="tj">Отказ от правила "<KBD>int</KBD> по умолчанию" приближает Little С к языкам С99 и C++.


<p>






</p>


<HR><A href="../main.htm#29">Содержание</A> | <A href="2901.htm">&lt;&lt;&lt;</A> | <A href="2903.htm">&gt;&gt;&gt;</A>
</BODY></HTML>