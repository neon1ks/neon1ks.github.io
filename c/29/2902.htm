<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Определение языка Little C - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#29">Содержание</a> | <a href="2901.htm">&lt;&lt;&lt;</a> | <a href="2903.htm">&gt;&gt;&gt;</a><hr>
<h1>Определение языка Little C</h1>
<p class="tj">Количество зарезервированных слов языка С невелико, однако это богатый и мощный язык. Чтобы описать интерпретатор полного С и его реализацию, понадобился бы значительно больший объем, чем одна глава. Интерпретатор Little C (Малый С) предназначен для интерпретации довольно узкого подмножества С, включающего, тем не менее, многие важные средства языка. При определении конкретного состава подмножества языка Little С использовались два главных критерия:
<ul type=square>
<li class="t">Неотделимо ли данное средство от языка?
<li class="t">Необходимо ли оно для демонстрации важных аспектов языка?
</ul>
<p class="tj">Например, такие средства, как рекурсивные функции, глобальные и локальные переменные удовлетворяют обоим критериям. Интерпретатор Little С поддерживает все три вида циклов (наличие всех их, конечно, не обязательно в соответствии с первым критерием, но необходимо в соответствии со вторым критерием). Однако оператор <kbd>switch</kbd> не включен в интерпретатор, потому что он не является обязательным (он красив, но не необходим) и не иллюстрирует ничего такого, что нельзя было бы проиллюстрировать с помощью оператора <kbd>if</kbd> (который включен в интерпретатор). Реализация оператора <kbd>switch</kbd> оставлена читателю в качестве самостоятельного упражнения.
<p class="tj">Исходя из этих соображений, в интерпретатор Little С включены следующие средства языка:
<ul type=square>
<li class="t">Параметризованные функции с локальными переменными
<li class="t">Рекурсия
<li class="t">Оператор <kbd>if</kbd>
<li class="t">Циклы <kbd>do-while</kbd>, <kbd>while</kbd> и <kbd>for</kbd>
<li class="t">Локальные и глобальные переменные типов <kbd>int</kbd> и <kbd>char</kbd>
<li class="t">Параметры функций типов <kbd>int</kbd> и <kbd>char</kbd>
<li class="t">Целые и символьные константы
<li class="t">Строковые константы (ограниченная реализация)
<li class="t">Оператор <kbd>return</kbd> (как со значением, так и без него)
<li class="t">Ограниченный набор стандартных библиотечных функций
<li class="t">Операторы <kbd>+</kbd>, <kbd>-</kbd>, <kbd>*</kbd>, <kbd>/</kbd>, <kbd>%</kbd>, <kbd>&lt;</kbd>, <kbd>&gt;</kbd>, <kbd>&lt;=</kbd>, <kbd>&gt;=</kbd>, <kbd>==</kbd>, <kbd>!=</kbd>, унарный <kbd>-</kbd>, унарный <kbd>+</kbd>
<li class="t">Функции, возвращающие целое значение
<li class="t">Комментарии вида <kbd>/*...*/</kbd>
</ul>
<p class="tj">Хоть этот набор и кажется небольшим, однако для его реализации требуется довольно объемный исходный текст программы. Одна из причин этого заключается в том, что при выполнении программы непосредственной работе интерпретатора предшествует значительная подготовительная работа программы, что обусловлено структурированностью языка.
<h2>Ограничение языка Little C</h2>
<p class="tj">Исходный текст программы интерпретатора Little С довольно длинный, фактически, длиннее, чем следовало бы помещать в книгу. С целью упрощения этого текста в грамматику Little С введены некоторые ограничения. Первое ограничение заключается в том, что телом операторов <kbd>if</kbd>, <kbd>while</kbd>, <kbd>do</kbd> и <kbd>for</kbd> может быть только блок, заключенный в фигурные скобки. Если телом является единственный оператор, он также должен быть заключен в фигурные скобки. Например, интерпретатор Little С не сможет правильно обработать следующий фрагмент программы:
<pre>
for(a=0; a&lt;10; a=a+1)
  for(b=0; b&lt;10; b-b+1)
    for(c=0; с&lt;10; с=с+1)
      puts("привет");
if (...)
  if (...) х = 10;
</pre>
<p class="tj">Этот фрагмент должен быть написан так:
<pre>
for(a=0; a&lt;10; a=a+1) {
  for(b=0; b&lt;10; b-b+1) {
    for(c=0; с&lt;10; с=с+1) {
      puts("привет");
    }
  }
}
if (...) {
  if (...) {
    х = 10;
  }
}
</pre>
<p class="tj">Благодаря этому ограничению интерпретатору легче найти конец участка программы, составляющего тело одного из операторов управления программой. К тому же, поскольку чаше всего операторы управления программой обрабатывают именно блок, это ограничение не выглядит слишком обременительным. При желании читатель может самостоятельно устранить это ограничение.
<p class="tj">Другое ограничение заключается в том, что не поддерживаются прототипы функций. Предполагается, что все функции возвращают тип <kbd>int</kbd>, разрешен возвращаемый тип <kbd>char</kbd>, но он преобразуется в <kbd>int</kbd>. Проверка правильности типа параметра не выполняется.
<p class="tj">Все локальные переменные должны быть объявлены в самом начале функции, сразу после открывающейся фигурной скобки. Локальные переменные не могут быть объявлены внутри какого-либо блока. Поэтому следующая функция в языке Little С является неправильной:
<pre>
int myfunc()
{
   int i; /* это допустимо */
   if(1) {
     int i; /* в языке Little С это не допустимо */
   }
}
</pre>
<p class="tj">Здесь объявление переменной <kbd>i</kbd> внутри блока <kbd>if</kbd> для интерпретатора Little С является недопустимым. Требование объявления локальных переменных только в начале функции немного упрощает реализацию интерпретатора. Для читателя не составит большого труда устранить это ограничение.
<p class="tj">И, наконец, последнее ограничение: определение каждой функции должно начинаться с зарезервированного слова <kbd>char</kbd> или <kbd>int</kbd>. Следовательно, интерпретатор Little С не поддерживает традиционное правило "<kbd>int</kbd> по умолчанию". Таким образом, следующее объявление является правильным:
<pre>
int main()
{
   /* ... */
}
</pre>
<p class="t">однако следующее объявление в языке Little С неправильное:
<pre>
main()
{
   /* ... */
}
</pre>
<p class="tj">Отказ от правила "<kbd>int</kbd> по умолчанию" приближает Little С к языкам С99 и C++.
<hr><a href="../main.htm#29">Содержание</a> | <a href="2901.htm">&lt;&lt;&lt;</a> | <a href="2903.htm">&gt;&gt;&gt;</a>


</body></html>