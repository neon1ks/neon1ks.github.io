<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Интерпретация структурированного языка - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head><body>
<a href="../main.htm#29">Содержание</a> | <a href="2902.htm">&lt;&lt;&lt;</a> | <a href="2904.htm">&gt;&gt;&gt;</a><hr>
<h1>Интерпретация структурированного языка</h1>
<p class="tj">Язык С структурирован. Это значит, что в нем определены отдельные подпрограммы с локальными переменными. В языке С также поддерживается рекурсия. Интересен тот факт, что для структурированного языка иногда легче написать компилятор, чем интерпретатор. Например, когда компилятор создает код вызова функции, он попросту заталкивает аргументы функции в системный стек и применяет к функции команду процессора CALL. При возврате функция записывает возвращаемое значение в регистр процессора, очищает стек и выполняет команду процессора RET. В то же время, если вызов функции выполняет интерпретатор, он должен на какое-то время "приостановиться", запомнить текущее состояние, найти функцию, выполнить ее, сохранить возвращаемое значение, возвратиться в исходную точку программы и восстановить состояние, существовавшее до вызова функции. Пример выполнения этих действий будет приведен далее при рассмотрении интерпретатора. В сущности, интерпретатор должен эмулировать (выполнить другими средствами) команды процессора CALL и RET. Поддержку рекурсии также значительно легче обеспечить в компиляторе, чем в интерпретаторе.
<p class="tj">В моей книге <em>The Art of C</em> (Berkeley, CA: Osborne/McGraw-Hill, 1991), вышедшей несколько лет назад, рассматривалась разработка интерпретатора языка small BASIC. В книге утверждается, что интерпретировать старую версию языка BASIC значительно легче, чем язык С, потому что BASIC изначально был предназначен для интерпретации. Он хорошо приспособлен к интерпретации благодаря своей неструктурированности. В нем все переменные являются глобальными и нет отдельных подпрограмм. Я по-прежнему придерживаюсь этого мнения, однако, если для интерпретатора создать средства поддержки функций, локальных переменных и рекурсии, то интерпретировать язык С станет легче, чем BASIC. Так получилось потому, что в языках типа BASIC на теоретическом уровне довольно много исключений из правил. Например, в нем знак равенства в операторе присваивания означает присваивание, а в операторе сравнения — равенство. Язык С почти полностью лишен подобных несуразностей.</p>
<table class="table table-bordered">
<tr><td class="tdnote">На заметку<td class="tj">Разработанная автором реализация интерпретатора языка small BASIC coдержит немало полезного для читателей, интересующихся интерпретаторами. Последняя версия интерпретатора small BASIC приведена в <em>The C/C++ Annotated Archives</em> (Berkley, CA: Osborne/McGraw-HilL 1999).
</table>
<p>
</p>
<hr><a href="../main.htm#29">Содержание</a> | <a href="2902.htm">&lt;&lt;&lt;</a> | <a href="2904.htm">&gt;&gt;&gt;</a>
</body></html>