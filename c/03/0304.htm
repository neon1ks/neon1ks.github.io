<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Лестница if-else-if - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#03">Содержание</a> | <a href="0303.htm">&lt;&lt;&lt;</a> | <a href="0305.htm">&gt;&gt;&gt;</a><hr>
<h1>Лестница if-else-if</h1>
<p class="tj">В программах часто используется конструкция, которую называют <em>лестницей if-else-if</em><sup><a href="#11" id="1">[1]</a></sup>. Общая форма лестницы имеет вид
<pre>
if (<em>выражение</em>) <em>оператор</em>;
else
  if (<em>выражение</em>) <em>оператор</em>;
  else
    if (<em>выражение</em>) <em>оператор</em>;
    .
    .
    .
    else <em>оператор</em>;
</pre>
<p class="tj">Работает эта конструкция следующим образом. Условные выражения операторов <kbd>if</kbd> вычисляются сверху вниз. После выполнения некоторого условия, т.е. когда встретится выражение, принимающее значение ИСТИНА, выполняется ассоциированный с этим выражением оператор, а оставшаяся часть лестницы пропускается. Если все условия ложны, то выполняется оператор в последней фразе <kbd>else</kbd>, а если последняя фраза <kbd>else</kbd> отсутствует, то в этом случае не выполняется ни один оператор.
<p class="tj">Недостаток предыдущей записи лестницы состоит в том, что с ростом глубины вложенности увеличивается количество отступов в строке. Это становится неудобным с технической точки зрения. Поэтому лестницу <kbd>if-else-if</kbd> обычно записывают так:
<pre>
if (<em>выражение</em>)
  <em>оператор</em>;
else if (<em>выражение</em>)
  <em>оператор</em>;
else if (<em>выражение</em>)
  <em>оператор</em>;
    .
    .
    .
else
  <em>оператор</em>;
</pre>
<p class="tj">Используя лестницу <kbd>if-else-if</kbd>, программу для игры в "магическое число" можно записать так:
<pre>
/* Магическое число, программа №4. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(void)
{
  int magic; /* магическое число */
  int guess; /* попытка игрока */
  magic = rand(); /* генерация магического числа */
  printf("Угадай магическое число: ");
  scanf("%d", &guess);
  if(guess == magic) {
    printf("** Верно ** ");
    printf("Магическое число равно %d\n", magic);
  }
  else if(guess &gt; magic)
    printf("Неверно, слишкое большое");
  else printf("Неверно, слишком малое");
  return 0;
}
</pre>
<h2>Оператор "?", альтернативный условному</h2>
<p class="tj">Оператор <kbd>?</kbd> можно использовать вместо оператора <kbd>if-else</kbd>, записанного в форме
<pre>
if (<em>условие</em>) <em>переменная</em> = <em>выражение</em>;
else <em>переменная</em> = <em>выражение</em>;
</pre>
<p class="tj">Оператор <kbd>?</kbd> является <em>тернарным</em>, потому что он имеет три операнда. Его общая форма следующая:
<pre><em>Выражение1</em> ? <em>Выражение2</em> : <em>Выражение3</em>;</pre>
<p class="tj">Обратите внимание на использование и расположение двоеточия.
<p class="tj">Результат операции <kbd>?</kbd> определяется следующим образом. Сначала вычисляется <em>Выражение1</em>. Если оно имеет значение ИСТИНА, вычисляется <em>Выражение2</em> и его значение становится результатом операции <kbd>?</kbd>. Если <em>Выражение1</em> имеет значение ЛОЖЬ, вычисляется <em>Выражение3</em> и его значение становится результатом операции <kbd>?</kbd>. Например:
<pre>
x = 10;
y = x&gt;9 ? 100 : 200;
</pre>
<p class="tj">В этом примере переменной <kbd>y</kbd> присваивается значение 100. Если бы <kbd>x</kbd> было меньше 9, то переменная <kbd>у</kbd> получила бы значение 200. То же самое можно записать, используя оператор <kbd>if-else</kbd>:
<pre>
x = 10;
if(x&gt;9) y = 100;
else y = 200;
</pre>
<p class="tj">В следующем примере оператор <kbd>?</kbd> используется для присвоения квадрату числа знака числа. (Само число вводится пользователем.) В этой программе при возведении в квадрат фактически сохраняется знак числа. Например, если пользователь введет 10, это число будет возведено в квадрат и в результате программа напечатает 100, а если пользователь введет число -10, то оно будет возведено в квадрат и результату будет приписан знак числа; в этом случае будет напечатано -100.
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
  int isqrd, i;
  printf("Введите число: ");
  scanf("%d", &i);
  isqrd = i&gt;0 ? i*i : -(i*i);
  printf("%d число в квадрате %d", i, isqrd);
  return 0;
}
</pre>
<p class="tj">(Обратите внимание, что в результате выполнения данной программы могут быть напечатаны не только верные утверждения. Не всегда компьютеры печатают только правильные результаты, если даже они работают без сбоев!)
<p class="tj">Оператор <kbd>?</kbd> можно использовать вместо <kbd>if-else</kbd> не только в операторе присваивания. Как известно, все функции (за исключением имеющих тип результата <kbd>void</kbd>) возвращают значение. Следовательно, в операторе <kbd>?</kbd> можно использовать вызовы функций. Когда в выражении встречается вызов функции, она выполняется, а возвращаемое ею значение используется при вычислении выражения. Это значит, что можно выполнить одну или несколько функций путем размещения их вызовов в выражениях оператора <kbd>?</kbd> в качестве операндов. Например:
<pre>
#include &lt;stdio.h&gt;
int f1(int n);
int f2(void);
int main(void)
{
  int t;
  printf("Введите число: ");
  scanf("%d", &t);
  /* печать соответствующего сообщения */
  t ? f1(t) + f2() : printf("Введен нуль.");
  printf("\n");
  return 0;
}
int f1(int n)
{
  printf("%d ", n);
  return 0;
}
int f2(void)
{
  printf(" введено ");
  return 0;
}
</pre>
<p class="tj">Эта программа сначала запрашивает число. При вводе нуля вызывается функция <kbd>printf()</kbd>, выводящая на экран сообщение введен нуль. При вводе отличного от нуля числа выполняются как <kbd>f1()</kbd>, так и <kbd>f2()</kbd>. Обратите внимание на то, что значение выражения <kbd>?</kbd> в этом примере не присваивается никакой переменной, оно просто отбрасывается.
<p class="tj">Следует помнить, что компилятор, пытаясь оптимизировать объектный код, может установить любой порядок вычисления значений операндов. В данном примере это значит, что функции <kbd>f1()</kbd> и <kbd>f2()</kbd> выполняются в произвольном порядке и сообщение введено может появиться как до, так и после числа.
<p class="tj">Используя оператор <kbd>?</kbd>, программу для игры в "магическое число" можно переписать следующим образом:
<pre>
/* Магическое число, программа №5. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(void)
{
  int magic; /* магическое число */
  int guess; /* попытка игрока */
  magic = rand(); /* генерация магического числа */
  printf("Угадай магическое число: ");
  scanf("%d", &guess);
  if(guess == magic) {
    printf("** Верно ** ");
    printf("Магическое число равно %d\n", magic);
  }
  else
    guess &gt; magic ? printf("Слишком большое") :
                       printf("Слишком малое");
  return 0;
}
</pre>
<p class="tj">В этой программе оператор <kbd>?</kbd> печатает соответствующее сообщение на основе проверки условия <kbd>guess &gt; magic</kbd>.
<h2>Условное выражение</h2>
<p class="tj">У начинающих программистов иногда возникают трудности в связи с тем, что в условном (управляющем) выражении операторов <kbd>if</kbd> или <kbd>?</kbd> могут стоять любые операторы, причем это не обязательно операторы отношения или логические (как в языках Basic или Pascal). В языке С значением результата управляющего выражения являются ИСТИНА или ЛОЖЬ, однако тип результата может быть любым скалярным типом. Считается, что любой ненулевой результат представляет значение ИСТИНА, а нулевой — ЛОЖЬ.
<p class="tj">В следующем примере программа считывает с клавиатуры два числа, вычисляет их отношение и выводит его на экран. Оператор <kbd>if</kbd> используется для того, чтобы избежать деления на нуль, если второе число равно нулю.
<pre>
/* Деление первого числа на второе. */
#include &lt;stdio.h&gt;
int main(void)
{
  int a, b;
  printf("Введите два числа: ");
  scanf("%d%d", &a, &b);
  if(b) printf("%d\n", a/b);
  else printf("Делить на нуль нельзя.\n");
  return 0;
}
</pre>
<p class="tj">Если управляющее выражение <kbd>b</kbd> равно 0, то его результат представляет значение ЛОЖЬ и выполняется оператор <kbd>else</kbd>. В противном случае (<kbd>b</kbd> не равно нулю) результат представляет значение ИСТИНА и выполняется деление чисел.
<p class="tj">В последнем примере оператор <kbd>if</kbd> можно записать так:
<pre>if(b != 0) printf("%d\n", a/b);</pre>
<p class="tj">Но следует отметить, что такая форма записи избыточна, она может привести к генерации неоптимального кода, кроме того, это считается признаком плохого стиля. Переменная <kbd>b</kbd> сама по себе представляет значение ИСТИНА или ЛОЖЬ, поэтому сравнивать ее с нулем нет необходимости.
<h2>Оператор выбора - switch</h2>
<p class="tj">Оператор выбора <kbd>switch</kbd> (часто его называют переключателем) предназначен для выбора ветви вычислительного процесса исходя из значения управляющего выражения. (При этом значение управляющего выражения сравнивается со значениями в списке целых или символьных констант. Если будет найдено совпадение, то выполнится ассоциированный с совпавшей константой оператор.) Общая форма оператора <kbd>switch</kbd> следующая:
<pre>
switch (<em>выражение</em>) {
  case <em>постоянная1</em>:
    <em>последовательность операторов</em>
    break;
  case <em>постоянная2</em>:
    <em>последовательность операторов</em>
    break;
  case <em>постоянная3</em>:
    <em>последовательность операторов</em>
    break;
  default:
    <em>последовательность операторов</em>;
}
</pre>
<p class="tj">Значение <em>выражения</em> оператора <kbd>switch</kbd> должно быть таким, чтобы его можно было выразить целым числом. Это означает, что в управляющем выражении можно использовать переменные целого или символьного типа, но только не с плавающей точкой. Значение управляющего <em>выражения</em> по очереди сравнивается с <em>постоянными</em> в операторах <kbd>case</kbd>. Если значение управляющего <em>выражения</em> совпадет с какой-то из <em>постоянных</em>, управление передается на соответствующую метку <kbd>case</kbd> и выполняется <em>последовательность операторов</em> до оператора <kbd>break</kbd>. Если оператор <kbd>break</kbd> отсутствует, выполнение последовательности операторов продолжается до тех пор, пока не встретится <kbd>break</kbd> (в другой метке) или не кончится тело оператора <kbd>switch</kbd> (т.е. блок, следующий за <kbd>switch</kbd>). Оператор <kbd>default</kbd> выполняется в том случае, когда значение управляющего выражения не совпало ни с одной постоянной. Оператор <kbd>default</kbd> также может отсутствовать. В этом случае при отсутствии совпадений не выполняется ни один оператор.
<p class="tj">Согласно Стандарту С89, оператор <kbd>switch</kbd> может иметь как минимум 257 операторов <kbd>case</kbd>. Стандарт С99 требует поддержки как минимум 1023 операторов <kbd>case</kbd>. Ели вы пишете программы вручную, такое большое количество операторов вам никогда не понадобится<sup><a href="#22" id="2">[2]</a></sup>. Оператор <kbd>case</kbd> — это метка, однако он не может быть использован сам по себе, вне оператора <kbd>switch</kbd>.
<p class="tj">Оператор <kbd>break</kbd> — это один из операторов безусловного перехода. Он может применяться не только в операторе <kbd>switch</kbd>, но и в циклах, (см. раздел "Операторы цикла"). Когда в теле оператора <kbd>switch</kbd> встречается оператор <kbd>break</kbd>, программа выходит из оператора <kbd>switch</kbd> и выполняет оператор, следующий за фигурной скобкой <kbd>}</kbd> оператора <kbd>switch</kbd>.
<p class="tj">Об операторе <kbd>switch</kbd> очень важно помнить следующее:
<ul class="square">
<li class="t">Оператор <kbd>switch</kbd> отличается от <kbd>if</kbd> тем, что в нем управляющее выражение проверяется только на равенство с постоянными, в то время как в <kbd>if</kbd> проверя ется любой вид отношения или логического выражения.
<li class="t">В одном и том же операторе <kbd>switch</kbd> никакие два оператора <kbd>case</kbd> не могут иметь равных постоянных. Конечно, если один <kbd>switch</kbd> вложен в другой, в их операторах <kbd>case</kbd> могут быть совпадающие постоянные.
<li class="t">Если в управляющем выражении оператора <kbd>switch</kbd> встречаются символьные константы, они автоматически преобразуются к целому типу по принятым в языке С правилам приведения типов.
</ul>
<p class="tj">Оператор <kbd>switch</kbd> часто используется для обработки команд с клавиатуры, например, при выборе пунктов меню. В следующем примере программа выводит на экран меню проверки правописания и вызывает соответствующую процедуру:
<pre>
void menu(void)
{
  char ch;
  printf("1. Проверка правописания\n");
  printf("2. Коррекция ошибок\n");
  printf("3. Вывод ошибок\n");
  printf("Для пропуска нажмите любую клавишу\n");
  printf("      Введите Ваш выбор: ");
  ch = getchar(); /* чтение клавиш */
  switch(ch) {
    case '1':
      check_spelling();
      break;
    case '2':
      correct_errors();
      break;
    case '3':
      display_errors();
      break;
    default :
      printf("Ни выбрана ниодна опция");
  }
}
</pre>
<p class="tj">С точки зрения синтаксиса, присутствие операторов <kbd>break</kbd> внутри <kbd>switch</kbd> не обязательно. Они прерывают выполнение последовательности операторов, ассоциированных с данной константой. Если оператор <kbd>break</kbd> отсутствует, то выполняется следующий оператор <kbd>case</kbd>, пока не встретится очередной <kbd>break</kbd>, или не будет достигнут конец тела оператора <kbd>switch</kbd>. Например, в функции <kbd>inp_handler()</kbd> (обработчик ввода драйвера) для упрощения программы несколько операторов <kbd>break</kbd> опущено, поэтому выполняются сразу несколько операторов <kbd>case</kbd>:
<pre>
/* Обработка значения i */
void inp_handler(int i)
{
  int flag;
  flag = -1;
  switch(i) {
    case 1:  /* Эти case эти общую */
    case 2:  /* последовательность операторов. */
    case 3:
      flag = 0;
      break;
    case 4:
      flag = 1;
    case 5:
      error(flag);
      break;
    default:
      process(i);
  }
}
</pre>
<p class="tj">Приведенный пример иллюстрирует следующие две особенности оператора <kbd>switch()</kbd>.
<p class="tj">Во-первых, оператор <kbd>case</kbd> может не иметь ассоциированной с ним последовательности операторов. Тогда управление переходит к следующему <kbd>case</kbd>. В этом примере три первых <kbd>case</kbd> вызывают выполнение одной и той же последовательности операторов, а именно:
<pre>
flag = 0;
break;
</pre>
<p class="tj">Во-вторых, если оператор <kbd>break</kbd> отсутствует, то выполняется последовательность операторов следующего <kbd>case</kbd>. Если <kbd>i</kbd> равно 4, то переменной <kbd>flag</kbd> присваивается значение 1 и, поскольку <kbd>break</kbd> отсутствует, выполнение продолжается и вызывается <kbd>error(flag)</kbd>. Если <kbd>i</kbd> равно 5, то <kbd>error()</kbd> будет вызвана со значением переменной <kbd>flag</kbd>, равным —1, а не 1.
<p class="tj">То, что при отсутствии <kbd>break</kbd> операторы <kbd>case</kbd> выполняются вместе, позволяет избежать ненужного дублирования операторов<sup><a href="#33" id="3">[3]</a></sup>.
<h2>Вложенные операторы switch</h2>
<p class="tj">Оператор <kbd>switch</kbd> может находиться в теле внешнего по отношению к нему оператора <kbd>switch</kbd>. Операторы <kbd>case</kbd> внутреннего и внешнего <kbd>switch</kbd> могут иметь одинаковые константы, в этом случае они не конфликтуют между собой. Например, следующий фрагмент программы вполне работоспособен:
<pre>
switch(x) {
  case 1:
    switch(y) {
      case 0: printf("Деление на нуль.\n");
              break;
      case 1: process(x,y);
              break;
    }
    break;
  case 2:
    .
    .
    .
</pre>
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Называется также <em>структурой выбора</em> или <em>конструкцией условного перехода</em>.
<p class="tj"><sup><a href="#2" id="22">[2]</a></sup>Если же для генерации программ вы используете макрогенераторы или генераторы компиляторов, например, уасс или lex, то на данное ограничение следует обратить внимание.
<p class="tj"><sup><a href="#3" id="33">[3]</a></sup>Но представляет собой опасность для забывчивых программистов.
</blockquote>
<hr><a href="../main.htm#03">Содержание</a> | <a href="0303.htm">&lt;&lt;&lt;</a> | <a href="0305.htm">&gt;&gt;&gt;</a>


</body>
</html>
