<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Оператор перехода - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head><body>
<a href="../main.htm#03">Содержание</a> | <a href="0305.htm">&lt;&lt;&lt;</a> | <a href="0307.htm">&gt;&gt;&gt;</a><hr>
<h1>Оператор перехода</h1>
<p class="tj">В языке С определены четыре оператора перехода: <kbd>return</kbd>, <kbd>goto</kbd>, <kbd>break</kbd> и <kbd>continue</kbd>. Операторы <kbd>return</kbd> и <kbd>goto</kbd> можно использовать в любом месте внутри функции. Операторы <kbd>break</kbd> и <kbd>continue</kbd> можно использовать в любом из операторов цикла. Как указывалось ранее в этой главе, <kbd>break</kbd> можно также использовать в операторе <kbd>switch</kbd>.
<h2>Оператор return</h2>
<p class="tj">Оператор <kbd>return</kbd> используется для выхода из функции. Отнесение его к категории операторов перехода обусловлено тем, что он заставляет программу перейти в точку вызова функции. Оператор <kbd>return</kbd> может иметь ассоциированное с ним значение, тогда при выполнении данного оператора это значение возвращается в качестве значения функции. В функциях типа <kbd>void</kbd> используется оператор <kbd>return</kbd> без значения.
<p class="tj">Стандарт С89 допускает наличие оператора <kbd>return</kbd> без значения, даже если тип функции отличен от <kbd>void</kbd>. В этом случае функция возвращает неопределенное значение. Но что касается языков С99 и C++, если тип функции отличен от <kbd>void</kbd>, то ее оператор <kbd>return</kbd> обязательно должен иметь значение. Конечно, и в программе на С89 отсутствие возвращаемого значения в функции, тип которой отличен от <kbd>void</kbd>, является признаком плохого стиля!
<p class="tj">Общая форма оператора <kbd>return</kbd> следующая:
<pre>return <em>выражение</em>;</pre>
<p class="tj"><em>Выражение</em> присутствует только в том случае, если функция возвращает значение. Это значение <em>выражения</em> становится возвращаемым значением функции.
<p class="tj">Внутри функции может присутствовать произвольное количество операторов <kbd>return</kbd>. Выход из функции происходит тогда, когда встречается один из них. Закрывающаяся фигурная скобка <kbd>}</kbd> также вызывает выход из функции. Выход программы на нее эквивалентен оператору <kbd>return</kbd> без значения. В этом случае функция, тип которой отличен от <kbd>void</kbd>, возвращает неопределенное значение.
<p class="tj">Функция, определенная со спецификатором <kbd>void</kbd>, не может содержать <kbd>return</kbd> со значением. Так как эта функция не возвращает значения, в ней не может быть оператора <kbd>return</kbd>, возвращающего значение. Более подробно <kbd>return</kbd> рассматривается в <a href="../06/06.htm">главе 6</a>.
<h2>Оператор goto</h2>
<p class="tj">Кроме <kbd>goto</kbd>, в языке С есть другие операторы управления (например <kbd>break</kbd>, <kbd>continue</kbd>), поэтому необходимости в применении <kbd>goto</kbd> практически нет. В результате чрезмерного использования операторов <kbd>goto</kbd> программа плохо читается, она становится "похожей на спагетти". Чаще всего такими программами недовольна администрация фирм, производящих программный продукт. То есть оператор <kbd>goto</kbd> весьма непопулярен, более того, считается, что в программировании не существует ситуаций, в которых нельзя обойтись без оператора <kbd>goto</kbd>. Но в некоторых случаях его применение все же уместно. Иногда, при умелом использовании, этот оператор может оказаться весьма полезным, например, если нужно покинуть глубоко вложенные циклы<sup><a href="#11" id="1">[1]</a></sup>. В данной книге оператор <kbd>goto</kbd> рассматривается только в этом разделе.
<p class="tj">Для оператора <kbd>goto</kbd> всегда необходима метка. <em>Метка</em> — это идентификатор с последующим двоеточием. Метка должна находится в той же функции, что и <kbd>goto</kbd>, переход в другую функцию невозможен. Общая форма оператора <kbd>goto</kbd> следующая:
<pre>
goto <em>метка</em>;
.
.
.
<em>метка</em>:
</pre>
<p class="tj">Метка может находиться как до, так и после оператора <kbd>goto</kbd>. Например, используя оператор <kbd>goto</kbd>, можно выполнить цикл от 1 до 100:
<pre>
x = 1;
loop1:
  x++;
  if(x&lt;=100) goto loop1;
</pre>
<h2>Оператор break</h2>
<p class="tj">Оператор <kbd>break</kbd> применяется в двух случаях. Во-первых, в операторе <kbd>switch</kbd> с его помощью прерывается выполнение последовательности <kbd>case</kbd> (см. раздел "Оператор выбора — switch" ранее в этой главе). В этом случае оператор <kbd>break</kbd> не передает управление за пределы блока. Во-вторых, оператор <kbd>break</kbd> используется для немедленного прекращения выполнения цикла без проверки его условия, в этом случае оператор <kbd>break</kbd> передает управление оператору, следующему после оператора цикла.
<p class="tj">Когда внутри цикла встречается оператор <kbd>break</kbd>, выполнение цикла безусловно (т.е. без проверки каких-либо условий.) прекращается и управление передается оператору, следующему за ним. Например, программа
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
  int t;
  for(t=0; t&lt;100; t++) {
    printf("%d ", t);
    if(t==10) break;
  }
  return 0;
}
</pre>
<p class="t">выводит на экран числа от 0 до 10. После этого выполнение цикла прекращается оператором <kbd>break</kbd>, условие <kbd>t &lt; 100</kbd> при этом игнорируется.
<p class="tj">Оператор <kbd>break</kbd> часто используется в циклах, в которых некоторое событие должно вызвать немедленное прекращение выполнения цикла. В следующем примере нажатие клавиши прекращает выполнение функции <kbd>look_up()</kbd>:
<pre>
void look_up(char *name)
{
  do {
    /* поиск имени 'name' */
    if(kbhit()) break;
  } while(!found);
  /* process match */
}
</pre>
<p class="tj">Библиотечная функция <kbd>kbhit()</kbd> возвращает 0, если клавиша не нажата (то есть, буфер клавиатуры пуст), в противном случае она возвращает ненулевое значение. В стандарте С функция <kbd>kbhit()</kbd> не определена, однако практически она поставляется почти с каждым компилятором (возможно, под несколько другим именем).
<p class="tj">Оператор <kbd>break</kbd> вызывает выход только из внутреннего цикла. Например, программа
<pre>
for(t=0; t&lt;100; ++t) {
  count = 1;
  for(;;) {
    printf("%d ", count);
    count++;
    if(count==10) break;
  }
}
</pre>
<p class="t">100 раз выводит на экран числа от 1 до 9. Оператор <kbd>break</kbd> передает управление внешнему циклу <kbd>for</kbd>.
<p class="tj">Если оператор <kbd>break</kbd> присутствует внутри оператора <kbd>switch</kbd>, который вложен в какие-либо циклы, то <kbd>break</kbd> относится только к <kbd>switch</kbd>, выход из цикла не происходит.
<h2>Функция exit()</h2>
<p class="tj">Функция <kbd>exit()</kbd> не является оператором языка, однако рассмотрим возможность ее применения. Аналогично прекращению выполнения цикла оператором <kbd>break</kbd>, можно прекратить работу программы и с помощью вызова стандартной библиотечной функции <kbd>exit()</kbd>. Эта функция вызывает немедленное прекращение работы всей программы и передает управление операционной системе.
<p class="tj">Общая форма функции <kbd>exit()</kbd> следующая:
<pre>void exit (int <em>код_возврата</em>);</pre>
<p class="tj">Значение переменной <em>код_возврата</em> передается вызвавшему программу процессу, обычно в качестве этого процесса выступает операционная система. Нулевое значение кода возврата обычно используется для указания нормального завершения работы программы. Другие значения указывают на характер ошибки. В качестве кода возврата можно использовать макросы <kbd>EXIT_SUCCESS</kbd> и <kbd>EXIT_FAILURE</kbd> (выход успешный и выход с ошибкой). Функция <kbd>exit()</kbd> объявлена в заголовочном файле <kbd>&lt;stdlib.h&gt;</kbd>.
<p class="tj">Функция <kbd>exit()</kbd> часто используется, когда обязательное условие работы программы не выполняется. Рассмотрим, например, компьютерную игру в виртуальной реальности, использующую специальный графический адаптер. Главная функция <kbd>main()</kbd> этой игры выглядит так:
<pre>
#include &lt;stdlib.h&gt;
int main(void)
{
   if(!virtual_graphics()) exit(1);
   play();
   /* ... */
}
/* .... */
</pre>
<p class="tj">Здесь <kbd>virtual_graphics()</kbd> возвращает значение ИСТИНА, если присутствует нужный графический адаптер. Если требуемого адаптера нет, вызов функции <kbd>exit(1)</kbd> прекращает работу программы.
<p class="tj">В следующем примере в новой версии ранее рассмотренной функции <kbd>menu()</kbd> вызов <kbd>exit()</kbd> используется для выхода из программы и возврата в операционную систему:
<pre>
void menu(void)
{
  char ch;
  printf("1. Проверка правописания\n");
  printf("2. Коррекция ошибок\n");
  printf("3. Вывод ошибок\n");
  printf("4. Выход\n");
  printf("      Введите Ваш выбор: ");
  do {
    ch = getchar(); /* чтение клавиши */
      switch(ch) {
        case '1':
          check_spelling();
          break;
        case '2':
          correct_errors();
          break;
        case '3':
          display_errors();
          break;
        case '4':
          exit(0); /* Возврат в ОС */
      }
    } while(ch!='1' && ch!='2' && ch!='3');
  }
</pre>
<h2>Оператор continue</h2>
<p class="tj">Можно сказать, что оператор <kbd>continue</kbd> немного похож на <kbd>break</kbd>. Оператор <kbd>break</kbd> вызывает прерывание цикла, a <kbd>continue</kbd> — прерывание текущей итерации цикла и осуществляет переход к следующей итерации. При этом все операторы до конца тела цикла пропускаются. В цикле <kbd>for</kbd> оператор <kbd>continue</kbd> вызывает выполнение операторов приращения и проверки условия цикла. В циклах <kbd>while</kbd> и <kbd>do-while</kbd> оператор <kbd>continue</kbd> передает управление операторам проверки условий цикла. В следующем примере программа подсчитывает количество пробелов в строке, введенной пользователем:
<pre>
/* Подсчет количества пробелов */
#include &lt;stdio.h&gt;
int main(void)
{
  char s[80], *str;
  int space;
  printf("Введите строку: ");
  gets(s);
  str = s;
  for(space=0; *str; str++) {
    if(*str != ' ') continue;
    space++;
  }
  printf("%d пробелов\n", space);
  return 0;
}
</pre>
<p class="tj">Каждый символ строки сравнивается с пробелом. Если сравниваемый символ не является пробелом, оператор <kbd>continue</kbd> передает управление в конец цикла <kbd>for</kbd> и выполняется следующая итерация. Если символ является пробелом, значение переменной <kbd>space</kbd> увеличивается на 1.
<p class="tj">В следующем примере оператор <kbd>continue</kbd> применяется для выхода из цикла <kbd>while</kbd> путем передачи управления на условие цикла:
<pre>
void code(void)
{
  char done, ch;
  done = 0;
  while(!done) {
    ch = getchar();
    if(ch=='$') {
      done = 1;
      continue;
    }
    putchar(ch+1); /* печать следующего в алфавитном
                      порядке символа */
  }
}
</pre>
<p class="tj">Функция <kbd>code</kbd> предназначена для кодирования сообщения путем замены каждого символа символом, код которого на 1 больше кода исходного символа в коде ASCII. Например, символ А заменяется символом В (если это латинские символы.). Функция прекращает работу при вводе символа <kbd>$</kbd>. При этом переменной <kbd>done</kbd> присваивается значение 1 и оператор <kbd>continue</kbd> передает управление на условие цикла, что и прекращает выполнение цикла.
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Уже одно это (чрезмерная вложенность и неожиданный выход сразу из нескольких циклов) может свидетельствовать о плохой структуре программы.
</blockquote>
<p>
</p>
<hr><a href="../main.htm#03">Содержание</a> | <a href="0305.htm">&lt;&lt;&lt;</a> | <a href="0307.htm">&gt;&gt;&gt;</a>
</body>
</html>
