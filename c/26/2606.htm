<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Скелет программы для Windows 2000 - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#26">Содержание</a> | <a href="2605.htm">&lt;&lt;&lt;</a> | <a href="2607.htm">&gt;&gt;&gt;</a><hr>
<h1>Скелет программы для Windows 2000</h1>
<p class="tj">Теперь, когда представлена вся необходимая предварительная информация, можно приступить к разработке минимального приложения для Windows 2000. Как уже говорилось, все программы для Windows 2000 имеют некоторые общие атрибуты. Скелет программы для Windows 2000, разработанный в этой главе, имеет все необходимые функциональные свойства. В мире Windows-программирования скелеты приложений (другими словами — программы-заготовки) используются довольно часто, поскольку "входная плата" при создании Windows-программ довольно значительна. В качестве примера, сравните, следующие показатели. В отличие от DOS-программ, у которых минимальный размер программы уложится всего в пять строк кода, минимальная программа для Windows составляет примерно пятьдесят строк.
<p class="tj">Минимальная программа для Windows 2000 содержит две функции: <kbd>WinMain()</kbd> и функцию окна. Функция <kbd>WinMain()</kbd> должна выполнить следующие общие действия:
<ol>
<li class="t">Описать класс окна;
<li class="t">Зарегистрировать этот класс в Windows 2000;
<li class="t">Создать окно данного класса;
<li class="t">Отобразить это окно;
<li class="t">Запустить выполнение цикла обработки сообщений.
</ol>
<p class="tj">Функция окна должна адекватно реагировать на все имеющие отношение к прикладной программе сообщения. Поскольку скелетная программа кроме отображения окна на экране дисплея больше ничего не делает, единственным сообщением, на которое она должна отреагировать, является сообщение о том, что пользователь прекратил выполнение программы.
<p class="tj">Перед тем как перейти к подробному обсуждению отдельных вопросов, рассмотрим следующую программу, которая представляет собой минимальный скелет программы для Windows 2000. Эта программа-заготовка создает стандартное окно, содержащее заголовок, кнопки системного меню, а также стандартные кнопки свертывания, развертывания и закрытия окна. Благодаря этому окно можно будет свернуть, развернуть, перемещать по экрану, изменять его размеры и, наконец, закрыть.
<pre>
/* Минимальный скелет программы для Windows 2000. */
#include &lt;windows.h&gt;
LRESULT CALLBACK WindowFunc(HWND, UINT, WPARAM, LPARAM);
char szWinName[] = "MyWin"; /* имя класса окна */
int WINAPI WinMain(HINSTANCE hThisInst, HINSTANCE hPrevInst,
                   LPSTR lpszArgs, int nWinMode)
{
  HWND hwnd;
  MSG msg;
  WNDCLASSEX wcl;
  /* Определим класс окна. */
  wcl.cbSize = sizeof(WNDCLASSEX);
  wcl.hInstance = hThisInst;     /* дескриптор даннонго экземпляра */
  wcl.lpszClassName = szWinName; /* имя класса окна */
  wcl.lpfnWndProc = WindowFunc;  /* функция окна */
  wcl.style = 0;                 /* стиль по умолчанию */
  wcl.hIcon = LoadIcon(NULL, IDI_APPLICATION); /* большая пиктограмма */
  wcl.hIconSm = NULL; /* использовать уменьшенный вариант большой
                         пиктограммы */
  wcl.hCursor = LoadCursor(NULL, IDC_ARROW);  /* стиль курсора */
  wcl.lpszMenuName = NULL; /* класс меню отсутствует */
  wcl.cbClsExtra = 0;      /* дополнительная память не требуется */
  wcl.cbWndExtra = 0;
  /* Сделаем белым цвет фона окна. */
  wcl.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH);
  /* Зарегистрируем класс окна. */
  if(!RegisterClassEx(&wcl)) return 0;
  /* Поскольку класс окна уже зарегистрирован, теперь может
     быть создано окно. */
  hwnd = CreateWindow(
    szWinName, /* имя класса окна */
    "Windows 2000 Skeleton", /* заголовок */
    WS_OVERLAPPEDWINDOW, /* стиль окна - стандартный */
    CW_USEDEFAULT, /* Координата X - пусть решает Windows */
    CW_USEDEFAULT, /* Координата Y - пусть решает Windows */
    CW_USEDEFAULT, /* Ширина - пусть решает Windows */
    CW_USEDEFAULT, /* Высота - пусть решает Windows */
    NULL,          /* Дескриптор родительского окна - родительское
                      окно отсутствует */
    NULL,          /* Дескриптор меню - меню отсутствует */
    hThisInst,     /* Дескриптор экземпляра */
    NULL           /* Дополнительные аргументы отсутствуют */
  );
  /* Отобразим окно. */
  ShowWindow(hwnd, nWinMode);
  UpdateWindow(hwnd);
  /* Создадим цикл оббработки сообщений. */
  while(GetMessage(&msg, NULL, 0, 0))
  {
    TranslateMessage(&msg); /* трансляция клавиатурных сообщений */
    DispatchMessage(&msg);  /* возвратить управление Windows 2000 */
  }
  return msg.wParam;
}
/* Эта функция вызывается Windows 2000 и пересылает
   сообщения из очереди сообщений.
*/
LRESULT CALLBACK WindowFunc(HWND hwnd, UINT message,
                            WPARAM wParam, LPARAM lParam)
{
  switch(message) {
    case WM_DESTROY: /* завершить программу */
      PostQuitMessage(0);
      break;
    default:
      /* Пусть Windows 2000 обрабатывает все сообщения, не
         перечисленные в предыдущем операторе switch. */
      return DefWindowProc(hwnd, message, wParam, lParam);
  }
  return 0;
}
</pre>
<p class="tj">Давайте тщательно, пункт за пунктом, проанализируем эту программу. Во-первых, все Windows-программы должны содержать заголовочный файл WINDOWS.H, Как уже упоминалось, этот файл (вместе с сопутствующими файлами) содержит прототипы функций API и всевозможные типы, макросы и описания, используемые самой Windows. Например, в файле WINDOWS.H (или в его придаточных файлах) определены типы данных <kbd>HWND</kbd> и <kbd>WNDCLASSEX</kbd>.
<p class="tj">Функция окна, используемая данной программой, называется <kbd>WindowFunc()</kbd>. Она объявлена как функция обратного вызова, поскольку именно эту функцию Windows вызывает для взаимодействия с данной программой.
<p class="tj">Как уже говорилось, работа программы начинается с выполнения <kbd>WinMain()</kbd>. Функции <kbd>WinMain()</kbd> передается четыре параметра. Из них <kbd>hThisInst</kbd> и <kbd>hPrevInst</kbd> — дескрипторы. Дескриптор <kbd>hThisInst</kbd> относится к текущему экземпляру программы. Помните, что Windows 2000 является многозадачной системой, поэтому одновременно может выполняться более одного экземпляра вашей программы. Для Windows 2000 дескриптор <kbd>hPrevInst</kbd> всегда принимает значение <kbd>NULL</kbd>. Параметр <kbd>lpszArgs</kbd> является указателем на строку, которая содержит аргументы командной строки, указанные при запуске приложения. В Windows 2000 эта строка содержит всю командную строку, в том числе и имя программы. Параметр <kbd>nWinMode</kbd> содержит значение, которое определяет то, как будет отображаться окно в момент, когда программа начнет выполняться.
<p class="tj">При выполнении данной функции в ней будут созданы три переменные. Переменная <kbd>hwnd</kbd> будет содержать дескриптор окна программы. Структурная переменная <kbd>msg</kbd> будет содержать сообщение окна, а структурная переменная <kbd>wcl</kbd> будет использоваться для описания класса окна.
<h2>Определение класса окна</h2>
<p class="tj">В первую очередь функция <kbd>WinMain()</kbd> выполняет два действия: определение класса окна, а затем его регистрация. Класс окна описывается путем заполнения необходимых значений в полях, определяемых структурой <kbd>WNDCLASSEX</kbd>. Вот эти поля:
<pre>
UINT cbSize;            /* размер структуры WNDCLASSEX */
UINT style;             /* тип окна */
WNDPROC lpfnWndProc;    /* адрес функции окна */
int cbClsExtra;         /* дополнительная память класса */
int cbWndExtra;         /* дополнительная память окна */
HINSTANCE hInstance;    /* дескриптор данного экземпляра */
HICON hIcon;            /* дескриптор большой пиктограммы */
HICON hIconSm;          /* дескриптор маленькой пиктограммы */
HCURSOR hCursor;        /* дескриптор указателя мыши */
HBRUSH hbrBackground;   /* цвет фона */
LPCSTR lpszMenuName;    /* имя главного меню */
LPCSTR lpszClassName;   /* имя класса окна */
</pre>
<p class="tj">Как видно из приведенного листинга, <kbd>cbSize</kbd> задает размер структуры <kbd>WNDCLASSEX</kbd>. Элемент <kbd>hInstance</kbd> определяет дескриптор текущего экземпляра и устанавливается в соответствии со значением дескриптора <kbd>hThisInst</kbd>. Имя класса окна указывается с помощью поля <kbd>lpszClassName</kbd>, которое в нашем случае указывает на строку <kbd>"MyWin"</kbd>. Адрес функции окна устанавливается в <kbd>lpfnWndProc</kbd>. В данной программе не назначается стиль по умолчанию, не требуется никакой дополнительной информации и не определяется главное меню. Хотя большинство программ содержат главное меню, в нем нет никакой необходимости для скелета приложения.
<p class="tj">Все Windows-приложения должны определять используемые по умолчанию формы (изображения) указателя мыши и пиктограммы приложения. Прикладная программа может определять свою собственную пользовательскую версию этих ресурсов или она может использовать один из встроенных стилей, что и создает скелет приложения. В любом случае дескрипторы этих ресурсов должны быть присвоены соответствующим элементам структуры <kbd>WNDCLASSEX</kbd>. Чтобы лучше понять, как это делается, начнем, пожалуй, с пиктограмм.
<p class="tj">Любое приложение для Windows 2000 имеет две связанные с ним пиктограммы: одна большая и одна маленькая. Маленькая пиктограмма используется в том случае, когда окно приложения свернуто. Эта же пиктограмма используется для отображения значка системного меню программы. Большая пиктограмма отображается на экране в том случае, когда вы перемещаете или копируете свое приложение на рабочий стол Windows. Как правило, большие пиктограммы представляют собой растровые изображения размером 32x32 пикселя, а маленькие — размером 16x16 пикселей. Большая пиктограмма загружается посредством API-функции <kbd>LoadIcon()</kbd>, чей прототип приведен ниже:
<pre>HICON LoadIcon(HINSTANCE <em>hInst</em>, LPCSTR <em>lpszName</em>);</pre>
<p class="tj">Эта функция возвращает дескриптор пиктограммы, а в случае аварийного завершения — значение <kbd>NULL</kbd>. В приведенном примере <em>hInst</em> определяет дескриптор модуля, который содержит пиктограмму, а ее название определяется параметром <em>lpszName</em>. Впрочем, чтобы воспользоваться одной из встроенных пиктограмм, необходимо использовать <kbd>NULL</kbd> для первого параметра и указать один из следующих макросов в качестве второго параметра:</p>
<table class="table table-bordered">
<tr><th><em>Макрос пиктограммы</em><th><em>Картинка</em>
<tr><td>IDI_APPLICATION<td>Пиктограмма по умолчанию
<tr><td>IDI_ERROR<td>Символ ошибки
<tr><td>IDI_INFORMATION<td>Символ информации
<tr><td>IDI_QUESTION<td>Знак вопроса
<tr><td>IDI_WARNING<td>Восклицательный знак
<tr><td>IDI_WINLOGO<td>Логотип Windows
</table>
<p class="tj">При загрузке пиктограмм следует обратить особое внимание на два важных момента. Во-первых, если ваше приложение не определяет маленькую пиктограмму, будет исследован ресурсный файл большой пиктограммы. Если в нем содержится маленькая пиктограмма, то именно она и будет использована. В противном случае при необходимости маленькая пиктограмма будет получена в результате уменьшения (пропорционального сжатия) большой пиктограммы. Если вы не хотите определять маленькую пиктограмму, присвойте значение <kbd>NULL</kbd> параметру <kbd>hIconSm</kbd> — именно так и поступает наша программа-заготовка. Во-вторых, функция <kbd>LoadIcon()</kbd>, вообще говоря, может применяться только для загрузки большой пиктограммы. Для загрузки пиктограмм произвольного размера можно воспользоваться функцией <kbd>LoadImage()</kbd>.
<p class="tj">Чтобы загрузить указатель мыши, используйте API-функцию <kbd>LoadCursor()</kbd>. Данная функция имеет следующий прототип:
<pre>HCURSOR LoadCursor(HINSTANSE <em>hInst</em>, LPCSTR <em>lpszName</em>);</pre>
<p class="tj">Эта функция возвращает дескриптор ресурса курсора или <kbd>NULL</kbd> в случае аварийного завершения. В данном примере <em>hInst</em> определяет дескриптор модуля, содержащего курсор мыши, а его имя указывается в параметре <em>lpszName</em>. Чтобы воспользоваться одним из встроенных указателей мыши, необходимо использовать <kbd>NULL</kbd> в качестве первого параметра и задать макрос одного из встроенных курсоров мыши в качестве второго параметра. Ниже приведено несколько встроенных курсоров:</p>
<table class="table table-bordered">
<tr><th><em>Макрос курсора мыши</em><th><em>Форма</em>
<tr><td>IDC_ARROW<td>Указатель-стрелка по умолчанию
<tr><td>IDC_CROSS<td>Перекрестие
<tr><td>IDC_HAND<td>Рука
<tr><td>IDC_IBEAM<td>Вертикальная двутавровая балка
<tr><td>IDC_WAIT<td>Песочные часы
</table>
<p class="tj">В качестве цвета фона окна, созданного скелетом программы, выбран белый цвет, а дескриптор <em>кисти</em> (<em>brush</em>) получается с помощью API-функции <kbd>GetStockObject()</kbd>. Кисть является ресурсом, который окрашивает экран с учетом предварительно заданных размера, цвета и узора. Функция <kbd>GetStockObject()</kbd> применяется для получения дескриптора ряда стандартных объектов отображения, в том числе кистей, перьев (которые проводят линии) и шрифтов символов. Вот его прототип:
<pre>HGDIOBJ GetStockObject(int <em>object</em>);</pre>
<p class="tj">Данная функция возвращает дескриптор объекта, определенного параметром <em>object</em>. В случае аварийного завершения возвращается значение <kbd>NULL</kbd>. (Тип <kbd>HGDIOBJ</kbd> относится к GDI-дескрипторам). Ниже приведено несколько встроенных кистей, доступных вашей программе:</p>
<table class="table table-bordered">
<tr><th><em>Имя макроса</em><th><em>Тип фона</em>
<tr><td>BKACK_BRUSH<td>Темно серый
<tr><td>DKGRAY_BRUSH<td>Полупрозрачный (видно сквозь окно)
<tr><td>HOLLOW_BRUSH<td>Черный
<tr><td>LTGRAY_BRUSH<td>Светло серый
<tr><td>WHITE_BRUSH<td>Белый
</table>
<p class="tj">Для получения кисти можно использовать эти макросы в качестве параметров функции <kbd>GetStockObject()</kbd>.
<p class="tj">После того как класс окна полностью определен, он регистрируется в Windows 2000 с помощью API-функции <kbd>RegisterClassEx()</kbd>, прототип которой приведен ниже:
<pre>ATOM RegisterClassEx(CONST WNDCLASSEX <em>*lpWClass</em>);</pre>
<p class="tj">Эта функция возвращает значение, которое идентифицирует класс окна. <kbd>ATOM</kbd> является <kbd>typedef</kbd>-описанием типа, которое подразумевает тип <kbd>WORD</kbd>. Каждый класс окна принимает уникальное значение. Параметр <em>lpWClass</em> должен содержать адрес структуры <kbd>WNDCLASSEX</kbd>.
<h2>Создание окна</h2>
<p class="tj">После того, как класс окна определен и зарегистрирован, ваше приложение может на самом деле создать окно этого класса с помощью API-функции <kbd>CreateWindow()</kbd>, прототип которой выглядит следующим образом:
<pre>
HWND CreateWindow(
  LPCSTR <em>lpszClassName</em>,    /* название класса окна */
  LPCSTR <em>lpszWinName</em>,      /* заголовок окна */
  Dword <em>dwStyle</em>,           /* тип окна */
  int <em>X</em>, int <em>Y</em>,            /* координаты верхней левой точки */
  int <em>Width</em>, int <em>Height</em>,   /* размеры окна */
  HWDN <em>hParent</em>,            /* дескриптор родительского окна */
  HMENU <em>hMenu</em>,             /* дескриптор главного меню */
  HINSTANCE <em>hThisInst</em>,     /* дескриптор создателя */
  LPVOID <em>lpszAdditional</em>,   /* указатель на дополнительную
                              информацию */
);
</pre>
<p class="tj">Как видно из листинга скелета программы, многим параметрам функции <kbd>СrеateWindow()</kbd> значения могут присваиваться по умолчанию или же в качестве значения им можно присвоить <kbd>NULL</kbd>. В действительности, в качестве параметров <em>X</em>, <em>Y</em>, <em>Width</em> и <em>Height</em> чаще всего используется макрос <kbd>CW_USEDEFAULT</kbd>; в этом случае Windows 2000 выбирает подходящий размер и местоположение окна. Если данное окно не имеет родительского окна (а именно этот случай имеет место в нашем скелете программы), то в качестве параметра <em>hParent</em> может быть указан <kbd>NULL</kbd>. (Для указания значения этого параметра можно также использовать <kbd>HWND_DESKTOP</kbd>.) Если окно не содержит главного меню или использует главное меню, которое определено посредством класса окна, то параметр <em>hMenu</em> должен иметь значение <kbd>NULL</kbd>. (Параметр <em>hMenu</em> имеет также и другие применения.) К тому же, если никакая дополнительная информация не требуется, что характерно для большинства случаев, то параметру <em>lpszAdditional</em> можно присвоить значение <kbd>NULL</kbd>. (Тип <kbd>LPVOID</kbd> переопределяется оператором <kbd>typedef</kbd> как <kbd>void*</kbd>. Исторически сложилось так, что <kbd>LPVOID</kbd> обозначает длинный указатель на <kbd>void</kbd>.)
<p class="tj">Значения остальных четырех параметров должны быть явно установлены прикладной программой. Во-первых, параметр <em>lpszClassName</em> должен указывать на имя класса окна. (Это то имя, которое вы дали окну при его регистрации.) Заголовок окна — это последовательность символов, на которую указывают посредством <em>lpszWinName</em>. Это может быть и пустая строка, но, как правило, окну следует давать какой-то заголовок. Стиль (или тип) окна, созданного в действительности, определяется значением параметра <em>dwStyle</em>. Макрос <kbd>WS_OVERLAPPEDWINDOW</kbd> определяет стандартное окно, которое имеет системное меню, обрамление и кнопки свертывания, развертывания и закрытия окна. Хотя чаще всего используется именно такой стиль окна, вы можете построить окно, удовлетворяющее вашим собственным критериям. Для этого просто объедините с помощью оператора <kbd>OR</kbd> макросы различных необходимых вам стилей. Ниже приведены некоторые часто встречающиеся стили:</p>
<table class="table table-bordered">
<tr><th><em>Макрос стиля</em><th><em>Функция Windows</em>
<tr><td>WS_OVERLAPPED<td>Перекрывающееся окно с обрамлением
<tr><td>WS_MAXIMIZEBOX<td>Кнопка развертывания
<tr><td>WS_MINIMIZEBOX<td>Кнопка свертывания
<tr><td>WS_SYSMENU<td>Системное меню
<tr><td>WS_HSCROLL<td>Горизонтальная полоса прокрутки
<tr><td>WS_VSCROLL<td>Вертикальная полоса прокрутки
</table>
<p class="tj">Параметр <em>hThisInst</em> игнорируется операционной системой Windows 2000, но для Windows 95/98 он должен содержать дескриптор текущего экземпляра приложения. Поэтому, чтобы обеспечить совместимость с этими средами, а заодно и предотвратить проблемы в будущем, параметру <em>hThisInst</em> рекомендуется присваивать значение дескриптора текущего экземпляра, как это сделано в нашем скелете программы.
<p class="tj">Функция <kbd>CreateWindow()</kbd> возвращает дескриптор созданного ею окна или <kbd>NULL</kbd>, если окно не может быть создано.
<p class="tj">Даже после создания окна оно все еще не отображается на экране дисплея. Чтобы отобразить окно, надо вызвать API-функцию <kbd>ShowWindow()</kbd>. Эта функция имеет следующий прототип:
<pre>BOOL ShowWindow(HWND <em>hwnd</em>, int <em>nHow</em>);</pre>
<p class="tj">Дескриптор отображаемого дисплеем окна указывается в параметре <em>hwndM</em>. А параметром <em>nHow</em> определяется режим отображения. Если окно выводится на экран в первый раз, целесообразно в качестве параметра <em>nHow</em> указать значение параметра <kbd>nWinMode</kbd> функции <kbd>WinMain()</kbd>. Значение <kbd>nWinMode</kbd> определяет способ отображения окна сразу после запуска программы на выполнение. Последующие вызовы могут при необходимости отобразить окно в нужном виде или вовсе удалить его. Некоторые общеупотребительные значения параметра <em>nHow</em> приведены ниже:</p>
<table class="table table-bordered">
<tr><th><em>Макрос отображения</em><th><em>Получаемый эффект</em>
<tr><td>SW_HIDE<td>Удаляет окно с экрана
<tr><td>SW_MINIMIZE<td>Свертывает окно в пиктограмму
<tr><td>SW_MAXIMIZE<td>Развертывает окно
<tr><td>SW_RESTORE<td>Возвращает окну обычный размер
</table>
<p class="tj">Функция <kbd>ShowWindow()</kbd> возвращает статус предыдущего режима отображения окна. Если окно выводилось на экран, то возвращается ненулевое значение. А если окно не отображалось на экране, то возвращается нуль.
<p class="tj">Хотя с формальной точки зрения для скелета программы это и не обязательно, все же в его текст включен вызов функции <kbd>UpdateWindow()</kbd>, поскольку она необходима практически для всех Windows 2000-приложений. По существу, она указывает, что Windows 2000 должна послать вашему приложению сообщение о том, что его главное окно необходимо обновить.
<h2>Цикл обработки сообщений</h2>
<p class="tj">Финальная часть функции <kbd>WinMain()</kbd> заготовки прикладной программы относится к <em>циклу обработки сообщений</em>. Цикл обработки сообщений является составной частью всех Windows-приложений. Его назначение — принять и обработать сообщение, посланное Windows 2000. Во время выполнения прикладной программы ей постоянно посылаются сообщения. Все эти сообщения сохраняются в очереди сообщений приложения и находятся там до тех пор, пока они не будут извлечены и обработаны. Всякий раз, когда приложение готово извлечь следующее сообщение, оно должно вызвать API-функцию <kbd>GetMessage()</kbd>, имеющую следующий прототип:
<pre>BOOL GetMessage(LPMSG <em>msg</em>, HWND <em>hwnd</em>, UINT <em>min</em>, UINT <em>max</em>);</pre>
<p class="tj">Сообщение будет записано в структуру, на которую указывает параметр <em>msg</em>. Все сообщения Windows имеют тип структуры <kbd>MSG</kbd>, представленный ниже:
<pre>
/* Структура сообщения */
typedef stuct tagMSG
{
  HWND hwnd;     /* окно, для которого предназначено сообщение */
  UINT message;  /* сообщение */
  WPARAM wParam; /* информация, обусловленная сообщением */
  LPARAM lParam; /* дополнительная информация, обусловленная
                    сообщением */
  DWORD time;    /* время, когда было отправлено сообщение */
  POINT pt;      /* координаты X и Y местоположения указателя мыши */
} MSG;
</pre>
<p class="tj">В структуре <kbd>MSG</kbd> дескриптор окна, которому предназначается сообщение, содержится в <kbd>hwnd</kbd>. Все сообщения в Windows 2000 являются 32-разрядными целыми числами, а само сообщение содержится в поле <kbd>message</kbd>. В зависимости от конкретного сообщения обусловленная им дополнительная информация передается в <kbd>wParam</kbd> и <kbd>lParam</kbd>. Оба типа <kbd>WPARAM</kbd> и <kbd>LPARAM</kbd> являются 32-разрядными значениями.
<p class="tj">Время, когда было отправлено (зарегистрировано) сообщение, определяется в миллисекундах в поле <kbd>time</kbd>.
<p class="tj">Элемент <kbd>pt</kbd> содержит координаты указателя мыши в тот момент, когда было отправлено сообщение. Координаты хранятся в структуре <kbd>POINT</kbd>, которая определяется следующим образом:
<pre>
typedef stuct tagPOINT {
  LONG x, y;
} POINT;
</pre>
<p class="tj">Если в очереди сообщений приложения отсутствуют сообщения, то вызов функции <kbd>GetMessage()</kbd> приведет к передаче управления обратно Windows 2000.
<p class="tj">Параметр <em>hwnd</em> функции <kbd>GetMessage()</kbd> определяет, для какого окна будут получены сообщения. Ведь часто приложение имеет несколько окон, и иногда необходимо принимать сообщения только для конкретного окна. Ну а если этому параметру присвоить значение <kbd>NULL</kbd>, то в ваше приложение будут направляться все сообщения.
<p class="tj">Оставшиеся два параметра функции <kbd>GetMessage()</kbd> определяют диапазон получаемых сообщений. Обычно приложение должно принимать все сообщения. Для этого необходимо оба параметра (и <kbd>min</kbd>, и <kbd>max</kbd>) установить равными нулю; именно так и сделано в скелете программы.
<p class="tj">Функция <kbd>GetMessage()</kbd> возвращает нуль, когда пользователь прекращает работу программы, что приводит к завершению цикла обработки сообщений. Во всех остальных случаях данная функция возвращает ненулевое значение. Если происходит ошибка, эта функция возвращает -1. Ошибка может произойти только при необычных обстоятельствах, которые не приемлемы для работы большинства программ.
<p class="tj">Внутри цикла обработки сообщений осуществляется вызов двух функций. Первая — это API-функция <kbd>TranslateMessage()</kbd>. Эта функция транслирует генерируемые операционной системой Windows 2000 виртуальные коды клавиш в символьные сообщения. Хотя ее применение необязательно во всех приложениях, в большинстве из них все же используется вызов функции <kbd>TranslateMessage()</kbd>, поскольку она необходима для осуществления полной интеграции клавиатуры в вашу прикладную программу.
<p class="tj">После того как сообщение было извлечено и преобразовано, оно отсылается обратно в Windows 2000 с помощью API-функции <kbd>DispatchMessage()</kbd>. Затем Windows 2000 хранит это сообщение до тех пор, пока не сможет передать его функции окна вашей программы.
<p class="tj">Как только завершается цикл обработки сообщений, выполнение функции <kbd>WinMain()</kbd> заканчивается, при этом она возвращает Windows 2000 значение <kbd>msg.wParam</kbd>. Это значение содержит код возврата, генерируемый при завершении выполнения прикладной программы.
<h2>Функция окна</h2>
<p class="tj">Второй функцией в скелете приложения является его функция окна. В нашем случае эта функция названа <kbd>WindowFunc()</kbd>, хотя она может носить любое понравившееся вам имя. Сообщения передаются функции окна посредством Windows 2000. Первые четыре элемента структуры <kbd>MSG</kbd> являются его параметрами. Из них единственным параметром, который используется скелетом программы, является собственно сообщение.
<p class="tj">Функция окна нашей программы-заготовки реагирует явным образом только на одно сообщение: <kbd>WM_DESTROY</kbd>. Такое сообщение посылается тогда, когда пользователь прекращает работу приложения. После получения такого сообщения программа должна осуществить вызов API-функции <kbd>PostQuitMessage()</kbd>. Аргументом этой функции является код возврата, который помещается в <kbd>msg.wParam</kbd> внутри функции <kbd>WinMain()</kbd>. Вызов <kbd>PostQuitMessage()</kbd> приводит к передаче приложению сообщения <kbd>WM_QUIT</kbd>, что заставляет функцию <kbd>GetMessage()</kbd> возвратить значение ЛОЖЬ (false) и, следовательно, прекратить работу вашей программы.
<p class="tj">Все остальные сообщения, принимаемые функцией <kbd>WindowFunc()</kbd>, передаются операционной системе Windows 2000 посредством вызова <kbd>DefWindowProc()</kbd> для стандартной обработки по умолчанию. Этот этап необходим, поскольку все сообщения так или иначе должны быть обработаны.
<p class="tj">Каждое сообщение устанавливает некоторое значение, которое должно быть возвращено функцией окна после обработки сообщения. Обычно после обработки большей части сообщений необходимо возвращать нулевое значение. Но после обработки некоторых сообщений требуется возвратить другой код возврата.
<p>
</p>
<hr><a href="../main.htm#26">Содержание</a> | <a href="2605.htm">&lt;&lt;&lt;</a> | <a href="2607.htm">&gt;&gt;&gt;</a>


</body>
</html>
