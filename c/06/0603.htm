<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Аргументы функции - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#06">Содержание</a> | <a href="0602.htm">&lt;&lt;&lt;</a> | <a href="0604.htm">&gt;&gt;&gt;</a><hr>
<h1>Аргументы функции</h1>
<p class="tj">Если функция должна принимать аргументы, то в ее объявлении следует декларировать параметры, которые примут значения этих аргументов. Как видно из объявления следующей функции, объявления параметров стоят после имени функции.
<pre>
/* Возвращает 1, если символ c входит в строку s;
   и 0 в противном случае. */
int is_in(char *s,  char c)
{
  while(*s)
    if(*s==c) return 1;
    else s++;
  return 0;
}
</pre>
<p class="tj">Функция <kbd>is_in()</kbd> имеет два параметра: <kbd>s</kbd> и <kbd>d</kbd>. Если символ <kbd>c</kbd> входит в строку <kbd>s</kbd>, то эта функция возвращает 1, в противном случае она возвращает 0.
<p class="tj">Хотя параметры выполняют специальную задачу, — принимают значения аргументов, передаваемых функции, — они все равно ведут себя так, как и другие локальные переменные. Формальным параметрам функции, например, можно присваивать какие-либо значения или использовать эти параметры в каких-либо выражениях.
<h2>Вызовы по значению и по ссылке</h2>
<p class="tj">В языках программирования имеется два способа передачи значений подпрограмме. Первый из них — <em>вызов по значению</em>. При его применении в формальный параметр подпрограммы копируется значение аргумента. В таком случае изменения параметра на аргумент не влияют.
<p class="tj">Вторым способом передачи аргументов подпрограмме является <em>вызов по ссылке</em>. При его применении в параметр копируется адрес аргумента. Это значит, что, в отличие от вызова по значению, изменения значения параметра приводят к точно таким же изменениям значения аргумента.
<p class="tj">За небольшим количеством исключений, в языке С для передачи аргументов используется вызов по значению. Обычно это означает, что код, находящийся внутри функции, не может изменять значений аргументов, которые использовались при вызове функции.
<p class="tj">Проанализируйте следующую программу:
<pre>
#include &lt;stdio.h&gt;
int sqr(int x);
int main(void)
{
  int t=10;
  printf("%d %d", sqr(t), t);
  return 0;
}
int sqr(int x)
{
  x = x*x;
  return(x);
}
</pre>
<p class="tj">В этом примере в параметр <kbd>х</kbd> копируется 10 — значение аргумента для <kbd>sqr()</kbd>. Когда выполняется присваивание <kbd>х=х*х</kbd>, модифицируется только локальная переменная <kbd>х</kbd>. А значение переменной <kbd>t</kbd>, использованной в качестве аргумента при вызове <kbd>sqr()</kbd>, по-прежнему остается равным 10. Поэтому выведено будет следующее: <kbd>100.10</kbd>.
<p class="tj">Помните, что именно копия значения аргумента передается в функцию. А то, что происходит внутри функции, не влияет на значение переменной, которая была использована при вызове в качестве аргумента.
<h2>Вызов по ссылке</h2>
<p class="tj">Хотя в С для передачи параметров применяется вызов по значению, можно создать вызов и по ссылке, передавая не сам аргумент, а указатель на него<sup><a href="#11" id="1">[1]</a></sup>. Так как функции передается адрес аргумента, то ее внутренний код в состоянии изменить значение этого аргумента, находящегося, между прочим, за пределами самой функции.
<p class="tj">Указатель передается функции так, как и любой другой аргумент. Конечно, в таком случае параметр следует декларировать как один из типов указателей. Это можно увидеть на примере функции <kbd>swap()</kbd>, которая меняет местами значения двух целых переменных, на которые указывают аргументы этой функции:
<pre>
void swap(int *x, int *y)
{
  int temp;
  temp = *x;  /* сохранить значение по адресу x */
  *x = *y;    /* поместить y в x */
  *y = temp;  /* поместить x в y */
}
</pre>
<p class="tj">Функция <kbd>swap()</kbd> может выполнять обмен значениями двух переменных, на которые указывают <kbd>х</kbd> и <kbd>y</kbd>, потому что передаются их адреса, а не значения. Внутри функции, используя стандартные операции с указателями, можно получить доступ к содержимому переменных и провести обмен их значений<sup><a href="#22" id="2">[2]</a></sup>.
<p class="tj">Помните, что <kbd>swap()</kbd> (или любую другую функцию, в которой используются параметры в виде указателей) необходимо вызывать вместе с адресами аргументов<sup><a href="#33" id="3">[3]</a></sup>. Следующая программа показывает, как надо правильно вызывать <kbd>swap()</kbd>:
<pre>
#include &lt;stdio.h&gt;
void swap(int *x, int *y);
int main(void)
{
  int i, j;
  i = 10;
  j = 20;
  printf("i и j перед обменом значениями: %d %d\n", i, j);
  swap(&i, &j); /* передать адреса переменных i и j */
  printf("i и j после обмена значениями: %d %d\n", i, j);
  return 0;
}
void swap(int *x, int *y)
{
  int temp;
  temp = *x;  /* сохранить значение по адресу x */
  *x = *y;    /* поместить y в x */
  *y = temp;  /* поместить x в y */
}
</pre>
<p class="tj">И вот что вывела эта программа:
<pre>
i и j перед обменом значениями: 10 20
i и j после обмена значениями: 20 10
</pre>
<p class="tj">В программе переменной <kbd>i</kbd> присваивается значение 10, а переменной <kbd>j</kbd> — значение 20. Затем вызывается функция <kbd>swap()</kbd> с адресами этих переменных. (Для получения адреса каждой из переменных используется унарный оператор <kbd>&</kbd>.) Поэтому в <kbd>swap()</kbd> передаются адреса переменных <kbd>i</kbd> и <kbd>j</kbd>, а не их значения.</p>
<table class="table table-bordered">
<tr><td class="tdnote">На заметку<td class="tj">Язык C++ при помощи параметров-ссылок дает возможность полностью автоматизировать вызов по ссылке. А в языке С параметры-ссылки не поддерживается
</table>
<h2>Вызов функций с помощью массивов</h2>
<p class="tj">Подробно о массивах рассказывалось в <a href="../04/04.htm">главе 4</a>. В настоящем же разделе рассказывается о передаче массивов функциям в качестве аргументов. Этот вопрос рассматривается потому, что эта операция является исключением по отношению к обычной передаче параметров, выполняемой путем вызова по значению<sup><a href="#44" id="4">[4]</a></sup>.
<p class="tj">Когда в качестве аргумента функции используется массив, то функции передается его адрес. В этом и состоит исключение по отношению к правилу, которое гласит, что при передаче параметров используется вызов по значению. В случае передачи массива функции ее внутренний код работает с реальным содержимым этого массива и вполне может изменить это содержимое. Проанализируйте, например, функцию <kbd>print_upper()</kbd>, которая печатает свой строковый аргумент на верхнем регистре:
<pre>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
void print_upper(char *string);
int main(void)
{
  char s[80];
  printf("Введите строку символов: ");
  gets(s);
  print_upper(s);
  printf("\ns теперь на верхнем регистре: %s", s);
  return 0;
}
/* Печатать строку на верхнем регистре. */
void print_upper(char *string)
{
  register int t;
  for(t=0; string[t]; ++t)  {
    string[t] = toupper(string[t]);
    putchar(string[t]);
  }
}
</pre>
<p class="tj">Вот что будет выведено в случае фразы "This is a test." (это тест):
<pre>
Введите строку символов: This is a test.
THIS IS A TEST.
s теперь в верхнем регистре: THIS IS A TEST.
</pre>
<p class="tj">Правда, эта программа не работает с символами кириллицы.
<p class="tj">После вызова <kbd>print_upper()</kbd> содержимое массива <kbd>s</kbd> в <kbd>main()</kbd> переводится в символы верхнего регистра. Если вам это не нужно, программу можно написать следующим образом:
<pre>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
void print_upper(char *string);
int main(void)
{
  char s[80];
  printf("Введите строку символов: ");
  gets(s);
  print_upper(s);
  printf("\ns не изменялась: %s", s);
  return 0;
}
void print_upper(char *string)
{
  register int t;
  for(t=0; string[t]; ++t)
    putchar(toupper(string[t]));
}
</pre>
<p class="tj">Вот какой на этот раз получится фраза "This is a test.":
<pre>
Введите строку символов: This is a test.
THIS IS A TEST.
s не изменилась: This is a test.
</pre>
<p class="tj">На этот раз содержимое массива не изменилось, потому что внутри <kbd>print_upper()</kbd> не изменялись его значения.
<p class="tj">Классическим примером передачи массивов в функции является стандартная библиотечная функция <kbd>gets()</kbd>. Хотя <kbd>gets()</kbd>, которая находится в вашей стандартной библиотеке, и более сложная, чем предлагаемая вам версия <kbd>xgets()</kbd>, но с помощью функции <kbd>xgets()</kbd> вы сможете получить представление о том, как работает <kbd>gets()</kbd>.
<pre>
/* Упрощенная версия стандартной библиотечной функции gets(). */
char *xgets(char *s)
{
  char ch, *p;
  int t;
  p = s;  /* xgets() возвращает указатель s */
  for(t=0; t&lt;80; ++t){
    ch = getchar();
    switch(ch) {
      case '\n':
        s[t] = '\0'; /* завершает строку */
        return p;
      case '\b':
        if(t&gt;0) t--;
        break;
      default:
        s[t] = ch;
    }
  }
  s[79] = '\0';
  return p;
}
</pre>
<p class="tj">Функцию <kbd>xgets()</kbd> следует вызывать с указателем <kbd>char *</kbd>. Им, конечно же, может быть имя символьного массива, которое по определению является указателем <kbd>char *</kbd>. В самом начале программы <kbd>xgets()</kbd> выполняется цикл <kbd>for</kbd> от 0 до 80. Это не даст вводить с клавиатуры строки, содержащие более 80 символов. При попытке ввода большего количества символов происходит возврат из функции. (В настоящей функции <kbd>gets()</kbd> такого ограничения нет.) Так как в языке С нет встроенной проверки границ, программист должен сам позаботиться, чтобы в любом массиве, используемом при вызове <kbd>xgets()</kbd>, помещалось не менее 80 символов. Когда символы вводятся с клавиатуры, они сразу записываются в строку. Если пользователь нажимает клавишу &lt;Backspase&gt;, то счетчик <kbd>t</kbd> уменьшается на 1, а из массива удаляется последний символ, введенный перед нажатием этой клавиши. Когда пользователь нажмет &lt;ENTER&gt;, в конец строки запишется нуль, т.е. признак конца строки. Так как массив, использованный для вызова <kbd>xgets()</kbd>, модифицируется, то при возврате из функции в нем будут находиться введенные пользователем символы.
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Конечно, при передаче указателя будет применен вызов по значению, и сам указатель внутри функции вы изменить не сможете. Однако для того объекта, на который указывает этот указатель, все произойдет так, будто этот объект был передан по ссылке. В некоторых языках программирования (например, в Алголе-60) имелись специальные средства, позволяющие уточнить, как следует передавать аргументы: по ссылке или по значению. Благодаря наличию указателей в С механизм передачи параметров удалось унифицировать. Параметры, не являющиеся массивами, в С всегда вызываются только по значению, но все, что в других языках вы можете сделать с объектом, получив ссылку на него (т.е. его адрес), вы можете сделать, получив значение указателя на этот объект (т.е. опять же, его адрес). Так что в языке С благодаря свойственной ему унификации передачи параметров никаких проблем не возникает. А вот в других языках трудности, связанные с отсутствием эффективных средств работы с указателями, встречаются довольно часто.
<p class="tj"><sup><a href="#2" id="22">[2]</a></sup>Конечно, задача, решаемая этой программой, кажется тривиальной. Ну разве представляет трудность написать на каком-либо процедурном языке, например, на Алголе-60, процедуру, которая обменивает значения своих параметров. Ведь так просто написать: <strong>procedure</strong> swap(x, y); <strong>integer</strong> х, y; <strong>begin integer</strong> t; t:= x; x:=y; y:=t <strong>end</strong>. Но эта процедура работает неправильно, хотя вызов значений здесь происходит по ссылке! Причем сразу найти тестовый пример, демонстрирующий ошибочность этой процедуры, удается далеко не всем. Ведь в случае вызова swap(i, j) все работает правильно! А что будет в случае вызова swap(i, a[i])? Да и можно ли на Алголе-60 вообще написать требуемую процедуру? Если вы склоняетесь к отрицательному ответу, то это показывает, насколько все-таки необходимы указатели в развитых языках программирования. Если все же вы знаете правильный ответ, то обратите внимание на то, что требуемая процедура, хотя и не длинная, но все же содержит своего рода программистский фокус!
<p class="tj"><sup><a href="#3" id="33">[3]</a></sup>Конечно, это просто программистский жаргон. На самом деле, конечно, аргументами являются именно адреса переменных, а не сами переменные. Просто в этом случае для краткости изложения программисты "делают вид", что вроде бы и в самом деле происходит передача значений по ссылке.
<p class="tj"><sup><a href="#4" id="44">[4]</a></sup>Ведь при вызове по значению пришлось бы копировать весь массив!
</blockquote>
<p>
</p>
<hr><a href="../main.htm#06">Содержание</a> | <a href="0602.htm">&lt;&lt;&lt;</a> | <a href="0604.htm">&gt;&gt;&gt;</a>


</body>
</html>
