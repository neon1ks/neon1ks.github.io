<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Прототип функции - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#06">Содержание</a> | <a href="0607.htm">&lt;&lt;&lt;</a> | <a href="0609.htm">&gt;&gt;&gt;</a><hr>
<h1>Прототип функции</h1>
<p class="tj">В современных, правильно написанных программах на языке С каждую функцию перед использованием необходимо объявлять. Обычно это делается с помощью <em>прототипа функции</em>. В первоначальном варианте языка С прототипов не было; но они были введены уже в Стандарт С89. Хотя прототипы формально не требуются, но их использование очень желательно. (Впрочем, в C++ прототипы <em>обязательны</em>!) Во всех примерах этой книги имеются полные прототипы функций. Прототипы дают компилятору возможность тщательнее выполнять проверку типов, подобно тому, как это делается в таких языках как Pascal. Если используются прототипы, то компилятор может обнаружить любые сомнительные преобразования типов аргументов, необходимые при вызове функции, если тип ее параметров отличается от типов аргументов. При этом будут выданы предупреждения обо всех таких сомнительных преобразованиях. Компилятор также обнаружит различия в количестве аргументов, использованных при вызове функции, и в количестве параметров функции.
<p class="tj">В общем виде прототип функции должен выглядеть таким образом:
<pre><em>тип имя_функции</em>(<em>тип имя_парам1, тип имя_парам2, ..., имя_парамN</em>);</pre>
<p class="tj">Использование имен параметров не обязательно. Однако они дают возможность компилятору при наличии ошибки указать имена, для которых обнаружено несоответствие типов, так что не поленитесь указать этих имен — это позволит сэкономить время впоследствии.
<p class="tj">Следующая программа показывает, насколько ценными являются прототипы функций. В ней выводится сообщение об ошибке, происходящей из-за того, что программа содержит попытку вызова <kbd>sqr_it()</kbd> с целым аргументом, в то время как требуется указатель на целое.
<pre>
/* В этой программе используется прототип функции
   чтобы обеспечить тщательную проверку типов. */
void sqr_it(int *i); /* прототип */
int main(void)
{
  int x;
  x = 10;
  sqr_it(x);  /* несоответствие типов */
  return 0;
}
void sqr_it(int *i)
{
  *i = *i * *i;
}
</pre>
<p class="tj">В качестве прототипа функции может также служить ее определение, если оно находится в программе до первого вызова этой функции. Вот, например, правильная программа:
<pre>
#include &lt;stdio.h&gt;
/* Это определение будет также служить и
   прототипом внутри этой программы. */
void f(int a, int b)
{
  printf("%d ", a % b);
}
int main(void)
{
  f(10,3);
  return 0;
}
</pre>
<p class="tj">В этом примере специальный прототип не требуется; так как функция <kbd>f()</kbd> определена еще до того, как она начинает использоваться в <kbd>main()</kbd>. Хотя определение функции и может служить ее прототипом в малых программах, но в больших такое встречается редко — особенно, когда используется несколько файлов. В программах, приведенных в качестве примеров в этой книге, для каждой функции автор старался приводить отдельный прототип потому, что именно так обычно и пишется код на языке С.
<p class="tj">Единственная функция, для которой не требуется прототип — это <kbd>main()</kbd>, так как это первая функция, вызываемая в начале работы программы.
<p class="tj">Имеется небольшая, но важная разница в том, как именно в С и C++ обрабатывается прототип функции, не имеющей параметров. В C++ пустой список параметров указывается полным отсутствием в прототипе любых параметров. Например,
<pre>int f(); /* Прототип C++ для функции, не имеющей параметров */</pre>
<p class="tj">Однако в С это выражение означает нечто другое. Из-за необходимости придерживаться совместимости с первоначальной версией С пустой список параметров сообщает, что просто о <em>параметрах</em> не предоставлено <em>никакой информации</em>. Что касается компилятора, то для него эта функция может иметь несколько параметров, а может не иметь ни одного. (Такой оператор называется старомодным объявлением функции, он описан в следующем разделе.)
<p class="tj">Если функция в языке С не имеет параметров, то в ее прототипе внутри списка параметров стоит только ключевое слово <kbd>void</kbd>. Вот, например, прототип функции <kbd>f()</kbd> в том виде, в каком он должен быть в программе на языке С:
<pre>float f(void);</pre>
<p class="tj">Таким образом компилятор узнает, что у функции нет параметров, и любое обращение к ней, в котором имеются аргументы, будет считаться ошибкой. В C++ использование ключевого слова <kbd>void</kbd> внутри пустого списка параметров также разрешено, но считается излишним.
<p class="tj">Прототипы функций позволяют "отлавливать" ошибки еще до запуска программы. Кроме того, они запрещают вызов функций при несовпадении типов (т.е. с неподходящими аргументами) и тем самым помогают проверять правильность программы.
<p class="tj">И напоследок хотелось бы сказать следующее: так как в ранних версиях С синтаксис прототипов в полном объеме не поддерживался, то в С прототипы формально не обязательны. Такой подход необходим для совместимости с С-кодом, созданным еще до появления прототипов. Но если старый С-код переносится в C++, то перед компиляцией этого кода в него необходимо добавить полные прототипы функций. Помните, что хотя прототипы в С не обязательны, но они обязательны в C++. Это значит, что каждая функция в программе на языке C++ должна иметь полный прототип. Поэтому при написании программ на С в них указываются полные прототипы функций — именно так поступает большинство программистов, работающих на этом языке.
<h2>Старомодные объявления функций</h2>
<p class="tj">В "ранней молодости" языка С, еще до создания прототипов функций, все-таки была необходимость сообщить компилятору о типе результата функции, чтобы при вызове функции был создан правильный код. (Так как размеры разных типов данных разные, то размер типа результата надо было знать еще до вызова функции.) Это выполнялось с помощью объявления функции, не содержащего никакой информации о параметрах. С точки зрения теперешних стандартов этот старомодный подход является архаичным. Однако его до сих пор можно найти в старых кодах. По этой причине важно понимать, как он работает.
<p class="tj">Согласно старомодному подходу, тип результата и имя функции, как показано ниже, объявляются почти что в начале программы:
<pre>
#include &lt;stdio.h&gt;
double div();  /* старомодное объявление функции */
int main(void)
{
  printf("%f", div(10.2, 20.0));
  return 0;
}
double div(double num, double denom)
{
  return num / denom;
}
</pre>
<p class="tj">Старомодное объявление типа функции сообщает компилятору, что функция <kbd>div()</kbd> возвращает результат типа <kbd>double</kbd>. Это объявление позволяет компилятору правильно генерировать код для вызовов этой функции. Однако оно ничего не говорит о параметрах <kbd>div()</kbd>.
<p class="tj">Общий вид старомодного оператора объявления функции такой:
<pre><em>спецификатор_типа имя_функции</em>();</pre>
<p class="tj">Обратите внимание, что список параметров пустой. Даже если функция принимает аргументы, то ни один из них не перечисляется в объявлении типа.
<p class="tj">Как уже говорилось, старомодное объявление функции устарело и не должно использоваться в новом коде. Кроме того, оно несовместимо с C++.
<h2>Прототипы старомодных библиотечных функций</h2>
<p class="tj">Любая стандартная библиотечная функция в программе должна иметь прототип. Поэтому для каждой такой функции необходимо ввести соответствующий заголовок. Все необходимые заголовки предоставляются компилятором С. В системе программирования на языке С библиотечными заголовками (обычно) являются файлы, в именах которых используется расширение <kbd>.h</kbd>. В заголовке имеется два основных элемента: любые определения, используемые библиотечными функциями, и прототипы библиотечных функций. Например, почти во все программы из этой книги включается файл <kbd>&lt;stdio.h&gt;</kbd>, потому что в этом файле находится прототип для <kbd>printf()</kbd>. Заголовки для стандартных функций описаны в <a href="../II.htm">части II</a>.
<hr><a href="../main.htm#06">Содержание</a> | <a href="0607.htm">&lt;&lt;&lt;</a> | <a href="0609.htm">&gt;&gt;&gt;</a>


</body>
</html>
