<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Указатели, определенные с квалификаторами типа restrict - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#11">Содержание</a> | <a href="1101.htm">&lt;&lt;&lt;</a> | <a href="1103.htm">&gt;&gt;&gt;</a><hr>
<h1>Указатели, определенные с квалификаторами типа restrict</h1>
<p class="tj">Одной из самых важных новинок, введенных Стандартом С99, является квалификатор типа <kbd>restrict</kbd> (ограниченный). Этот квалификатор применяется только к указателям. Указатель, определенный с квалификатором типа <kbd>restrict</kbd><sup><a href="#11" id="1">[1]</a></sup>, изначально является единственным средством, с помощью которого можно получить доступ к указываемому объекту. Доступ к объекту с помощью другого указателя возможен лишь тогда, когда этот второй указатель основан на первом. Таким образом, доступ к объекту возможен только для выражений, составленных на основе указателя с квалификатором типа <kbd>restrict</kbd>. Такие указатели в основном используются как параметры функций или для указания памяти, распределенной с помощью <kbd>malloc()</kbd>. Квалификатор типа <kbd>restrict</kbd> семантики программы не меняет.
<p class="tj">Если указатель квалифицирован с помощью квалификатора типа <kbd>restrict</kbd>, то компилятор может лучше оптимизировать некоторые программы, зная, что указатель с квалификатором типа <kbd>restrict</kbd> является единственным средством доступа к объекту. Например, если функция имеет два параметра в виде указателей с квалификатором типа <kbd>restrict</kbd>, то компилятор может допустить, что указатели указывают на разные (причем неперекрывающиеся!) объекты. Проанализируем, например, то, что стало классическим примером применения <kbd>restrict</kbd> — определение функции <kbd>memcpy()</kbd>. В С89 у нее имеется следующий прототип:
<pre>void *memcpy(void *<em>cmp1</em>, const void *<em>cmp2</em>, size_t <em>размер</em>);</pre>
<p class="tj">В описании <kbd>memcpy()</kbd> сказано, что если объекты, на которые указывают <em>cmp1</em> и <em>cmp2</em>, перекрываются, то поведение этой функции непредсказуемое. Таким образом. <kbd>memcpy()</kbd> гарантированно будет работать только с неперекрывающимися объектами.
<p class="tj">В С99 можно использовать <kbd>restrict</kbd>, чтобы в прототипе <kbd>memcpy()</kbd> явно указать то, что в С89 приходится дополнительно объяснять словами. Вот прототип <kbd>memcpy()</kbd> в С99:
<pre>void *memcpy(void * restrict <em>cmp1</em>, const void * restrict <em>cmp2</em>, size_t <em>размер</em>);</pre>
<p class="tj">Квалифицируя <em>cmp1</em> и <em>cmp2</em> с помощью квалификатора типа <kbd>restrict</kbd>, в прототипе явно утверждается, что они указывают на неперекрывающиеся объекты.
<p class="tj">Из-за преимуществ, которые может принести использование квалификатора типа <kbd>restrict</kbd>, в С99 он был добавлен в прототипы многих библиотечных функций, определенных еще в С89.
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Указатель, определенный с квалификатором типа <kbd>restrict</kbd>, называется также <em>restrict-квалифицированным указателем</em> или <em>указателем, квалифицированным как restrict</em>.
</blockquote>
<p>
</p>
<hr><a href="../main.htm#11">Содержание</a> | <a href="1101.htm">&lt;&lt;&lt;</a> | <a href="1103.htm">&gt;&gt;&gt;</a>


</body>
</html>
