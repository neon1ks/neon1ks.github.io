<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Расширение массивов - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#11">Содержание</a> | <a href="1104.htm">&lt;&lt;&lt;</a> | <a href="1106.htm">&gt;&gt;&gt;</a><hr>
<h1>Расширение массивов</h1>
<p class="tj">В Стандарте С99 появились два новых для С и достаточно важных свойства массивов: переменная длина и возможность включать в объявлениях массивов квалификаторы типа.
<h2>Массивы переменной длины</h2>
<p class="tj">В С89 размерности массивов необходимо объявлять при помощи выражений из целых констант, причем размер массива фиксируется во время компиляции. В силу определенных обстоятельств, в С99 это правило было изменено. В С99 можно объявить массив, размерности которого определяются любыми допустимыми целыми выражениями, в том числе и такими, значения которых становятся известны только во время выполнения. Такой массив называется <em>массивом переменной длины</em> (variable-length array, VLA). Однако такими массивами могут быть только локальные массивы (то есть те, у которых область видимости — прототип или блок). Вот пример массива переменной длины:
<pre>
void f(int diml, int dim2)
{
  int matrix[diml][dim2]; /* двумерный массив переменной длины */
  /* ... */
}
</pre>
<p class="tj">В данном случае размер <kbd>matrix</kbd> определяется значениями, передаваемыми функции <kbd>f()</kbd> через переменные <kbd>dim1</kbd> и <kbd>dim2</kbd>. Таким образом, в результате каждого вызова <kbd>f()</kbd> может получиться массив <kbd>matrix</kbd> с самыми разными измерениями.
<p class="tj">Важно понять, что массивы переменной длины за время "своей жизни" не меняют своих размеров. (Иными словами, они не являются динамическими.) На самом деле массив переменной длины создается с другим размером каждый раз, когда встречается его объявление.
<p class="tj">Можно указать массив переменной длины неуказанного размера, используя в качестве размера звездочку, *.
<p class="tj">Появление массивов переменной длины вызвало небольшое изменение в операторе <kbd>sizeof</kbd>. Вообще говоря, <kbd>sizeof</kbd> — это оператор, который вычисляется во время компиляции. То есть во время компиляции он обычно превращается в целую константу, значение которой равно размеру типа или объекта. Однако если <kbd>sizeof</kbd> применяется к массиву переменной длины, то свое значение он получает только во время выполнения. Это изменение было необходимо потому, что размер массива переменной длины нельзя узнать до времени выполнения.
<p class="tj">Одной из главных причин появления массивов переменной длины является желание упростить программирование численных методов. Конечно, это средство применяется довольно широко. Но помните — массивы переменной длины не поддерживаются Стандартом С89 (и в языке C++).
<h2>Использование квалификаторов типов в объявлении массива</h2>
<p class="tj">В С99 при объявлении массива в качестве параметра функции, внутри квадратных скобок этого объявления можно указать ключевое слово <kbd>static</kbd>. Оно сообщает компилятору, что в массиве, на который указывает этот параметр, всегда будет находиться как минимум названное количество элементов. Например:
<pre>
int f(char str[static 80])
{
  // здесь str всегда является указателем на массив из 80 элементов
  //
}
</pre>
<p class="tj">Здесь дается гарантия, что <kbd>str</kbd> будет указывать на начало массива типа <kbd>char</kbd>, причем в нем будет не менее 80 элементов.
<p class="tj">Внутри квадратных скобок также допускаются ключевые слова <kbd>restrict</kbd>, <kbd>volatile</kbd> и <kbd>const</kbd>, но только для параметров функций. Использование <kbd>restrict</kbd> означает, что указатель изначально является единственным средством доступа к объекту. Применение <kbd>const</kbd> показывает, что указатель указывает на один и тот же массив (то есть указатель всегда указывает на один и тот же объект). Можно использовать и <kbd>volatile</kbd> (означает "асинхронно-изменяемый"), хотя и нет смысла это делать.
<p>
</p>
<hr><a href="../main.htm#11">Содержание</a> | <a href="1104.htm">&lt;&lt;&lt;</a> | <a href="1106.htm">&gt;&gt;&gt;</a>


</body>
</html>
