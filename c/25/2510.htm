<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Поиск и использованием частичного пути минимальной стоимости - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#25">Содержание</a> | <a href="2509.htm">&lt;&lt;&lt;</a> | <a href="2511.htm">&gt;&gt;&gt;</a><hr>
<h1>Поиск и использованием частичного пути минимальной стоимости</h1>
<p class="tj">Противоположностью наискорейшему подъему является <em>поиск с использованием частичного пути минимальной стоимости</em>. Эта стратегия похожа на то, как если бы вы стояли на середине улицы, ведущей на большую гору, а на ногах у вас были бы надеты роликовые коньки. Вы бы тогда явно почувствовали, что двигаться вниз намного легче, чем вверх! Другими словами, поиск с использованием частичного пути минимальной стоимости выбирает путь наименьшего сопротивления.
<p class="tj">Если поиск с использованием частичного пути минимальной стоимости применять к задаче выбора маршрутов полетов, то это означает, что авиарейсы всегда выбираются самые короткие — в надеже, что и найденный маршрут окажется самым коротким. В отличие от наискорейшего подъема, который стремится уменьшить количество авиарейсов, поиск с использованием частичного пути минимальной стоимости сводит к минимуму общую длину маршрута.
<p class="tj">Чтобы использовать поиск с использованием частичного пути минимальной стоимости, сначала, как обычно, нужно переписать функцию <kbd>find()</kbd>. Ниже показан ее новый код.
<pre>
/* Найти самый близкий город и поместить его в "anywhere". */
int find(char *from, char *anywhere)
{
  int pos, dist;
  pos = 0;
  dist = 32000;  /* больше длины самого длинного авиарейса */
  find_pos = 0;
  while(find_pos &lt; f_pos) {
    if(!strcmp(flight[find_pos].from, from) &&
      !flight[find_pos].skip) {
        if(flight[find_pos].distance&lt;dist) {
        pos = find_pos;
        dist = flight[find_pos].distance;
      }
    }
    find_pos++;
  }
  if(pos) {
    strcpy(anywhere, flight[pos].to);
    flight[pos].skip = 1;
    return flight[pos].distance;
  }
  return 0;
}
</pre>
<p class="tj">С помощью этой версии <kbd>find()</kbd> получается такое решение:
<pre>
Нью-Йорк - Торонто - Лос-Анджелес
Расстояние в милях равно 2600.
</pre>
<p class="tj">Как видите, в данном случае этот метод поиска позволяет найти самый короткий маршрут. Цепочка, ведущая к цели (т.е. маршрут, причем самый короткий), показана на рис. 25.8.</p>
<table class="table">
<caption class="bottom"><p class="tj"><em>Рис. 25.8. Эта цепочка, ведущая к решению (т.е. путь, притом наикратчайший), была найдена методом поиска с использованием частичного пути минимальной стоимости</em>
<tr><td align="center"><a href="../work/pic.pdf">Страница №9
</table>
<h2>Анализ поиска с использованием частичного пути минимальной стоимости</h2>
<p class="tj">Поиск с использованием частичного пути минимальной стоимости и наискорейший подъем имеют одни и те же достоинства и недостатки, но только с точностью до наоборот: то, что является достоинством одного метода, является недостатком другого, и наоборот. При поиске с использованием частичного пути минимальной стоимости могут появиться ложные, обманчивые "овраги, долины, низины и пропасти", но в целом этот метод работает достаточно хорошо. Однако не надо думать, что если поиск с использованием частичного пути минимальной стоимости работал в нашей задаче лучше, чем наискорейший подъем, то он вообще работает лучше<sup><a href="#11" id="1">[1]</a></sup>. Т.е. можно сказать, что в среднем он работает лучше, чем поиск вслепую.
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Действительно, зная условие задачи, в которой поиск с использованием частичного пути минимальной стоимости работает лучше, можно сформулировать двойственную задачу, в которой будет лучше работать наискорейший подъем.
</blockquote>
<p>
</p>
<hr><a href="../main.htm#25">Содержание</a> | <a href="2509.htm">&lt;&lt;&lt;</a> | <a href="2511.htm">&gt;&gt;&gt;</a>


</body>
</html>
