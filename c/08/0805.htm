<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>scanf() - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head><body>
<a href="../main.htm#08">Содержание</a> | <a href="0804.htm">&lt;&lt;&lt;</a> | <a href="../09/09.htm">&gt;&gt;&gt;</a><hr>
<h1>scanf()</h1>
<p class="tj">Функция <kbd>scanf()</kbd> — это программа ввода общего назначения, выполняющая ввод с консоли. Она может читать данные всех встроенных типов и автоматически преобразовывать числа в соответствующий внутренний формат, <kbd>scanf()</kbd> во многом выглядит как обратная к <kbd>printf()</kbd>. Вот прототип функции <kbd>scanf()</kbd>:
<pre>int scanf(const char *<em>управляющая_строка</em>, ...);</pre>
<p class="tj">Эта функция возвращает количество тех элементов данных, которым было успешно присвоено значение. В случае ошибки <kbd>scanf()</kbd> возвращает <kbd>EOF</kbd>, <em>управляющая_строка</em> определяет преобразование считываемых значений при записи их переменные, на которые указывают элементы списка аргументов.
<p class="tj">Управляющая строка состоит из символов трех видов:
<ul class="square">
<li>спецификаторов преобразования,
<li>разделителей,
<li>символов, не являющихся разделителями.
</ul>
<p class="tj">Теперь поговорим о каждом из этих видов.
<h2>Спецификаторы преобразования</h2>
<p class="tj">Каждый спецификатор формата ввода начинается со знака <kbd>%</kbd>, причем спецификаторы формата ввода сообщают функции <kbd>scanf()</kbd> тип считываемых данных. Перечень этих кодов (т.е. литер-спецификаторов) приведен в табл. 8.3. Спецификаторам преобразования в порядке слева направо ставятся в соответствие элементы списка аргументов. Рассмотрим некоторые примеры.</p>
<table class="table table-bordered">
<caption><strong>Таблица 8.3. Спецификаторы преобразования для функции <kbd>scanf()</kbd></strong></caption>
<tr><th><em>Код</em><th><em>Значение</em>
<tr><td><kbd>%a</kbd><td class="t">Читает значение с плавающей точкой (только С99)
<tr><td><kbd>%c</kbd><td class="t">Читает одиночный символ
<tr><td><kbd>%d</kbd><td class="t">Читает десятичное целое число
<tr><td><kbd>%i</kbd><td class="t">Читает целое число как в десятичном, так и восьмеричном или шестнадцатеричном формате
<tr><td><kbd>%e</kbd><td class="t">Читает число с плавающей точкой
<tr><td><kbd>%f</kbd><td class="t">Читает число с плавающей точкой
<tr><td><kbd>%g</kbd><td class="t">Читает число с плавающей точкой
<tr><td><kbd>%о</kbd><td class="t">Читает восьмеричное число
<tr><td><kbd>%s</kbd><td class="t">Читает строку
<tr><td><kbd>%x</kbd><td class="t">Читает шестнадцатеричное число
<tr><td><kbd>%p</kbd><td class="t">Читает указатель
<tr><td><kbd>%n</kbd><td class="t">Принимает целое значение, равное количеству уже считанных символов
<tr><td><kbd>%u</kbd><td class="t">Читает десятичное целое число без знака
<tr><td><kbd>%[]</kbd><td class="t">Читает набор сканируемых символов
<tr><td><kbd>%%</kbd><td class="t">Читает знак процента
</table>
<h2>Ввод чисел</h2>
<p class="tj">Для чтения целого числа используйте спецификатор преобразования <kbd>%d</kbd> или <kbd>%i</kbd>. A для чтения числа с плавающей точкой, представленного в стандартном или экспоненциальном виде, используйте спецификатор преобразования <kbd>%e</kbd>, <kbd>%f</kbd> или <kbd>%g</kbd>. (Кроме того, для чтения числа с плавающей точкой стандарт С99 разрешает использовать также спецификатор преобразования <kbd>%a</kbd>.)
<p class="tj">Функцию <kbd>scanf()</kbd> можно использовать для чтения целых значений в восьмеричной или шестнадцатеричной форме, применяя для этого соответственно команды форматирования <kbd>%o</kbd> и <kbd>%x</kbd>, последняя из которых может быть как на верхнем, так и на нижнем регистре. Когда вводятся шестнадцатеричные числа, то буквы от А до F, представляющие шестнадцатеричные цифры, должны быть на том же самом регистре, что и литера-спецификатор. Следующая программа читает восьмеричное и шестнадцатеричное число:
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
  int i, j;
  scanf("%o%x", &i, &j);
  printf("%o %x", i, j);
  return 0;
}
</pre>
<p class="tj">Функция <kbd>scanf()</kbd> прекращает чтение числа тогда, когда встречается первый нечисловой символ.
<h2>Ввод целых значений без знака</h2>
<p class="tj">Для ввода целого значения без знака используйте спецификатор формата <kbd>%u</kbd>. Например, операторы
<pre>
unsigned num;
scanf("%u", &num);
</pre>
<p class="t">выполняют считывание целого числа без знака и присваивают его переменной <kbd>num</kbd>.
<h2>Чтение одиночных символов с помощью scanf()</h2>
<p class="tj">Как уже говорилось в этой главе, одиночные символы можно прочитать с помощью функции <kbd>getchar()</kbd> или какой-либо функции, родственной с ней. Для той же цели можно использовать также вызов функции <kbd>scanf()</kbd> со спецификатором формата <kbd>%c</kbd>. Но, как и большинство реализаций <kbd>getchar()</kbd>, функция <kbd>scanf()</kbd> при использовании спецификатора преобразования <kbd>%c</kbd> обычно будет выполнять построчно буферизованный ввод. В интерактивной среде такая ситуация вызывает определенные трудности.
<p class="tj">При чтении одиночного символа символы разделителей читаются так же, как и любой другой символ, хотя при чтении данных других типов разделители интерпретируются как разделители полей. Например, при вводе с входного потока "x y" фрагмент кода
<pre>scanf("%c%c%c", &a, &b, &c);</pre>
<p class="t">помещает символ <kbd>x</kbd> в <kbd>a</kbd>, пробел — в <kbd>b</kbd>, а символ <kbd>y</kbd> — в <kbd>c</kbd>.
<h2>Чтение строк</h2>
<p class="tj">Для чтения из входного потока строки можно использовать функцию <kbd>scanf()</kbd> со спецификатором преобразования <kbd>%s</kbd>. Использование спецификатора преобразования <kbd>%s</kbd> заставляет <kbd>scanf()</kbd> читать символы до тех пор, пока не встретится какой-либо разделитель. Читаемые символы помещаются в символьный массив, на который указывает соответствующий аргумент, а после введенных символов еще добавляется символ конца строки ('0'). Что касается <kbd>scanf()</kbd>, то таким разделителем может быть пробел, разделитель строк, табуляция, вертикальная табуляция или подача страницы. В отличие от <kbd>gets()</kbd>, которая читает строку, пока не будет нажата клавиша &lt;ENTER&gt;, <kbd>scanf()</kbd> читает строку до тех пор, пока не встретится первый разделитель. Это означает, что <kbd>scanf()</kbd> нельзя использовать для чтения строки "это испытание", потому что после пробела процесс чтения прекратится. Чтобы увидеть, как действует спецификатор <kbd>%s</kbd>, попробуйте при выполнении этой программы ввести строку "привет всем":
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
  char str[80];
  printf("Введите строку: ");
  scanf("%s", str);
  printf("Вот Ваша строка: %s", str);
  return 0;
}
</pre>
<p class="tj">Программа выведет только часть строки, то есть слово <kbd>привет</kbd>.
<h2>Ввод адреса</h2>
<p class="tj">Для ввода какого-либо адреса памяти используйте спецификатор преобразования <kbd>%p</kbd>. Этот спецификатор преобразования заставляет функцию <kbd>scanf()</kbd> читать адрес в том формате, который определен архитектурой центрального процессора. Например, следующая программа вначале вводит адрес, а затем отображает то, что находится в памяти по этому адресу:
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
  char *p;
  printf("Введите адрес: ");
  scanf("%p", &p);
  printf("По адресу %p находится %c\n", p, *p);
  return 0;
}
</pre>
<h2>Спецификатор %n</h2>
<p class="tj">Спецификатор <kbd>%n</kbd> указывает, что <kbd>scanf()</kbd> должна поместить количество символов, считанных (до того момента, когда встретился <kbd>%n</kbd>) из входного потока в целую переменную, указанную соответствующим аргументом.
<h2>Использование набора сканируемых символов</h2>
<p class="tj">Функция <kbd>scanf()</kbd> поддерживает спецификатор формата общего назначения, называемый набором сканируемых символов (scanset). <em>Набор сканируемых символов</em> представляет собой множество символов. Когда <kbd>scanf()</kbd> обрабатывает такое множество, то вводит только те символы, которые входят в набор сканируемых символов. Читаемые символы будут помещаться в массив символов, который указан аргументом, соответствующим набору сканируемых символов. Этот набор определяется следующим образом: все те символы, которые предстоит сканировать, помещают в квадратные скобки. Непосредственно перед открывающей квадратной скобкой должен находиться знак <kbd>%</kbd>. Например, следующий набор сканируемых символов дает указание <kbd>scanf()</kbd> сканировать только символы X, Y и Z:
<pre>%[XYZ]</pre>
<p class="tj">При использовании набора сканируемых символов функция <kbd>scanf()</kbd> продолжает читать символы, помещая их в соответствующий массив символов, пока не встретится символ, не входящий в этот набор. При возвращении из <kbd>scanf()</kbd> в массиве символов будет находиться строка, состоящая из считанных символов, причем эта строка будет заканчиваться символом конца строки. Чтобы увидеть, как это все работает, запустите следующую программу:
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
  int i;
  char str[80], str2[80];
  scanf("%d%[abcdefg]%s", &i, str, str2);
  printf("%d %s %s", i, str, str2);
  return 0;
}
</pre>
<p class="tj">Введите <kbd>123abcdtye</kbd>, а затем нажмите клавишу &lt;ENTER&gt;. После этого программа выведет <kbd>123 abed tye</kbd>. Так как в данном случае 't' не входит в набор сканируемых символов, то <kbd>scanf()</kbd> прекратила чтение символов в переменную <kbd>str</kbd> сразу после того, как встретился символ 't'. Оставшиеся символы были помещены в переменную <kbd>str2</kbd>.
<p class="tj">Кроме того, можно указать набор сканируемых символов, работающий с точностью до наоборот; тогда первым символом в таком наборе должен быть <kbd>^</kbd>. Этот символ дает указание <kbd>scanf()</kbd> принимать любой символ, который не входит в набор сканируемых символов.
<p class="tj">В большинстве реализаций для указания диапазона можно использовать дефис. Например, указанный ниже набор сканируемых символов дает функции <kbd>scanf()</kbd> указание принимать символы от А до Z:
<pre>%[A-Z]</pre>
<p class="tj">Следует обратить внимание на такой важный момент: набор сканируемых символов чувствителен к регистру букв. Если нужно сканировать буквы и на верхнем, и на нижнем регистре, то их надо указывать отдельно для каждого регистра.
<h2>Пропуск лишних разделителей</h2>
<p class="tj">Разделитель в управляющей строке дает <kbd>scanf()</kbd> указание пропустить в потоке ввода один или несколько начальных разделителей. Разделителями являются пробелы, табуляции, вертикальные табуляции, подачи страниц и разделители строк. В сущности, один разделитель в управляющей строке заставляет <kbd>scanf()</kbd> читать, но не сохранять любое количество (в том числе и нулевое) разделителей, которые находятся перед первым символом, не являющимся разделителем.
<h2>Символы в управляющей строке, не являющиеся разделителями</h2>
<p class="tj">Если в управляющей строке находится символ, не являющийся разделителем, то функция <kbd>scanf()</kbd> прочитает символ из входного потока, проверит, совпадает ли прочитанный символ с указанным в управляющей строке, и в случае совпадения пропустит прочитанный символ. Например, "<kbd>%d,%d</kbd>" заставляет <kbd>scanf()</kbd> прочитать целое значение, прочитать запятую и пропустить ее (если это была запятая!), а затем прочитать следующее целое значение. Если же указанный символ во входном потоке не будет найден, то <kbd>scanf()</kbd> завершится. Когда нужно прочитать и отбросить знак процента, то в управляющей строке следует указать <kbd>%%</kbd>.
<h2>Функции scanf() необходимо передавать адреса</h2>
<p class="tj">Для всех переменных, которые должны получить значения с помощью <kbd>scanf()</kbd>, должны быть переданы адреса. Это означает, что все аргументы должны быть указателями. Вспомните, что именно так в С создается вызов по ссылке и именно тогда функция может изменить содержимое аргумента. Например, для считывания целого значения в переменную <kbd>count</kbd> можно использовать такой вызов функции <kbd>scanf()</kbd>:
<pre>scanf("%d", &count);</pre>
<p class="tj">Строки будут читаться в символьные массивы, а имя массива без индекса является адресом первого его элемента. Таким образом, чтобы прочитать строку в символьный массив, можно использовать оператор
<pre>scanf("%s", str);</pre>
<p class="tj">В этом случае <kbd>str</kbd> является указателем, и потому перед ним не нужно ставить оператор <kbd>&</kbd>.
<h2>Модификаторы форматат</h2>
<p class="tj">Как и <kbd>printf()</kbd>, функция <kbd>scanf()</kbd> дает возможность модифицировать некоторое число своих спецификаторов формата. В спецификаторах формата моно указать модификатор максимальной длины поля. Это целое число, расположенное между <kbd>%</kbd> и спецификатором формата; оно ограничивает число символов, считываемых из этого поля. Например, чтобы считывать в переменную <kbd>str</kbd> не более 20 символов, пишите
<pre>scanf("%20s", str);</pre>
<p class="tj">Если поток ввода содержит больше 20 символов, то при следующем вызове функций ввода считывание начнется после того места, где оно закончилось при предыдущем вызове. Например, если вы в ответ на вызов <kbd>scanf()</kbd> из этого примера введете
<pre>ABCDEFGHIJKLMNOPRSTUVWXYZ</pre>
<p class="t">то в <kbd>str</kbd> из-за спецификатора максимальной ширины поля будет помещено только 20 символов, то есть символы вплоть до Т. Это значит, что оставшиеся символы UVWXYZ пока еще не прочитаны. При следующем вызове <kbd>scanf()</kbd>, например при выполнении оператора
<pre>scanf("%s", str);</pre>
<p class="t">в <kbd>str</kbd> будут помешены буквы UVWXYZ. Ввод из поля может завершиться и до того, как будет достигнута максимальная длина поля — если встретится разделитель. В таком случае <kbd>scanf()</kbd> переходит к следующему полю.
<p class="tj">Чтобы прочитать длинное целое, перед спецификатором формата поместите <kbd>l</kbd> (эль). А для чтения короткого целого значения перед спецификатором формата следует поместить <kbd>n</kbd>. Эти модификаторы можно использовать со следующими кодами форматов: <kbd>d</kbd>, <kbd>i</kbd>, <kbd>o</kbd>, <kbd>u</kbd>, <kbd>x</kbd> и <kbd>n</kbd>.
<p class="tj">По умолчанию спецификаторы <kbd>f</kbd>, <kbd>e</kbd> и <kbd>g</kbd> дают <kbd>scanf()</kbd> указание присваивать данные переменной типа <kbd>float</kbd>. Если перед одним из этих спецификаторов будет помещен <kbd>l</kbd> (эль), то <kbd>scanf()</kbd> будет присваивать данные переменной типа <kbd>double</kbd>. Использование <kbd>L</kbd> дает <kbd>scanf()</kbd> указание, чтобы переменная, принимающая данные, имела тип <kbd>long double</kbd>.
<p class="tj">Если в компиляторе предусмотрена обработка <em>двухбайтовых символов</em><sup><a href="#11" id="1">[1]</a></sup>, добавленных в язык С Поправкой 1 от 1995 года, то модификатор <kbd>l</kbd> можно также использовать с такими кодами формата, как <kbd>c</kbd> и <kbd>s</kbd>. <kbd>l</kbd> непосредственно перед <kbd>c</kbd> является признаком указателя на объект типа <kbd>wchar_t</kbd>. А <kbd>l</kbd> непосредственно перед <kbd>s</kbd> — признак указателя на массив элементов типа <kbd>wchar_t</kbd>. Кроме того, <kbd>l</kbd> также применяется для модификации набора сканируемых символов, чтобы этот набор можно было использовать для двухбайтовых символов.
<p class="tj">В Стандарте С99, кроме перечисленных, предусмотрены также модификаторы <kbd>ll</kbd> и <kbd>hh</kbd>, последний из которых можно применять к спецификаторам <kbd>d</kbd>, <kbd>i</kbd>, <kbd>o</kbd>, <kbd>u</kbd>, <kbd>x</kbd> или <kbd>n</kbd>. Он является признаком того, что соответствующий аргумент является указателем на значение, типа <kbd>signed</kbd> или <kbd>unsigned char</kbd>. Кроме того, к спецификаторам <kbd>d</kbd>, <kbd>i</kbd>, <kbd>o</kbd>, <kbd>u</kbd>, <kbd>x</kbd> и <kbd>n</kbd> можно применять и <kbd>ll</kbd>, этот спецификатор является признаком того, что соответствующий аргумент является указателем на значение типа <kbd>signed</kbd> (или <kbd>unsigned</kbd>) <kbd>long long int</kbd>.</p>
<table class="table table-bordered">
<tr><td class="tdnote">На заметку<td class="tj">В С99 для функции <kbd>scanf()</kbd> имеются еще и другие модификаторы типа; о них рассказывается в <a href="../II.htm">части II</a>.
</table>
<h2>Подавление ввода</h2>
<p class="tj"><kbd>scanf()</kbd> может прочитать поле, но не присваивать прочитанное значение никакой переменной; для этого надо перед литерой-спецификатором формата поля поставить звездочку, <kbd>*</kbd>. Например, когда выполняется оператор
<pre>scanf("%d%*c%d", &x, &y);</pre>
<p class="t">можно ввести пару координат <kbd>10,10</kbd>. Запятая будет прочитана правильно, но ничему не будет присвоена. Подавление присвоения особенно полезно тогда, когда нужно обработать только часть того, что вводится.
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Называются также <em>символами в расширенном 16-битном алфавите</em> или <em>символами уникода</em>. (Unicode (уникод) — 16-битовый стандарт кодирования символов, позволяюший представлять алфавиты всех существующих в мире языков.)
</blockquote>
<p>
</p>
<hr><a href="../main.htm#08">Содержание</a> | <a href="0804.htm">&lt;&lt;&lt;</a> | <a href="../09/09.htm">&gt;&gt;&gt;</a>
</body>
</html>
