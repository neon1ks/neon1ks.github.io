<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Чтение и запись строк - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#08">Содержание</a> | <a href="0801.htm">&lt;&lt;&lt;</a> | <a href="0803.htm">&gt;&gt;&gt;</a><hr>
<h1>Чтение и запись строк</h1>
<p class="tj">Среди функций ввода/вывода на консоль есть и более сложные, но и более мощные: это функции <kbd>gets()</kbd> и <kbd>puts()</kbd>, которые позволяют считывать и отображать строки символов.
<p class="tj">Функция <kbd>gets()</kbd> читает строку символов, введенную с клавиатуры, и записывает ее в память по адресу, на который указывает ее аргумент. Символы можно вводить с клавиатуры до тех пор, пока не будет введен символ возврата каретки. Он не станет частью строки, а вместо него в ее конец будет помещен символ конца строки ('0'), после чего произойдет возврат из функции <kbd>gets()</kbd>. На самом деле вернуть символ возврата каретки с помощью этой функции нельзя (а с помощью <kbd>getchar()</kbd> — как раз можно). Перед тем как нажимать &lt;ENTER&gt;, можно исправлять неправильно введенные символы, пользуясь для этого клавишей возврата каретки на одну позицию (клавишей backspace). Вот прототип для <kbd>gets()</kbd>:
<pre>char *gets(char *<em>cmp</em>);</pre>
<p class="tj">Здесь <em>cmp</em> — это указатель на массив символов, в который записываются символы, вводимые пользователем, <kbd>gets()</kbd> также возвращает <em>cmp</em>. Следующая программа читает строку в массив <kbd>str</kbd> и выводит ее длину:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
  char str[80];
  gets(str);
  printf("Длина в символах равна %d", strlen(str));
  return 0;
}
</pre>
<p class="tj">Необходимо очень осторожно использовать <kbd>gets()</kbd>, потому что эта функция не проверяет границы массива, в который записываются введенные символы. Таким образом, может случиться, что пользователь введет больше символов, чем помещается в этом массиве. Хотя функция <kbd>gets()</kbd> прекрасно подходит для программ-примеров и простых утилит, предназначенных только для вас, но в профессиональных программах ею лучше не пользоваться. Ее альтернативой, позволяющей предотвратить переполнение массива, будет функция <kbd>fgets()</kbd>, которая описана в следующей главе.
<p class="tj">Функция <kbd>puts()</kbd> отображает на экране свой строковый аргумент, после чего курсор переходит на новую строку. Вот прототип этой функции:
<pre>int puts(const char *<em>cmp</em>);</pre>
<p class="t"><kbd>puts()</kbd> признает те же самые <em>управляющие последовательности</em><sup><a href="#11" id="1">[1]</a></sup>, что и <kbd>printf()</kbd>, например, \t в качестве символа табуляции. Вызов функции <kbd>puts()</kbd> требует намного меньше ресурсов, чем вызов <kbd>printf()</kbd>. Это объясняется тем, что <kbd>puts()</kbd> может только выводить строку символов, но не может выводить числа или делать преобразования формата. В результате эта функция занимает меньше места и выполняется быстрее, чем <kbd>printf()</kbd>. Поэтому тогда, когда не нужны преобразования формата, часто используется функция <kbd>puts()</kbd>.
<p class="tj">Функция <kbd>puts()</kbd> в случае успешного завершения возвращает неотрицательное значение, а в случае ошибки — <kbd>EOF</kbd>. Однако при записи на консоль обычно предполагают, что ошибки не будет, поэтому значение, возвращаемое <kbd>puts()</kbd>, проверяется редко. Следующий оператор выводит фразу <kbd>Привет</kbd>:
<pre>puts("Привет");</pre>
<p class="tj">В таблице 8.1 перечислены основные функции консольного ввода/вывода.</p>
<table class="table table-bordered">
<caption><strong>Таблица 8.1. Основные функции ввода/вывода</strong></caption>
<tr><th><em>Функция</em><th><em>Ее действия	</em>
<tr><td><kbd>getchar()</kbd><td class="t">Читает символ с клавиатуры; обычно ожидает возврат каретки
<tr><td><kbd>getche()</kbd><td class="t">Читает символ, при этом он отображается на экране; не ожидает возврата каретки; в стандарте С не определена, но распространена достаточно широко
<tr><td><kbd>getch()</kbd><td class="t">Читает символ, но не отображает его на экране; не ожидает возврата каретки; в стандарте С не определена, но распространена достаточно широко
<tr><td><kbd>putchar()</kbd><td class="t">Отображает символ на экране
<tr><td><kbd>gets()</kbd><td class="t">Читает строку с клавиатуры
<tr><td><kbd>puts()</kbd><td class="t">Отображает строку на экране
</table>
<p class="tj">В следующей программе — простом компьютеризованном словаре — показано применение нескольких основных функций консольного ввода/вывода. Эта программа предлагает пользователю ввести слово, а затем проверяет, совпадает ли оно с каким-либо из тех слов, что находятся в ее базе данных. Если оно там есть, то программа выводит значение слова. Обратите особое внимание на использование косвенной адресации в этой программе. Чтобы легче было понять программу, прежде всего вспомните, что массив <kbd>dic</kbd> — это массив указателей на строки. Обратите внимание, что список должен завершаться двумя нулями.
<pre>
/* Простой словарь. */
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
/* список слов и их значений */
char  *dic[][40] = {
  "атлас", "Том географических и/или топографических карт.",
  "автомобиль", "Моторизоравонное средство передвижения.",
  "телефон", "Средство связи.",
  "самолет", "Летающая машина.",
  "", ""  /* нули, завершающие список */
};
int main(void)
{
  char word[80], ch;
  char **p;
  do {
    puts("\nВведите слово: ");
    scanf("%s", word);
    p = (char **)dic;
    /* поиск слова в словаре и вывод его значения */
    do {
      if(!strcmp(*p, word)) {
        puts("Значение:");
        puts(*(p+1));
        break;
      }
      if(!strcmp(*p, word)) break;
      p = p + 2;  /* продвижение по списку */
    } while(*p);
    if(!*p) puts("Слово в словаре отсутствует.");
    printf("Будете еще вводить? (y/n): ");
    scanf(" %c%*c", &ch);
  } while(toupper(ch) != 'N');
  return 0;
}
</pre>
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Называются также <em>ESC-последовательностями</em>; в C/C++ — это комбинация символов, обычно используемая для задания неотображаемых символов и символов, имеющих специальное значение. Представление управляющих последовательностей начинается с обратной косой черты.
</blockquote>
<p>
</p>
<hr><a href="../main.htm#08">Содержание</a> | <a href="0801.htm">&lt;&lt;&lt;</a> | <a href="0803.htm">&gt;&gt;&gt;</a>


</body>
</html>
