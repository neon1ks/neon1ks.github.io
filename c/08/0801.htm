<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Чтение и запись символов - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#08">Содержание</a> | <a href="08.htm">&lt;&lt;&lt;</a> | <a href="0802.htm">&gt;&gt;&gt;</a><hr>
<h1>Чтение и запись символов</h1>
<p class="tj">Самыми простыми из консольных функций ввода/вывода являются <kbd>getchar()</kbd>, которая читает символ с клавиатуры, и <kbd>putchar()</kbd>, которая отображает символ на экране. Первая из этих функций ожидает, пока не будет нажата клавиша, а затем возвращает значение этой клавиши. Кроме того, при нажатии клавиши на клавиатуре на экране дисплея автоматически отображается соответствующий символ. Вторая же функция, <kbd>putchar()</kbd>, отображает символ на экране в текущей позиции курсора. Вот прототипы функций <kbd>getchar()</kbd> и <kbd>putchar()</kbd>:
<pre>
int getchar(void);
int putchar(int <em>c</em>);
</pre>
<p class="tj">Как видно из прототипа, считается, что функция <kbd>getchar()</kbd> возвращает целый результат. Однако возвращаемое значение можно присвоить переменной типа <kbd>char</kbd>, что обычно и делается, так как символ содержится в младшем байте. (Старший байт при этом обычно обнулен.) В случае ошибки <kbd>getchar()</kbd> возвращает <kbd>EOF</kbd>. (Макрос <kbd>EOF</kbd> определяется в <kbd>&lt;stdio.h&gt;</kbd> и часто равен -1.)
<p class="tj">Что же касается <kbd>putchar()</kbd>, то несмотря на то, что эта функция объявлена как принимающая целый параметр, она обычно вызывается с символьным аргументом. На самом деле из ее аргумента на экран выводится только младший байт. Функция <kbd>putchar()</kbd> возвращает записанный символ или, в случае ошибки, <kbd>EOF</kbd>.
<p class="tj">В следующей программе продемонстрировано применение <kbd>getchar()</kbd> и <kbd>putchar()</kbd>. В этой программе с клавиатуры вводятся символы, а затем они отображаются на другом регистре. То есть символы, вводимые на верхнем регистре, выводятся на нижнем, а вводимые на нижнем — выводятся на верхнем. Чтобы остановить программу, введите точку.
<pre>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
int main(void)
{
  char ch;
  printf("Введите какой-нибудь текст
          (для завершения работы введите точку).\n");
  do {
    ch = getchar();
    if(islower(ch)) ch = toupper(ch);
    else ch = tolower(ch);
    putchar(ch);
  } while (ch != '.');
  return 0;
}
</pre>
<p class="tj">(Эта программа не работает, правда, с кириллическими символами.)
<h2>Трудности использования getchar()</h2>
<p class="tj">Использование <kbd>getchar()</kbd> может быть связано с определенными трудностями. Во многих библиотеках компиляторов эта функция реализуется таким образом, что она заполняет буфер ввода до тех пор, пока не будет нажата клавиша &lt;ENTER&gt;. Это называется <em>построчно буферизованным вводом</em>. Чтобы функция <kbd>getchar()</kbd> возвратила какой-либо символ, необходимо нажать клавишу &lt;ENTER&gt;. Кроме того, эта функция при каждом ее вызове вводит только по одному символу. Поэтому сохранение в буфере целой строки может привести к тому, что в очереди на ввод останутся ждать один или несколько символов, а в интерактивной среде это раздражает достаточно сильно. Хотя <kbd>getchar()</kbd> и можно использовать в качестве интерактивной функции, но это делается редко. Так что если предшествующая программа ведет себя не так, как ожидалось, то вы теперь знаете, в чем тут дело.
<h2>Альтернативы getchar()</h2>
<p class="tj">Так как <kbd>getchar()</kbd>, имеющаяся в библиотеке компилятора, может оказаться неподходящей в интерактивной среде, то для чтения символов с клавиатуры может потребоваться другая функция. В стандарте языка С не определяется никаких функций, которые гарантировали бы интерактивный ввод, но их определения имеются буквально в библиотеках всех компиляторов С. И пусть в стандарте С эти функции не определены, но известны они всем! А известны они благодаря функции <kbd>getchar()</kbd>, которая для большинства программистов явно не подходит.
<p class="tj">У двух из самых распространенных альтернативных функций <kbd>getch()</kbd> и <kbd>getche()</kbd> имеются следующие прототипы:
<pre>
int getch(void);
int getche(void);
</pre>
<p class="tj">В библиотеках большинства компиляторов прототипы таких функций находятся в заголовочном файле <kbd>&lt;conio.h&gt;</kbd>. В библиотеках некоторых компиляторов имена этих функций начинаются со знака подчеркивания (_). Например, в Visual C++ компании Microsoft они называются <kbd>_getch()</kbd> и <kbd>_getche()</kbd>.
<p class="tj">Функция <kbd>getch()</kbd> ожидает нажатия клавиши, после которого она немедленно возвращает значение. Причем, символ, введенный с клавиатуры, на экране не отображается. Имеется еще и функция <kbd>getche()</kbd>, которая хоть и такая же, как <kbd>getch()</kbd>, но символ на экране отображает. И если в интерактивной программе необходимо прочитать символ с клавиатуры, то часто вместо <kbd>getchar()</kbd> применяется <kbd>getche()</kbd> или <kbd>getch()</kbd>. Вот, например, предыдущая программа, в которой <kbd>getchar()</kbd> заменена функцией <kbd>getch()</kbd>:
<pre>
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;ctype.h&gt;
int main(void)
{
  char ch;
  printf("Введите какой-нибудь текст
          (для завершения работы введите точку).\n");
  do {
    ch = getch();
    if(islower(ch)) ch = toupper(ch);
    else ch = tolower(ch);
    putchar(ch);
  } while (ch != '.');
  return 0;
}
</pre>
<p class="tj">Когда выполняется эта версия программы, при каждом нажатии клавиши соответствующий символ сразу передается программе и выводится на другом регистре. А ввод в строках не буферизируется. И хотя в кодах в этой книге функции <kbd>getch()</kbd> и <kbd>getche()</kbd> больше не встречаются, но они вполне могут пригодиться в тех программах, которые напишете вы.</p>
<table class="table table-bordered">
<tr><td class="tdnote">На заметку<td class="tj">Тогда: когда писались эти слова, при использовании компилятора Visual C++ компании Microsoft функции <kbd>_getch()</kbd> и <kbd>getch()</kbd> были несовместимы с функциями ввода стандартного С, например, с функциями <kbd>scanf()</kbd> или <kbd>gets()</kbd>. Поэтому вам придется вместо стандартных функций использовать такие их специальные версии, как <kbd>cscanf()</kbd> или <kbd>cgets()</kbd>. Чтобы получить более подробную информацию, следует изучить документацию по Visual C++.
</table>
<p>
</p>
<hr><a href="../main.htm#08">Содержание</a> | <a href="08.htm">&lt;&lt;&lt;</a> | <a href="0802.htm">&gt;&gt;&gt;</a>


</body>
</html>
