<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Структуры - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#07">Содержание</a> | <a href="07.htm">&lt;&lt;&lt;</a> | <a href="0702.htm">&gt;&gt;&gt;</a><hr>
<h1>Структуры</h1>
<p class="tj">Структура — это совокупность переменных, объединенных под одним именем. С помощью структур удобно размещать в смежных полях связанные между собой элементы информации. <em>Объявление структуры</em> создает шаблон, который можно использовать для создания ее объектов (то есть экземпляров этой структуры). Переменные, из которых состоит структура, называются <em>членами</em>. (Члены структуры еще называются <em>элементами</em> или <em>полями</em>.)
<p class="tj">Как правило, члены структуры связаны друг с другом по смыслу. Например, элемент списка рассылки, состоящий из имени и адреса логично представить в виде структуры. В следующем фрагменте кода показано, как объявить структуру, в которой определены поля имени и адреса. Ключевое слово <kbd>struct</kbd> сообщает компилятору, что объявляется (еще говорят, "декларируется") структура.
<pre>
struct addr
{
  char name[30];
  char street[40];
  char city[20];
  char state[3];
  unsigned long int zip;
};
</pre>
<p class="tj">Обратите внимание, что объявление завершается точкой с запятой, потому что объявление структуры является оператором. Кроме того, <em>тег</em> структуры <kbd>addr</kbd> идентифицирует эту конкретную структуру данных и является спецификатором ее типа.
<p class="tj">В данном случае <em>на самом деле никакая переменная не создается</em>. Всего лишь определяется вид данных. Когда вы объявляете структуру, то определяете агрегатный <em>тип</em>, а не переменную. И пока вы не объявите переменную этого типа, то существовать она не будет. Чтобы объявить переменную (то есть физический объект) типа <kbd>addr</kbd>, напишите следующее:
<pre>struct addr addr_info;</pre>
<p class="tj">В этом операторе объявлена переменная типа <kbd>addr</kbd>, которая называется <kbd>addr_info</kbd>. Таким образом, <kbd>addr</kbd> описывает вид структуры (ее тип), a <kbd>addr_info</kbd> является экземпляром (объектом) этой структуры.
<p class="tj">Когда объявляется переменная-структура, компилятор автоматически выделяет количество памяти, достаточное, чтобы разместить все ее члены. На рис. 7.1 показано, как <kbd>addr_info</kbd> размещена в памяти; в данном случае предполагается, что целые переменные типа <kbd>long</kbd> занимают по 4 байта.</p>
<table class="table">
<caption class="bottom"><p class="tj"><em>Рис. 7.1. Расположение в памяти структуры <kbd>addr_info</kbd></em>
<tr><td>
<pre>
+------------------------------------------+
|Name (имя) 30 байт                        |
+------------------------------------------+
+-------------------------------------------------+
|Street (улица) 40 байт                           |
+-------------------------------------------------+
+-----------------------------------+
|City (город) 20 байт               |
+-----------------------------------+
+---------------------+
|State (штат) 3 байта |
+---------------------+
+----------------------------+
|Zip (код) 4 байта           |
+----------------------------+
</pre>
</table>
<p class="tj">Одновременно с объявлением структуры можно объявить одну или несколько переменных. Например,
<pre>
struct addr {
  char name[30];
  char street[40];
  char city[20];
  char state[3];
  unsigned long int zip;
} addr_info, binfo, cinfo;
</pre>
<p class="t">определяет тип структуры, называемый <kbd>addr</kbd>, и объявляет переменные этого типа <kbd>addr_info</kbd>, <kbd>binfo</kbd> и <kbd>cinfo</kbd>. Важно понимать, что каждая переменная-структура содержит собственные копии членов структуры. Например, поле <kbd>zip</kbd> в <kbd>binfo</kbd> отличается от поля <kbd>zip</kbd> в <kbd>cinfo</kbd>. Изменения в <kbd>zip</kbd> из <kbd>binfo</kbd> не повлияют на содержимое поля <kbd>zip</kbd>, находящегося в <kbd>cinfo</kbd>.
<p class="tj">Если нужна только одна переменная-структура, то <em>тег</em> структуры является лишним. В этом случае наш пример объявления можно переписать следующим образом:
<pre>
struct {
  char name[30];
  char street[40];
  char city[20];
  char state[3];
  unsigned long int zip;
} addr_info;
</pre>
<p class="tj">В этом случае объявляется одна переменная с именем <kbd>addr_info</kbd>, причем ее поля указаны в структуре, которая предшествует этому имени.
<p class="tj">Общий вид объявления структуры такой:
<pre>
struct <em>тег</em> {
  <em>тип имя-члена;
  тип имя-члена;
  тип имя-члена;
  .
  .
  .</em>
} <em>переменные-структуры;</em>
</pre>
<p class="t">причем <em>тег</em> или <em>переменные-структуры</em> могут быть пропущены, но только не оба одновременно.
<h2>Доступ к членам структуры</h2>
<p class="tj">Доступ к отдельным членам структуры осуществляется с помощью оператора <kbd>.</kbd> (который обычно называют <em>оператором точка</em> или <em>оператором доступа к члену структуры</em>). Например, в следующем выражении полю <kbd>zip</kbd> в уже объявленной переменной-структуре <kbd>addr_info</kbd> присваивается значение ZIP-кода, равное 12345:
<pre>addr_info.zip = 12345;</pre>
<p class="tj">Этот отдельный член определяется именем объекта (в данном случае <kbd>addr_info</kbd>), за которым следует точка, а затем именем самого этого члена (в данном случае <kbd>zip</kbd>). В общем виде использование оператора точка для доступа к члену структуры выглядит таким образом:
<pre><em>имя-объекта.имя-члена</em></pre>
<p class="tj">Поэтому, чтобы вывести ZIP-код на экран, напишите следующее:
<pre>printf("%d", addr_info.zip);</pre>
<p class="tj">Будет выведен ZIP-код, который находится в члене <kbd>zip</kbd> переменной-структуры <kbd>addr_infо</kbd>.
<p class="tj">Точно так же в вызове <kbd>gets()</kbd> можно использовать массив символов <kbd>addr_infо.name</kbd>:
<pre>gets(addr_info.name);</pre>
<p class="tj">Таким образом, в начало <kbd>name</kbd> передается указатель на символьную строку.
<p class="tj">Так как <kbd>name</kbd> является массивом символов, то чтобы получить доступ к отдельным символам в массиве <kbd>addr_info.name</kbd>, можно использовать индексы вместе с <kbd>name</kbd>. Например, с помощью следующего кода можно посимвольно вывести на экран содержимое <kbd>addr_info.name</kbd>:
<pre>
for(t=0; addr_info.name[t]; ++t)
  putchar(addr_info.name[t]);
</pre>
<p class="tj">Обратите внимание, что индексируется именно name (а не <kbd>addr_info</kbd>). Помните, что <kbd>addr_info</kbd> — это имя всего объекта-структуры, a <kbd>name</kbd> — имя элемента этой структуры. Таким образом, если требуется индексировать элемент структуры, то индекс необходимо указывать после имени этого элемента.
<h2>Присваивание структур</h2>
<p class="tj">Информация, которая находится в одной структуре, может быть присвоена другой структуре того же типа при помощи единственного оператора присваивания. Нет необходимости присваивать значения каждого члена в отдельности. Как выполняется присваивание структур, показывает следующая программа:
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
  struct {
    int a;
    int b;
  } x, y;
  x.a = 10;
  y = x;  /* присваение одной структуры другой */
  printf("%d", y.a);
  return 0;
}
</pre>
<p class="tj">После присвоения в <kbd>y.a</kbd> будет храниться значение 10.
<hr><a href="../main.htm#07">Содержание</a> | <a href="07.htm">&lt;&lt;&lt;</a> | <a href="0702.htm">&gt;&gt;&gt;</a>


</body>
</html>
