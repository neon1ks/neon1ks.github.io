<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Перечисления - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#07">Содержание</a> | <a href="0707.htm">&lt;&lt;&lt;</a> | <a href="0709.htm">&gt;&gt;&gt;</a><hr>
<h1>Перечисления</h1>
<p class="tj"><em>Перечисление</em> — это набор именованных целых констант. Перечисления довольно часто встречаются в повседневной жизни. Вот, например, перечисление, в котором приведены названия монет, используемых в Соединенных Штатах:
<p class="t">penny (пенни, монета в один цент), nickel (никель, монета в пять центов), dime (монета в 10 центов), quarter (25 центов, четверть доллара), half-dollar (полдоллара), dollar (доллар)
<p class="tj">Перечисления определяются во многом так же, как и структуры; началом объявления перечислимого типа<sup><a href="#11" id="1">[1]</a></sup> служит ключевое слово <kbd>enum</kbd>. Перечисление в общем виде выглядит так:
<pre>enum <em>тег</em> {<em>список перечисления</em>} <em>список переменных</em>;</pre>
<p class="tj">Здесь <em>тег</em> и <em>список переменных</em> не являются обязательными. (Но хотя бы что-то одно из них должно присутствовать.) Следующий фрагмент кода определяет перечисление с именем <kbd>coin</kbd> (монета):
<pre>
enum coin { penny, nickel, dime, quarter,
            half_dollar, dollar};
</pre>
<p class="tj">Тег перечисления можно использовать для объявления переменных данного перечислимого типа. Вот код, в котором <kbd>money</kbd> (деньги) объявляется в качестве переменной типа <kbd>coin</kbd>:
<pre>enum coin money;</pre>
<p class="tj">С учетом этих объявлений совершенно верными являются следующие операторы:
<pre>
money = dime;
if(money==quarter) printf("Денег всего четверть доллара.\n");
</pre>
<p class="tj">Главное, что нужно знать для понимания перечислений — каждый их элемент<sup><a href="#22" id="2">[2]</a></sup> представляет целое число. В таком виде элементы перечислений можно применять везде, где используются целые числа. Каждому элементу дается значение, на единицу большее, чем у его предшественника. Первый элемент перечисления имеет значение 0. Поэтому, при выполнении кода
<pre>printf("%d %d", penny, dime);</pre>
<p class="t">на экран будет выведено <kbd>0 2</kbd>.
<p class="tj">Однако для одного или более элементов можно указать значение, используемое как инициализатор. Для этого после перечислителя надо поставить знак равенства, а затем — целое значение. Перечислителям, которые идут после инициализатора, присваиваются значения, большие предшествующего. Например, следующий код присваивает <kbd>quarter</kbd> значение 100:
<pre>
enum coin { penny, nickel, dime, quarter=100,
            half_dollar, dollar};
</pre>
<p class="t">вот какие значения появились у этих элементов:
<pre>
penny           0
nickel          1
dime            2
quarter         100
half_dollar     101
dollar          102
</pre>
<p class="tj">Относительно перечислений есть одно распространенное, но ошибочное мнение. Оно состоит в том, что их элементы можно непосредственно вводить и выводить. Это не так. Например, следующий фрагмент кода не будет выполняться так, как того ожидают многие неопытные программисты:
<pre>
/* этот код работать не будет */
money = dollar;
printf("%s", money);
</pre>
<p class="tj">Здесь <kbd>dollar</kbd> — это имя для значения целого типа; это не строка. Таким образом, попытка вывести <kbd>money</kbd> в виде строки по существу обречена. По той же причине для достижения нужных результатов не годится и такой код:
<pre>
/* этот код не правильный */
strcpy(money, "dime");
</pre>
<p class="tj">То есть строка, содержащая имя элемента, автоматически в этот перечислитель не превратится.
<p class="tj">На самом же деле создавать код для ввода и вывода элементов перечислений — это довольно-таки скучное занятие (но его можно избежать лишь тогда, когда будет достаточно именно целых значений этих перечислителей). Например, чтобы выводить название монеты, вид которой находится в <kbd>money</kbd>, потребуется следующий код:
<pre>
switch(money) {
  case penny: printf("пенни");
    break;
  case nickel: printf("никель");
    break;
  case dime: printf("монета в 10 центов");
    break;
  case quarter: printf("четверть доллара");
    break;
  case half_dollar: printf("полдоллара");
    break;
  case dollar: printf("доллар");
}
</pre>
<p class="tj">Иногда можно объявить строчный массив и использовать значение перечисления как индекс при переводе этого значения в соответствующую строку. Например, следующий код также выводит нужную строку:
<pre>
char name[][12]={
  "пенни",
  "никель",
  "монета в 10 центов",
  "четверть доллара",
  "полдоллара",
  "доллар"
};
printf("%s", name[money]);
</pre>
<p class="tj">Конечно, он будет работать только тогда, когда не инициализирован ни один из элементов перечисления, так как строчный массив должен иметь индекс, который начинается с 0 и возрастает каждый раз на 1.
<p class="tj">Так как при операциях ввода/вывода необходимо специально заботиться о преобразовании перечислений в их строчный эквивалент, который можно легко прочитать, то перечисления полезнее всего именно в тех процедурах, где такие преобразования не нужны. Например, перечисления часто применяются, чтобы определить таблицы соответствия символов в компиляторах.
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>	Иногда используется термин <em>перечисляемый тип</em>.
<p class="tj"><sup><a href="#2" id="22">[2]</a></sup>Элементы списка перечисления называются также <em>перечислителями</em> и <em>идентификаторами</em>.
</blockquote>
<p>
</p>
<hr><a href="../main.htm#07">Содержание</a> | <a href="0707.htm">&lt;&lt;&lt;</a> | <a href="0709.htm">&gt;&gt;&gt;</a>


</body>
</html>
