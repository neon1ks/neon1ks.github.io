<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Передача структур функциям - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#07">Содержание</a> | <a href="0702.htm">&lt;&lt;&lt;</a> | <a href="0704.htm">&gt;&gt;&gt;</a><hr>
<h1>Передача структур функциям</h1>
<p class="tj">В этом разделе рассказывается о передаче структур и их членов функциям.
<h2>Передача членов структур функциям</h2>
<p class="tj">При передаче функции члена структуры передается его значение, притом не играет роли то, что значение берется из члена структуры. Проанализируйте, например, следующую структуру:
<pre>
struct fred
{
  char x;
  int y;
  float z;
  char s[10];
} mike;
</pre>
<p class="tj">Например, обратите внимание, каким образом каждый член этой структуры передается функции:
<pre>
func(mike.x);    /* передается символьное значение x */
func2(mike.y);   /* передается целое значение y */
func3(mike.z);   /* передается значение с плавающей точкой z */
func4(mike.s);   /* передается адрес строки s */
func(mike.s[2]); /* передается символьное значение s[2] */
</pre>
<p class="tj">В каждом из этих случаев функции передается значение определенного элемента, и здесь не имеет значения то, что этот элемент является частью какой-либо большей совокупности.
<p class="tj">Если же нужно передать <em>адрес</em> отдельного члена структуры, то перед именем структуры должен находиться оператор <kbd>&</kbd>. Например, чтобы передать адреса членов структуры <kbd>mike</kbd>, можно написать следующее:
<pre>
func(&mike.x);    /* передается адрес символа x */
func2(&mike.y);   /* передается адрес целого y */
func3(&mike.z);   /* передается адрес члена z с плавающей точкой */
func4(mike.s);    /* передается адрес строки s */
func(&mike.s[2]); /* передается адрес символа в s[2] */
</pre>
<p class="tj">Обратите внимание, что оператор <kbd>&</kbd> стоит непосредственно перед именем структуры, а не перед именем отдельного члена. И еще заметьте, что <kbd>s</kbd> уже обозначает адрес, поэтому <kbd>&</kbd> не требуется.
<h2>Передача целых структур функциям</h2>
<p class="tj">Когда в качестве аргумента функции используется структура, то для передачи целой структуры используется обычный способ вызова по значению. Это, конечно, означает, что любые изменения в содержимом параметра внутри функции не отразятся на той структуре, которая передана в качестве аргумента.
<p class="tj">При использовании структуры в качестве аргумента надо помнить, что тип аргумента должен соответствовать типу параметра. Например, в следующей программе и аргумент <kbd>arg</kbd>, и параметр <kbd>parm</kbd> объявляются с одним и тем же типом структуры.
<pre>
#include &lt;stdio.h&gt;
/* Определение типа структуры. */
struct struct_type {
  int a, b;
  char ch;
} ;
void f1(struct struct_type parm);
int main(void)
{
  struct struct_type arg;
  arg.a = 1000;
  f1(arg);
  return 0;
}
void f1(struct struct_type parm)
{
  printf("%d", parm.a);
}
</pre>
<p class="tj">Как видно из этой программы, при объявлении параметров, являющихся структурами, объявление типа структуры должно быть глобальным, чтобы структурный тип можно было использовать во всей программе. Например, если бы <kbd>struct_type</kbd> был бы объявлен внутри <kbd>main()</kbd>, то этот тип не был бы виден в <kbd>f1()</kbd>.
<p class="tj">Как уже говорилось, при передаче структуры тип аргумента должен совпадать с типом параметра. Для аргумента и параметра недостаточно просто быть физически похожими; должны совпадать даже имена их типов. Например, следующая версия предыдущей программы неправильная и компилироваться не будет. Дело в том, что имя типа для аргумента, используемого при вызове функции <kbd>f1()</kbd>, отличается от имени типа ее параметра.
<pre>
/* Эта программа неправильная и при компиляции будут
   обнаружены ошибки. */
#include &lt;stdio.h&gt;
/* Определение типа структур. */
struct struct_type {
  int a, b;
  char ch;
} ;
/* Определение структуры, похожей на struct_type,
   но сдругими именами. */
struct struct_type2 {
  int a, b;
  char ch;
} ;
void f1(struct struct_type2 parm);
int main(void)
{
  struct struct_type arg;
  arg.a = 1000;
  f1(arg); /* несовпадение типов */
  return 0;
}
void f1(struct struct_type2 parm)
{
  printf("%d", parm.a);
}
</pre>
<p>
</p>
<hr><a href="../main.htm#07">Содержание</a> | <a href="0702.htm">&lt;&lt;&lt;</a> | <a href="0704.htm">&gt;&gt;&gt;</a>


</body>
</html>
