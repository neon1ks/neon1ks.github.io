<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Указатели на структуры - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#07">Содержание</a> | <a href="0703.htm">&lt;&lt;&lt;</a> | <a href="0705.htm">&gt;&gt;&gt;</a><hr>
<h1>Указатели на структуры</h1>
<p class="tj">В языке С указатели на структуры также официально признаны, как и указатели на любой другой вид объектов. Однако указатели на структуры имеют некоторые особенности, о которых и пойдет речь.
<h2>Объявление указателя на структуру</h2>
<p class="tj">Как и другие указатели, указатель на структуру объявляется с помощью звездочки <kbd>*</kbd>, которую помещают перед именем переменной структуры. Например, для ранее определенной структуры <kbd>addr</kbd> следующее выражение объявляет <kbd>addr_pointer</kbd> указателем на данные этого типа (то есть на данные типа <kbd>addr</kbd>):
<pre>struct addr *addr_pointer;</pre>
<h2>Использование указателей на структуры</h2>
<p class="tj">Указатели на структуры используются главным образом в двух случаях: когда структура передается функции с помощью вызова по ссылке, и когда создаются связанные друг с другом списки и другие структуры с динамическими данными, работающие на основе динамического размещения. В этой главе рассматривается первый случай.
<p class="tj">У такого способа, как передача любых (кроме самых простых) структур функциям, имеется один большой недостаток: при выполнении вызова функции, чтобы поместить структуру в стек, необходимы существенные ресурсы. (Вспомните, что аргументы передаются функциям через стек.) Впрочем, для простых структур с несколькими членами эти ресурсы являются не такими уж большими. Но если в структуре имеется большое количество членов или некоторые члены сами являются массивами, то при передаче структур функциям производительность может упасть до недопустимо низкого уровня. Как же решить эту проблему? Надо передавать не саму структуру, а указатель на нее.
<p class="tj">Когда функции передается указатель на структуру, то в стек попадает только адрес структуры. В результате вызовы функции выполняются очень быстро. В некоторых случаях этот способ имеет еще и второе преимущество: передача указателя позволяет функции модифицировать содержимое структуры, используемой в качестве аргумента.
<p class="tj">Чтобы получить адрес переменной-структуры, необходимо перед ее именем поместить оператор <kbd>&</kbd>. Например, в следующем фрагменте кода
<pre>
struct bal {
  float balance;
  char name[80];
} person;
struct bal *p;  /* объявление указателя на структуру */
</pre>
<p class="t">адрес структуры <kbd>person</kbd> можно присвоить указателю <kbd>p</kbd>:
<pre>p = &person;</pre>
<p class="tj">Чтобы с помощью указателя на структуру получить доступ к ее членам, необходимо использовать оператор стрелка <kbd>-&gt;</kbd>.  Вот,  например, как можно сослаться на поле <kbd>balance</kbd>:
<pre>p-&gt;balance</pre>
<p class="tj">Оператор <kbd>-&gt;</kbd>, который обычно называют <em>оператором стрелки</em>, состоит из знака "минус", за которым следует знак "больше". Стрелка применяется вместо оператора точки тогда, когда для доступа к члену структуры используется указатель на структуру.
<p class="tj">Чтобы увидеть, как можно использовать указатель на структуру, проанализируйте следующую простую программу, которая имитирует таймер, выводящий значения часов, минут и секунд:
<pre>
/* Программа-имитатор таймера. */
#include &lt;stdio.h&gt;
#define DELAY 128000
struct my_time {
  int hours;
  int minutes;
  int seconds;
} ;
void display(struct my_time *t);
void update(struct my_time *t);
void delay(void);
int main(void)
{
  struct my_time systime;
  systime.hours = 0;
  systime.minutes = 0;
  systime.seconds = 0;
  for(;;) {
    update(&systime);
    display(&systime);
  }
  return 0;
}
void update(struct my_time *t)
{
  t-&gt;seconds++;
  if(t-&gt;seconds==60) {
    t-&gt;seconds = 0;
    t-&gt;minutes++;
  }
  if(t-&gt;minutes==60) {
    t-&gt;minutes = 0;
    t-&gt;hours++;
  }
  if(t-&gt;hours==24) t-&gt;hours = 0;
  delay();
}
void display(struct my_time *t)
{
  printf("%02d:", t-&gt;hours);
  printf("%02d:", t-&gt;minutes);
  printf("%02d\n", t-&gt;seconds);
}
void delay(void)
{
  long int t;
  /* если надо, можно изменять константу DELAY (задержка) */
  for(t=1; t&lt;DELAY; ++t) ;
}
</pre>
<p class="tj">Эту программу можно настраивать, меняя определение <kbd>DELAY</kbd>.
<p class="tj">В этой программе объявлена глобальная структура <kbd>my_time</kbd>, но при этом не объявлены никакие другие переменные программы. Внутри же <kbd>main()</kbd> объявлена структура <kbd>systime</kbd> и она инициализируется значением 00:00:00. Это значит, что <kbd>systime</kbd> непосредственно видна только в функции <kbd>main()</kbd>.
<p class="tj">Функциям <kbd>update()</kbd> (которая изменяет значения времени) и <kbd>display()</kbd> (которая выводит эти значения) передается адрес структуры <kbd>systime</kbd>. Аргументы в обеих функциях объявляются как указатель на структуру <kbd>my_time</kbd>.
<p class="tj">Внутри <kbd>update()</kbd> и <kbd>display()</kbd> доступ к каждому члену <kbd>systime</kbd> осуществляется с помощью указателя. Так как функция <kbd>update()</kbd> принимает указатель на структуру <kbd>systime</kbd>, то она в состоянии обновлять значение этой структуры. Например, необходимо "в полночь", когда значение переменной, в которой хранится количество часов, станет равным 24, сбросить отсчет и снова сделать значение этой переменной равным 0. Для этого в <kbd>update()</kbd> имеется следующая строка:
<pre>if(t-&gt;hours==24) t-&gt;hours = 0;</pre>
<p class="tj">Таким образом, компилятору дается указание взять адрес <kbd>t</kbd> (этот адрес указывает на переменную <kbd>systime</kbd> из <kbd>main()</kbd>) и сбросить значение <kbd>hours</kbd> в нуль.
<p class="tj">Помните, что оператор точка используется для доступа к элементам структуры при работе с самой структурой. А когда используется указатель на структуру, то надо применять оператор стрелка.
<p>
</p>
<hr><a href="../main.htm#07">Содержание</a> | <a href="0703.htm">&lt;&lt;&lt;</a> | <a href="0705.htm">&gt;&gt;&gt;</a>


</body>
</html>
