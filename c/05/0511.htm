<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Трудности при работе с указателями - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#05">Содержание</a> | <a href="0510.htm">&lt;&lt;&lt;</a> | <a href="../06/06.htm">&gt;&gt;&gt;</a><hr>
<h1>Трудности при работе с указателями</h1>
<p class="tj">Ничто не может доставить больше неприятностей, чем "дикий" указатель! Указатели похожи на обоюдоострое оружие: их возможности огромны, однако обезвредить ошибки в них особенно трудно.
<p class="tj">Ошибочный указатель трудно найти потому, что ошибка в самом указателе никак себя не проявляет. Проблемы возникают при попытке обратиться к объекту с помощью этого указателя. Если значение указателя неправильное, то программа с его помощью обращается к произвольной ячейке памяти. При чтении в программу попадают неправильные данные, а при записи искажаются другие данные, хранящиеся в памяти, или портится участок программы, не имеющий никакого отношения к ошибочному указателю. В обоих случаях ошибка может не проявиться вовсе или проявиться позже в форме, никак не указывающей на ее причину.
<p class="tj">Поскольку ошибки, связанные с указателями, особенно трудно обезвредить, при работе с указателями следует соблюдать особую осторожность. Рассмотрим некоторые ошибки, наиболее часто возникающие при работе с указателями. Классический пример — <em>неинициализированный указатель</em>:
<pre>
/* Это программа содержит ошибку. */
int main(void)
{
  int x, *p;
  x = 10;
  *p = x; /* ошибка, p не инициализирован */
  return 0;
}
</pre>
<p class="tj">Эта программа присваивает значение 10 некоторой неизвестной области памяти. Рассмотрим, почему это происходит. Хотя указателю <kbd>р</kbd> не было присвоено никакого значения, но в момент выполнения операции <kbd>*р = х</kbd> он имел некоторое (совершенно произвольное!) значение. Поэтому здесь имела место попытка выполнить операцию записи в область памяти, на которую указывал данный указатель. В небольших программах такая ошибка часто остается незамеченной, потому что если программа и данные занимают немного места, то "выстрел наугад" скорее всего будет "промахом". С увеличением размера программы вероятность "попасть" в нее возрастает.
<p class="tj">В таком простом случае большинство компиляторов выводят предупреждение о том, что используется неинициализированный указатель. Однако подобная ошибка может произойти и в более завуалированном виде, тогда компилятор не сможет распознать ее.
<p class="tj">Вторая распространенная ошибка заключается в простом недоразумении при использовании указателя:
<pre>
/* Это программа содержит ошибку. */
#include &lt;stdio.h&gt;
int main(void)
{
  int x, *p;
  x = 10;
  p = x;
  printf("%d", *p);
  return 0;
}
</pre>
<p class="tj">Вызов <kbd>printf()</kbd> не выводит на экран значение <kbd>х</kbd>, равное 10. Выводится произвольная величина, потому что оператор
<pre>p = x;</pre>
<p class="t">записан неправильно. Он присваивает значение 10 указателю, однако указатель должен содержать адрес, а не значение. Правильный оператор выглядит так:
<pre>p = &x;</pre>
<p class="tj">Большинство компиляторов при попытке присвоить указателю <kbd>р</kbd> значение <kbd>х</kbd> выведут предупреждающее сообщение, но, как и в предыдущем примере, компилятор не сможет распознать эту ошибку в более завуалированном виде.
<p class="tj">Еще одна типичная ошибка происходит иногда при неправильном понимании принципов расположения переменных в памяти. Программисту ничего не известно о том, как используемые им данные располагаются в памяти, будут ли они расположены так же при следующем выполнении программы или как их расположат другие компиляторы. Поэтому сравнивать одни указатели с другими недопустимо. Например, программа
<pre>
char s[80], y[80];
char *p1, *p2;
p1 = s;
p2 = y;
if(p1 &lt; p2) . . .
</pre>
<p class="t">в общем случае неправильна. (В некоторых необычных ситуациях иногда определяют относительное положение переменных, но это делают очень редко.)
<p class="tj">Похожая ошибка возникает, когда делается необоснованное предположение о расположении массивов. Иногда, предполагая, что массивы расположены рядом, пытаются обращаться к ним с помощью одного и того же указателя, например:
<pre>
int first[10], second[10];
int *p, t;
p = first;
for(t=0; t&lt;20; ++t)  *p++ = t;
</pre>
<p class="tj">Так присваивать значения массивам <kbd>first</kbd> и <kbd>second</kbd> нельзя. Если компилятор разместит массивы рядом, это может и не привести к неправильному результату. Однако подобная ошибка особенно неприятна тем, что при проверке она может остаться незамеченной, а потом компилятор будет размещать массивы по-другому и программа выполнится неправильно.
<p class="tj">В следующей программе приведен пример очень опасной ошибки. Постарайтесь сами найти ее, не подсматривая в последующее объяснение.
<pre>
/* Это программа с ошибкой. */
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
int main(void)
{
  char *p1;
  char s[80];
  p1 = s;
  do {
    gets(s);  /* чтение строки */
    /* печать десятичного эквивалента
       каждого символа */
    while(*p1) printf(" %d", *p1++);
  } while(strcmp(s, "выполнено"));
  return 0;
}
</pre>
<p class="tj">Программа печатает значения символов ASCII, находящихся в строке <kbd>s</kbd>. Печать осуществляется с помощью <kbd>p1</kbd>, указывающего на <kbd>s</kbd>. Ошибка состоит в том, что указателю <kbd>p1</kbd> присвоено значение <kbd>s</kbd> только один раз, перед циклом. В первой итерации <kbd>p1</kbd> правильно проходит по символам строки <kbd>s</kbd>, однако в следующей итерации он начинает не с первого символа, а с того, которым закончил в предыдущей итерации. Так что во второй итерации <kbd>p1</kbd> может указывать на середину второй строки, если она длиннее первой, или же вообще на конец остатка первой строки. Исправленная версия программы записывается так:
<pre>
/* Это правильная программа. */
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
int main(void)
{
  char *p1;
  char s[80];
  do {
    p1 = s; /* установка p1 в начало строки s */
    gets(s);  /* чтение строки */
    /* печать десятичного эквивалента
       каждого символа */
    while(*p1) printf(" %d", *p1++);
  } while(strcmp(s, "выполнено"));
  return 0;
}
</pre>
<p class="tj">При такой записи указатель <kbd>p1</kbd> в начале каждой итерации устанавливается на первый символ строки <kbd>s</kbd>. Об этом необходимо всегда помнить при повторном использовании указателей.
<p class="tj">То, что неправильные указатели могут быть очень "коварными", не может служить причиной отказа от их использования. Следует лишь быть осторожным и внимательно проанализировать каждое применение указателя в программе.
<p>
</p>
<hr><a href="../main.htm#05">Содержание</a> | <a href="0510.htm">&lt;&lt;&lt;</a> | <a href="../06/06.htm">&gt;&gt;&gt;</a>


</body>
</html>
