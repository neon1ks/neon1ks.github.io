<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Разбиение выражения на лексемы - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#24">Содержание</a> | <a href="2401.htm">&lt;&lt;&lt;</a> | <a href="2403.htm">&gt;&gt;&gt;</a><hr>
<h1>Разбиение выражения на лексемы</h1>
<p class="tj">Для того чтобы вычислять выражения, необходимо уметь разбивать их на отдельные составляющие. Например, выражение А * В - (W + 10) состоит из таких элементов: А, *, В, -, (, W, +, 10 и ). Каждый из них представляет единую неделимую часть выражения. В общем случае необходима функция, которая возвращает один за другим все элементы выражения. Эта функция также должна уметь пропускать пробелы и символы табуляции и определять конец выражения.
<p class="tj">Каждый элемент выражения называется <em>лексемой</em> (token). Поэтому функция, возвращающая очередную лексему, часто называется <kbd>get_token()</kbd>. В этой функции используется глобальный указатель на строку с разбираемым выражением. В показанной здесь версии функции <kbd>get_token()</kbd> этот глобальный указатель называется <kbd>prog</kbd>. Переменная <kbd>prog</kbd> описана глобально, поскольку она должна сохранять свое значение между вызовами функции <kbd>get_token()</kbd> и быть доступной другим функциям. Помимо значения возвращаемой лексемы, необходимо знать ее тип. Для анализатора, разрабатываемого в данной главе, понадобятся только три типа: переменная, число и разделитель. Им соответствуют константы <kbd>VARIABLE</kbd>, <kbd>NUMBER</kbd> и <kbd>DELIMITER</kbd>, (<kbd>DELIMITER</kbd> используется как для операторов, так и для скобок.) Ниже приведен текст функции <kbd>get_token()</kbd> вместе с необходимыми глобальными описаниями, константами и вспомогательной функцией:
<pre>
#define DELIMITER 1
#define VARIABLE  2
#define NUMBER    3
extern char *prog;  /* указатель на анализируемое выражение */
char token[80];
char tok_type;
/* Данная функция возвращает очередную лексему. */
void get_token(void)
{
  register char *temp;
  tok_type = 0;
  temp = token;
  *temp = '\0';
  if(!*prog) return; /* конец выражения */
  while(isspace(*prog)) ++prog;  /* пропустить пробелы, символы
                                    табуляции и пустой строки */
  if(strchr("+-*/%^=()", *prog)){
    tok_type = DELIMITER;
    /* продвинуться к следующему символу */
    *temp++ = *prog++;
  }
  else if(isalpha(*prog)) {
    while(!isdelim(*prog)) *temp++ = *prog++;
    tok_type = VARIABLE;
  }
  else if(isdigit(*prog)) {
    while(!isdelim(*prog)) *temp++ = *prog++;
    tok_type = NUMBER;
  }
  *temp = '\0';
}
/* Возвращает значение ИСТИНА, если с является раздилителем. */
int isdelim(char c)
{
  if(strchr(" +-/*%^=()", c) || c==9 || c=='\r' || c==0)
    return 1;
  return 0;
}
</pre>
<p class="tj">Давайте рассмотрим приведенные выше функции более подробно. После нескольких инициализаций функция <kbd>get_token()</kbd> проверяет, не достигнут ли символ конца строки ( '0' ), завершающий выражение. Если в выражении еще есть неразобранная часть, функция <kbd>get_token()</kbd> сначала пропускает ведущие пробелы, если они имеются. После этого переменная <kbd>prog</kbd> указывает на число, переменную, оператор или — если выражение завершалось пробелами — на символ конца строки ( '0' ). Если очередной символ является оператором, он возвращается в виде строки, хранимой в глобальной переменной <kbd>token</kbd>, а переменной <kbd>tok_type</kbd>, содержащей тип полученной лексемы, присваивается значение <kbd>DELIMITER</kbd>. Если же следующий символ является буквой, он считается именем переменной и возвращается в строковой переменной <kbd>token</kbd>. При этом <kbd>tok_type</kbd> получает значение <kbd>VARIABLE</kbd>. В случае, когда очередной символ является цифрой, считывается все число, причем оно помещается в переменную <kbd>token</kbd>, а его типом будет <kbd>NUMBER</kbd>. Наконец, если следующий символ не является ни одним из перечисленных выше, считается, что достигнут конец выражения. В этом случае <kbd>token</kbd> содержит пустую строку, возврат которой означает конец выражения.
<p class="tj">Как уже было сказано ранее, чтобы не усложнять код этой функции, были опущены некоторые средства контроля за ошибками и сделаны некоторые допущения. Например, любой нераспознанный символ завершает выражение. Кроме того, в данной версии программы имена переменных могут иметь любую длину, но значащей является только первая буква. В соответствии с требованиями конкретной задачи вы можете усложнить средства контроля за ошибками и добавить другие подробности. Функцию <kbd>get_token()</kbd> можно доработать или модифицировать, чтобы она выбирала из входного выражения строки символов, числа других типов или лексемы другого типа.
<p class="tj">Чтобы лучше понять принцип действия функции <kbd>get_token()</kbd>, ниже приведены возвращаемые ей лексемы и типы лексем для следующего входного выражения:
<pre>A + 100 - (B * C) /2</pre>
<table class="table table-bordered">
<tr><th><em>Лексема</em><th><em>Тип лексемы</em>
<tr><td>А<td>VARIABLE
<tr><td>+<td>DELIMITER
<tr><td>100<td>NUMBER
<tr><td>-<td>DELIMITER
<tr><td>(<td>DELIMITER
<tr><td>В<td>VARIABLE
<tr><td>*<td>DELIMITER
<tr><td>С<td>VARIABLE
<tr><td>)<td>DELIMITER
<tr><td>/<td>DELIMITER
<tr><td>2<td>NUMBER
<tr><td>нуль (конец строки)<td>0(нуль)
</table>
<p class="tj">Следует помнить, что переменная <kbd>token</kbd> всегда содержит строку, завершающуюся символом конца строки ('0'), даже если эта строка состоит только из одного символа.
<hr><a href="../main.htm#24">Содержание</a> | <a href="2401.htm">&lt;&lt;&lt;</a> | <a href="2403.htm">&gt;&gt;&gt;</a>


</body>
</html>
