<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Модификация базовых типов - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#02">Содержание</a> | <a href="0201.htm">&lt;&lt;&lt;</a> | <a href="0203.htm">&gt;&gt;&gt;</a><hr>
<h1>Модификация базовых типов</h1>
<p class="tj">Базовые типы данных (кроме <kbd>void</kbd>) могут иметь различные <em>спецификаторы</em><sup><a href="#11" id="1">[1]</a></sup>, предшествующие им в тексте программы. Спецификатор типа так изменяет значение базового типа, чтобы он более точно соответствовал своему назначению в программе. Полный список спецификаторов типов:
<pre>
signed
unsigned
long
short
</pre>
<p class="tj">Базовый тип <kbd>int</kbd> может быть модифицирован каждым из этих спецификаторов. Тип <kbd>char</kbd> модифицируется с помощью <kbd>unsigned</kbd> и <kbd>signed</kbd>, <kbd>double</kbd> — с помощью <kbd>long</kbd>. (Стандарт С99 также позволяет модифицировать <kbd>long</kbd> с помощью <kbd>long</kbd>, создавая таким образом <kbd>long long</kbd>, см. <a href="../II.htm">часть II</a>). В табл. 2.1 приведены все допустимые комбинации типов данных с их минимальным диапазоном значений и типичным размером. Обратите внимание, в таблице приведены <em>минимально возможные</em>, а не типичные диапазоны значений. Например, если в компьютере арифметические операции выполняются над числами в дополнительных кодах (а именно так спроектированы почти все компьютеры!), то в диапазон значений целых попадут все целые числа от -32767 до 32768.</p>
<table class="table table-bordered">
<caption><strong>Таблица 2.1. Все типы данных, определенные Стандартом C</strong><caption>
<tr><th><em>Тип</em><th><em>Типичный размер в битах</em><th><em>Минимально допустимый диапозон значений</em>
<tr><td>char<td>8<td>от -127 до 127
<tr><td>unsigned char<td>8<td>от 0 до 255
<tr><td>signed char<td>8<td>от -127 до 127
<tr><td>int<td>16 или 32<td>от -32767 до 32767
<tr><td>unsigned int<td>16 или 32<td>от 0 до 65535
<tr><td>signed int<td>16 или 32<td>то же, что int
<tr><td>short int<td>16<td>от -32767 до 32767
<tr><td>unsigned short int<td>16<td>от 0 до 65535
<tr><td>signed short int<td>16<td>то же, что short int
<tr><td>long int<td>32<td>от -2 147 483 647 до 2 147 483 647
<tr><td>long long int<td>64<td>от -(2<sup>63</sup>-1) до (2<sup>63</sup>-1), добавлен стандартом C99
<tr><td>signed long int<td>32<td>то же, что long int
<tr><td>unsigned long int<td>32<td>от 0 до 4 294 967 295
<tr><td>unsigned long long int<td>64<td>от 0 до (2<sup>64</sup>-1), добавлен в C99
<tr><td>float<td>32<td>от 1E-37 до 1E+37, с точностью не менее 6 значащих десятичных цифр
<tr><td>double<td>64<td>от 1E-37 до 1E+37, с точностью не менее 10 значащих десятичных цифр
<tr><td>long double<td>80<td>от 1E-37 до 1E+37, с точностью не менее 10 значащих десятичных цифр
</table>
<p class="tj">Для целых можно использовать спецификатор <kbd>signed</kbd>, но в этом нет необходимости, потому что при объявлении целого он предполагается по умолчанию. Спецификатор <kbd>signed</kbd> чаще всего используется для типа <kbd>char</kbd>, который в некоторых реализациях по умолчанию может быть беззнаковым.
<p class="tj">Целые числа со знаком и без знака отличаются интерпретацией нулевого бита числа. Если целое объявлено со знаком, компилятор считает, что нулевой бит содержит знак числа. Если в нулевом бите записан 0, число считается положительным, а если 1 — отрицательным.
<p class="tj">В большинстве реализаций отрицательные числа представлены в <em>двоичном дополнительном коде</em>. Это значит, что для отрицательного числа все биты, кроме нулевого, инвертируются, к полученному числу добавляется 1, а нулевой бит устанавливается в 1.
<p class="tj">Целые числа со знаком используются почти во всех алгоритмах, но абсолютная величина наибольшего из них составляет примерно только половину максимального целого без знака. Например, знаковое целое число 32767 в двоичном коде имеет вид
<pre>01111111 11111111</pre>
<p class="tj">Если в нулевой бит записать 1, то оно будет интерпретироваться как —1. Однако если полученную запись рассматривать как представление числа, объявленного как <kbd>unsigned int</kbd>, то оно будет интерпретироваться как 65535.
<p class="tj">Если спецификатор типа записать сам по себе (без следующего за ним базового типа), то предполагается, что он модифицирует тип <kbd>int</kbd>. Таким образом, следующие спецификаторы типов эквивалентны:</p>
<table class="table table-bordered">
<tr><th><em>Спецификатор</em><th><em>То же самое</em>
<tr><td>signed<td>signed int
<tr><td>unsigned<td>unsigned int
<tr><td>long<td>long int
<tr><td>short<td>short int
</table>
<p class="tj">Хотя базовый тип <kbd>int</kbd> и предполагается по умолчанию, его, тем не менее, обычно указывают явно.
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Называются также <em>описателями</em>, <em>модификаторами</em> и <em>квалификаторами</em>.
</blockquote>
<hr><a href="../main.htm#02">Содержание</a> | <a href="0201.htm">&lt;&lt;&lt;</a> | <a href="0203.htm">&gt;&gt;&gt;</a>


</body>
</html>
