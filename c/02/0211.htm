<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Выражения - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#02">Содержание</a> | <a href="0210.htm">&lt;&lt;&lt;</a> | <a href="../03/03.htm">&gt;&gt;&gt;</a><hr>
<h1>Выражения</h1>
<p class="tj">Выражения состоят из операторов, констант, функций и переменных. В языке С выражением является любая правильная последовательность этих элементов. Большинство выражений в языке С по форме очень похожи на алгебраические, часто их и пишут, руководствуясь правилами алгебры. Однако здесь необходимо быть внимательным и учитывать специфику выражений в языке С.
<h2>Порядок вычислений</h2>
<p class="tj">Порядок вычисления подвыражений в выражениях языка С не определен. Компилятор может самостоятельно перестроить выражение с целью создания оптимального объектного кода. Это значит, что программист не может полагаться на определенную последовательность вычисления подвыражений. Например, при вычислении выражения
<pre>х = f1() + f2();</pre>
<p class="t">нет никаких гарантий того, что функция <kbd>f1()</kbd> будет вызвана перед вызовом <kbd>f2()</kbd>.
<h2>Преобразования типов в выражениях</h2>
<p class="tj">Если в выражении встречаются переменные и константы разных типов, они преобразуются к одному типу. Компилятор преобразует "меньший" тип в "больший". Этот процесс называется <em>продвижением типов</em> (<em>type promotion</em>). Сначала все переменные типов <kbd>char</kbd> и <kbd>short int</kbd> автоматически продвигаются в <kbd>int</kbd>. Это называется целочисленным расширением. (В С99 целочисленное расширение может также завершиться преобразованием в <kbd>unsigned int</kbd>.) После этого все остальные операции выполняются одна за другой, как описано в приведенном ниже алгоритме преобразования типов:
<pre>
IF операнд имеет тип <strong>long double</strong>
THEN второй операнд преобразуется в <strong>long double</strong>
ELSE IF операнд имеет тип <strong>double</strong>
THEN второй операнд преобразуется в <strong>double</strong>
ELSE IF операнд имеет тип <strong>float</strong>
THEN второй операнд преобразуется в <strong>float</strong>
ELSE IF операнд имеет тип <strong>unsigned long</strong>
THEN второй операнд преобразуется в <strong>unsigned long</strong>
ELSE IF операнд имеет тип <strong>long</strong>
THEN второй операнд преобразуется в <strong>long</strong>
ELSE IF операнд имеет тип <strong>unsigned int</strong>
THEN второй операнд преобразуется в <strong>unsigned int</strong>
</pre>
<p class="tj">Для тех, кто еще не знаком с общей формой оператора IF, приводим более русифицированную запись алгоритма:
<pre>
ЕСЛИ операнд имеет тип <strong>long double</strong>
ТО второй операнд преобразуется в <strong>long double</strong>
ИНАЧЕ ЕСЛИ операнд имеет тип <strong>double</strong>
ТО второй операнд преобразуется в <strong>double</strong>
ИНАЧЕ ЕСЛИ операнд имеет тип <strong>float</strong>
ТО второй операнд преобразуется в <strong>float</strong>
ИНАЧЕ ЕСЛИ операнд имеет тип <strong>unsigned long</strong>
ТО второй операнд преобразуется в <strong>unsigned long</strong>
ИНАЧЕ ЕСЛИ операнд имеет тип <strong>long</strong>
ТО второй операнд преобразуется в <strong>long</strong>
ИНАЧЕ ЕСЛИ операнд имеет тип <strong>unsigned int</strong>
ТО второй операнд преобразуется в <strong>unsigned int</strong>
</pre>
<p class="tj">Кроме того, действует следующее правило: если один из операндов имеет тип <kbd>long</kbd>, а второй — <kbd>unsigned int</kbd>, притом значение <kbd>unsigned int</kbd> не может быть представлено типом <kbd>long</kbd>, то оба операнда преобразуются в <kbd>unsigned long</kbd>.</p>
<table class="table table-bordered">
<tr><td class="tdnote">На заметку<td class="tj">Описание правил целочисленного расширения в С99 см. в <a href="../II.htm">части II</a>.
</table>
<p class="tj">После выполнения приведенных выше преобразований оба операнда относятся к одному и тому же типу, к этому типу относится и результат операции.
<p class="tj">Рассмотрим пример преобразования типов, приведенный на рис. 2.2. Сначала символ <kbd>ch</kbd> преобразуется в целое число. Результат операции <kbd>ch/i</kbd> преобразуется в <kbd>double</kbd>, потому что результат <kbd>f*d</kbd> имеет тип <kbd>double</kbd>. Результат операции <kbd>f+i</kbd> имеет тип <kbd>float</kbd>, потому что <kbd>f</kbd> имеет тип <kbd>float</kbd>. Окончательный результат имеет тип <kbd>double</kbd>.
<table class="table">
<caption class="bottom"><p class="tj"><em>Рис. 2.2. Пример преобразования типов</em>
<tr><td>
<pre>
  char    ch;
  int     i;
  float   f;
  double  d;
  r  e  s  u  l  t  =  (  ch  /  i  )  +  (  f  *  d  )  -  (  f  +  i  )  ;
                           |     |           |     |           |     |
                          int    |         double  |           |    float
                           |_____|           |_____|           |_____|
                              |                 |                 |
                             int              double             float
                              |_________________|                 |
                                       |__________________________|
                                                    |
                                                  double
</pre>
</table>
<h2>Явное преоразование типов: операция приведения типов</h2>
<p class="tj">Программист может "принудительно" преобразовать значение выражения к нужному ему типу, используя операцию приведения типов. Общая форма оператора явного приведения типа:
<pre><em>(тип) выражение</em></pre>
<p class="tj">Здесь <em>тип</em> — это любой поддерживаемый тип данных. Например, следующая запись преобразует значение выражения <kbd>х/2</kbd> к типу <kbd>float</kbd>:
<pre>(float) х/2</pre>
<p class="tj">Явное преобразование типа — это операция. Оператор приведения типа является унарным и имеет тот же приоритет, что и остальные унарные операторы.
<p class="tj">Иногда приведение типов может быть весьма полезным. Допустим, целую переменную нужно использовать как параметр цикла, притом в вычислении участвует и дробная часть числа. В следующем примере показано, как с помощью приведения можно сохранить точность:
<pre>
#include &lt;stdio.h&gt;
int main(void) /* печать i и i/2 с дробной частью */
{
  int i;
  for(i=1; i&lt;=100; ++i)
    printf("%d / 2 is: %f\n", i, (float) i /2);
  return 0;
}
</pre>
<p class="tj">Без операции приведения <kbd>(float)</kbd> выполнялось бы целочисленное деление. Дробная часть результата выводится благодаря приведению типа переменной <kbd>i</kbd>.
<h2>Пробелы и круглые скобки</h2>
<p class="tj">Для повышения удобочитаемости программы при записи выражений можно использовать пробелы и символы табуляции. Например, следующие два оператора эквивалентны:
<pre>
x=10/y~(127/x);
x = 10 / y ~(127/x);
</pre>
<p class="tj">Лишние скобки, если они не изменяют приоритет операций, не приводят к ошибке и не замедляют вычисление выражения. Дополнительные скобки часто используют для прояснения порядка вычислений. В следующем примере 2-я строка читается значительно легче:
<pre>
x = y/3-34*temp+127;
x = (y/3) - (34*temp) + 127;
</pre>
<p>
</p>
<hr><a href="../main.htm#02">Содержание</a> | <a href="0210.htm">&lt;&lt;&lt;</a> | <a href="../03/03.htm">&gt;&gt;&gt;</a>


</body>
</html>
