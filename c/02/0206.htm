<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Квалификатор типа - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head><body>
<a href="../main.htm#02">Содержание</a> | <a href="0205.htm">&lt;&lt;&lt;</a> | <a href="0207.htm">&gt;&gt;&gt;</a><hr>
<h1>Квалификатор типа</h1>
<p class="tj">В языке С определяются <em>квалификаторы типа</em><sup><a href="#11" id="1">[1]</a></sup>, указывающие на доступность и модифицируемость переменной. Стандарт С89 определяет два квалификатора: <kbd>const</kbd> и <kbd>volatile</kbd>. (C99 добавляет третий, <kbd>restrict</kbd>, описанный в <a href="../II.htm">части II</a>.) Квалификатор типа должен предшествовать имени типа, который он квалифицирует (уточняет).
<h2>Квалификатор const</h2>
<p class="tj">Переменная, к которой в объявлении (декларации) применен квалификатор <kbd>const</kbd>, не может изменять свое значение<sup><a href="#22" id="2">[2]</a></sup>. Ее можно только инициализировать, то есть присвоить ей значение в начале выполнения программы. Компилятор может поместить переменную этого типа в постоянное запоминающее устройство, так называемое ПЗУ (ROM, read-only memory). Например, в объявлении
<pre>const int a=10;</pre>
<p class="t">создается переменная с именем <kbd>а</kbd>, причем ей присваивается начальное значение 10, которое в дальнейшем в программе изменить никак нельзя. Переменную, к которой в объявлении применен квалификатор <kbd>const</kbd>, можно использовать в различных выражениях. Однако свое значение она может получить только в результате инициализации или с помощью аппаратно-зависимых средств.
<p class="tj">Квалификатор <kbd>const</kbd> часто используется для того, чтобы предотвратить изменение функцией объекта, на который указывает аргумент функции. Без него при передаче в функцию указателя эта функция может изменить объект, на который он указывает. Однако если в объявлении параметра-указателя применен квалификатор <kbd>const</kbd>, функция не сможет изменить этот объект. В следующем примере функция <kbd>sp_to_dash()</kbd> печатает минус вместо каждого пробела в строке, передаваемой ей как аргумент. То есть строка "тестовый пример" будет напечатана как "тестовый-пример". Применение квалификатора <kbd>const</kbd> в объявлении параметра функции гарантирует, что внутри функций объект, на который указывает параметр функции, не будет изменен.
<pre>
#include &lt;stdio.h&gt;
void sp_to_dash(const char *str);
int main(void)
{
  sp_to_dash("тестовый пример");
  return 0;
}
void sp_to_dash(const char *str)
{
  while(*str) {
    if(*str== ' ') printf("%c", '-');
    else printf("%c", *str);
    str++;
  }
}
</pre>
<p class="tj">Если написать <kbd>sp_to_dash()</kbd> таким образом, что внутри функции строка изменяется, то еще на этапе компиляции в программе будет обнаружена ошибка. Например, на этапе компиляции возникнет ошибка, если написать так:
<pre>
/* Неправильный пример. */
void sp_to_dash(const char *str)
{
  while(*str) {
    if(*str==' ' ) *str = '-'; /* это не правильно */
    printf("%c", *str);
    str++;
  }
}
</pre>
<p class="tj">Квалификатор <kbd>const</kbd> используется в объявлениях параметров многих функций стандартной библиотеки. Например, прототип функции <kbd>strlen()</kbd> выглядит так:
<pre>size_t strlen(const char *<em>str</em>);</pre>
<p class="tj">Применение квалификатора <kbd>const</kbd> в объявлении <kbd>str</kbd> гарантирует, что функция не изменит строку, на которую указывает <kbd>str</kbd>. Если функция стандартной библиотеки не предназначена для изменения аргумента, то практически всегда в объявлении указателя на аргумент применяется квалификатор <kbd>const</kbd>.
<p class="tj">Программист тоже может применять квалификатор <kbd>const</kbd> для того, чтобы гарантировать сохранность объекта. Но следует помнить, что переменная, даже если к ней применен квалификатор <kbd>const</kbd>, может быть изменена в результате какого-нибудь внешнего по отношению к программе воздействия. Например, ей может быть присвоено значение каким либо устройством. Однако применение квалификатора <kbd>const</kbd> в объявлении переменной гарантирует, что ее изменение может произойти только в ходе внешнего по отношению к программе события.
<h2>Квалификатор volatile</h2>
<p class="tj">Квалификатор <kbd>volatile</kbd> указывает компилятору на то, что значение переменной может измениться независимо от программы, т.е. вследствие воздействия еще чего-либо, не являющегося оператором программы. Например, адрес глобальной переменной можно передать в подпрограмму операционной системы, следящей за временем, и тогда эта переменная будет содержать системное время. В этом случае значение переменной будет изменяться без участия какого-либо оператора программы. Знание таких подробностей важно потому, что большинство компиляторов С автоматически оптимизируют некоторые выражения, предполагая при этом неизменность переменной, если она не встречается в левой части оператора присваивания. В этом случае при очередной ссылке на переменную может использоваться ее предыдущее значение. Некоторые компиляторы изменяют порядок вычислений в выражениях, что может привести к ошибке, если в выражении присутствует переменная, вычисляемая вне программы. Квалификатор <kbd>volatile</kbd> предотвращает такие изменения программы.
<p class="tj">Квалификаторы <kbd>const</kbd> и <kbd>volatile</kbd> могут применяться и совместно. Например, если 0x30 — адрес порта, значение в котором может задаваться только извне, то следующее объявление предотвратит всякую возможность нежелательных побочных эффектов:
<pre>const volatile char *port = (const volatile char *) 0x30;</pre>
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Называются также <em>классификаторами</em>, <em>описателями</em>, <em>спецификаторами</em>.
<p class="tj"><sup><a href="#2" id="22">[2]</a></sup>На жаргоне программистов: переменная "типа" <kbd>const</kbd> не может изменять значение. В описании многих языков такие переменные часто называются константами. Но если исключить левые части операторов присваивания, то переменные этого "типа" могут использоваться в тех же ситуациях, что и "настоящие" переменные. В этом смысле константы являются частным случаем переменных.
</blockquote>
<p>
</p>
<hr><a href="../main.htm#02">Содержание</a> | <a href="0205.htm">&lt;&lt;&lt;</a> | <a href="0207.htm">&gt;&gt;&gt;</a>
</body>
</html>
