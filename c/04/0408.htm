<!DOCTYPE HTML>
<html lang="ru">
<HEAD>
<TITLE>Инициализация массивов - cправочник по Си</TITLE>
<meta charset="utf-8">
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#04">Содержание</A> | <A href="0407.htm">&lt;&lt;&lt;</A> | <A href="0409.htm">&gt;&gt;&gt;</A><HR>
<H1>Инициализация массивов</H1>
<P class="tj">В языке С массивы при объявлении можно инициализировать. Общая форма инициализации массива аналогична инициализации переменной:
<PRE><I>тип имя_массива</I>[<I>размер1</I>]...[<I>размер№</I>] = {<I>список_значений</I>};</PRE>
<P class="tj"><I>Список_значений</I> представляет собой список констант, разделенных запятыми. Типы констант должны быть совместимыми с <I>типом</I> массива. Первая константа присваивается первому элементу массива, вторая — второму и так далее. После закрывающейся фигурной скобки точка с запятой обязательна.</P>
<table class="table table-bordered">
<TR><td class="tdnote">На заметку<TD class="tj">В С99 локальные массивы можно инициализировать не константами, а переменными, однако в С89 все массивы инициализируются только константами.
</TABLE>
<P class="tj">В следующем примере массив целых из 10 элементов инициализируется числами от 1 до 10:
<PRE>int i[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};</PRE>
<P class="tj">Здесь элементу <KBD>i[0]</KBD> присваивается 1, a <KBD>i[9]</KBD> — 10.
<P class="tj">Символьные массивы, содержащие строки, можно инициализировать строковыми константами:
<PRE>char <I>имя_массива</I>[<I>размер</I>] = "<I>строка</I>";</PRE>
<P class="tj">В следующем примере массив <KBD>str</KBD> инициализируется фразой "Язык С":
<PRE>char str[9] = "Язык C";</PRE>
<P class="tj">Это объявление можно записать так:
<PRE>char str[9] = {'Я', 'з', 'ы', 'к', ' ', 'C', '\0'};</PRE>
<P class="tj">Строка кончается нулевым символом, поэтому при объявлении необходимо задавать размер массива, достаточный для того, чтобы этот символ поместился в нем. В предыдущем примере размер строки задан равным 7, хотя во фразе "Язык С" содержится 6 символов. Если строка инициализируется строковой константой, компилятор автоматически добавляет нулевой символ в конец строки.
<P class="tj">Многомерные массивы инициализируются так же, как и одномерные. В следующем примере массив <KBD>sqrs</KBD> инициализируется числами от 1 до 10 и их квадратами:
<PRE>
int sqrs[10][2] = {
  1, 1,
  2, 4,
  3, 9,
  4, 16,
  5, 25,
  6, 36,
  7, 49,
  8, 64,
  9, 81,
  10, 100
};
</PRE>
<P class="tj">Инициализируя многомерный массив, для улучшения наглядности элементы инициализации каждого измерения можно заключать в фигурные скобки. Этот способ называется <I>группированием подагрегатов</I> (<I>subaggregate grouping</I>). С использованием этого приема предыдущий пример может быть записан так:
<PRE>
int sqrs[10][2] = {
  {1, 1},
  {2, 4},
  {3, 9},
  {4, 16},
  {5, 25},
  {6, 36},
  {7, 49},
  {8, 64},
  {9, 81},
  {10, 100}
};
</PRE>
<P class="tj">При такой записи, если внутри группы недостаточно констант инициализации, то оставшиеся элементы группы автоматически заполняются нулями.
<H2>Инициализация безразмерных массивов</H2>
<P class="tj">Предположим, что необходимо создать таблицу сообщений об ошибках, используя инициализацию массивов:
<PRE>
char e1[12] = "Ошибка чтения\n";
char e2[13] = "Ошибка записи\n";
char e3[18] = "Нельзя открыть файл\n";
</PRE>
<P class="tj">Для задания размера массива пришлось бы вручную подсчитывать количество символов в каждом сообщении. Однако в языке С есть конструкция, благодаря которой компилятор автоматически определяет необходимую длину строки. Если в операторе инициализации массива не указан размер массива, компилятор создает массив такого размера, что в нем умещаются все инициализирующие элементы. Таким образом создается безразмерный массив. Используя этот метод, предыдущий пример можно записать так:
<PRE>
char e1[] = "Ошибка чтения\n";
char e2[] = "Ошибка записи\n";
char e3[] = "Нельзя открыть файл\n";
</PRE>
<P class="tj">Тогда оператор
<PRE>printf("%s имеет длину %d\n",  e2,  sizeof e2);</PRE>
<P class="t">выведет на экран следующее:
<PRE>
Ошибка записи
 имеет длину 15
</PRE>
<P class="tj">Кроме уменьшения трудоемкости, инициализация безразмерных массивов полезна тем, что позволяет изменять длину любого сообщения, не заботясь о соблюдении границ массивов.
<P class="tj">Инициализация безразмерных массивов поддерживается не только для одномерных массивов. В многомерном массиве размер самого левого измерения также можно не указывать. (Размеры по остальным измерениям обязательно должны быть указаны, так как это нужно компилятору для определения длины подмассивов, составляющих массив). Таким способом можно создавать таблицы переменного размера, компилятор автоматически выделит требуемую для них память. Например, объявление <KBD>sqrs</KBD> как безразмерного массива выглядит так:
<PRE>
int sqrs[][2] = {
  {1, 1},
  {2, 4},
  {3, 9},
  {4, 16},
  {5, 25},
  {6, 36},
  {7, 49},
  {8, 64},
  {9, 81},
  {10, 100}
};
</PRE>
<P class="tj">Преимущество безразмерного объявления массива состоит в том, что можно изменять длину таблицы, не заботясь о размере массива.
<p>
</p>
<HR><A href="../main.htm#04">Содержание</A> | <A href="0407.htm">&lt;&lt;&lt;</A> | <A href="0409.htm">&gt;&gt;&gt;</A>
</BODY>
</html>
