<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Одномерные массивы - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#04">Содержание</a> | <a href="04.htm">&lt;&lt;&lt;</a> | <a href="0402.htm">&gt;&gt;&gt;</a><hr>
<h1>Одномерные массивы</h1>
<p class="tj">Общая форма объявления одномерного массива имеет следующий вид:
<pre><em>тип имя_переменной</em> [<em>размер</em>];</pre>
<p class="tj">Как и другие переменные, массив должен быть объявлен явно, чтобы компилятор выделил для него определенную область памяти (т.е. разместил массив). Здесь <em>тип</em> обозначает базовый тип массива, являющийся типом каждого элемента. <em>Размер</em> задает количество элементов массива. Например, следующий оператор объявляет массив из 100 элементов типа <kbd>double</kbd> под именем <kbd>balance</kbd>:
<pre>double balance[100];</pre>
<p class="tj">Согласно стандарту С89 размер массива должен быть указан явно с помощью выражения-константы. Таким образом, в программе на С89 размер массива определяется во время компиляции и впоследствии остается неизменным. (В С99 определены массивы, размер которых определяется во время выполнения. О них еще будет идти речь далее в этой главе, а также более подробно в <a href="../II.htm">части II</a>).
<p class="tj">Доступ к элементу массива осуществляется с помощью имени массива и индекса. Индекс элемента массива помещается в квадратных скобках после имени. Например, оператор
<pre>balance[3] = 12.23;</pre>
<p class="t">присваивает 3-му элементу массива <kbd>balance</kbd> значение 12.23.
<p class="tj">Индекс первого элемента любого массива в языке С равен нулю. Поэтому оператор
<pre>char p[10];</pre>
<p class="t">объявляет массив символов из 10 элементов — от <kbd>р[0]</kbd> до <kbd>р[9]</kbd>. В следующей программе вычисляются значения элементов массива целого типа с индексами от 0 до 99:
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
  int x[100]; /* объявление массива 100 целых */
  int t;
  /* присваение массиву значений от 0 до 99 */
  for(t=0; t&lt;100; ++t) x[t] = t;
  /* вывод на экран содержимого x */
  for(t=0; t&lt;100; ++t) printf("%d ", x[t]);
  return 0;
}
</pre>
<p class="tj">Объем памяти, необходимый для хранения массива, непосредственно определяется его типом и размером. Для одномерного массива количество байтов памяти вычисляется следующим образом:
<pre>количество_байтов = sizeof(базовый_тип) &#215; длина_массива</pre>
<p class="tj">Во время выполнения программы на С не проверяется ни соблюдение границ массивов, ни их содержимое. В область памяти, занятую массивом, может быть записано что угодно, даже программный код. Программист должен сам, где это необходимо, ввести проверку границ индексов. Следующий пример программы компилируется без ошибки, однако при выполнении происходит нарушение границы массива <kbd>count</kbd> и разрушение соседних участков памяти:
<pre>
int count[10], i;
/* здесь нарушена граница массива count */
for(i=0; i&lt;100; i++) count[i] = i;
</pre>
<p class="tj">Можно сказать, что одномерный массив — это список, хранящийся в непрерывной области памяти в порядке индексации. На рис. 4.1 показано, как хранится в памяти массив <kbd>а</kbd>, начинающийся по адресу 1000 и объявленный как
<pre>char a[7];</pre>
<table class="table">
<caption class="bottom"><p class="tj"><em>Рис. 4.1. Массив из семи символов, начинающийся по адресу 1000</em>
<tr><td>
<pre>
Элемент   a[0]   a[1]   a[2]   a[3]   a[4]   a[5]   a[6]   a[7]
Адрес     1000   1001   1002   1003   1004   1005   1006   1007
</pre>
</table>
<hr><a href="../main.htm#04">Содержание</a> | <a href="04.htm">&lt;&lt;&lt;</a> | <a href="0402.htm">&gt;&gt;&gt;</a>


</body>
</html>
