<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Строки - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#04">Содержание</a> | <a href="0403.htm">&lt;&lt;&lt;</a> | <a href="0405.htm">&gt;&gt;&gt;</a><hr>
<h1>Строки</h1>
<p class="tj">Одномерный массив наиболее часто применяется в виде строки символов. <em>Строка</em> — это одномерный массив символов, заканчивающийся нулевым символом. В языке С признаком окончания строки (нулевым символом) служит символ '<kbd>\0</kbd>'. Таким образом, строка содержит символы, составляющие строку, а также нулевой символ. Это единственный вид строки, определенный в С.</p>
<table class="table table-bordered">
<tr><td class="tdnote">На заметку<td class="tj">В C++ дополнительно определен специальный класс строк, называющийся <kbd>String</kbd><sup><a href="#11" id="1">[1]</a></sup>, который позволяет обрабатывать строки объектно-ориентированными методами. Стандарт С не поддерживает <kbd>String</kbd>.
</table>
<p class="tj">Объявляя массив символов, предназначенный для хранения строки, необходимо предусмотреть место для нуля, т.е. указать его размер в объявлении на один символ больше, чем наибольшее предполагаемое количество символов. Например, объявление массива <kbd>str</kbd>, предназначенного для хранения строки из 10 символов, должно выглядеть так:
<pre>char str[11];</pre>
<p class="tj">Последний, 11-й байт предназначен для нулевого символа.
<p class="tj">Записанная в тексте программы строка символов, заключенных в двойные кавычки, является строковой константой, например,
<pre>"некоторая строка"</pre>
<p class="tj">В конец строковой константы компилятор автоматически добавляет нулевой символ.
<p class="tj">Для обработки строк в С определено много различных библиотечных функций. Чаще всего используются следующие функции:</p>
<table class="table table-bordered">
<tr><th><em>Имя функции</em><th><em>Выполняемое действие</em>
<tr><td><kbd>strcpy(<em>s1</em>,<em>s2</em>)</kbd><td>Копирование <em>s2</em> в <em>s1</em>
<tr><td><kbd>strcat(<em>s1</em>,<em>s2</em>)</kbd><td>Конкатенация (присоединение) <em>s2</em> в конец <em>s1</em>
<tr><td><kbd>strlen(<em>s1</em>)</kbd><td>Возвращает длину строки <em>s1</em>
<tr><td><kbd>strcmp(<em>s1</em>,<em>s2</em>)</kbd><td>Возвращает 0, если <em>s1</em> и <em>s2</em> совпадают, отрицательное значение, если <em>s1</em>&lt;<em>s2</em> и положительное значение, если <em>s1</em>&gt;<em>s2</em>
<tr><td><kbd>strchr(<em>s1</em>,<em>ch</em>)</kbd><td>Возвращает указатель на первое вхождение символа <em>ch</em> в строку <em>s1</em>
<tr><td><kbd>strstr(<em>s1</em>,<em>s2</em>)</kbd><td>Возвращает указатель на первое вхождение строки <em>s2</em> в строку <em>s1</em>
</table>
<p class="tj">Эти функции объявлены в заголовочном файле <kbd>&lt;string.h&gt;</kbd>. Применение библиотечных функций обработки строк иллюстрируется следующим примером:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
  char s1[80], s2[80];
  gets(s1);
  gets(s2);
  printf("Длина: %d %d\n", strlen(s1), strlen(s2));
  if(!strcmp(s1, s2)) printf("Строки равны\n");
  strcat(s1, s2);
  printf("%s\n", s1);
  strcpy(s1, "Проверка.\n");
  printf(s1);
  if(strchr("Алло", 'e')) printf(" л есть в Алло\n");
  if(strstr("Привет", "ив")) printf(" найдено ив ");
  return 0;
}
</pre>
<p class="tj">Если эту программу выполнить и ввести в <kbd>s1</kbd> и в <kbd>s2</kbd> одну и ту же строку <kbd>"Алло!"</kbd>, то на экран будет выведено следующее:
<pre>
Длина: 5 5
Строки равны
Алло!Алло!
Проверка,
л есть в Алло
найдено ив
</pre>
<p class="tj">Следует помнить, что <kbd>strcmp()</kbd> принимает значение ЛОЖЬ, если строки совпадают (хоть это и несколько нелогично). Поэтому в тесте на совпадение нужно использовать логический оператор отрицания <kbd>!</kbd> как в предыдущем примере.
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup><kbd>CString</kbd> в среде Visual C++</kbd>.
</blockquote>
<hr><a href="../main.htm#04">Содержание</a> | <a href="0403.htm">&lt;&lt;&lt;</a> | <a href="0405.htm">&gt;&gt;&gt;</a>


</body>
</html>
