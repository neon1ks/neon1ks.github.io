<!DOCTYPE HTML>
<html lang="ru">
<HEAD>
<TITLE>Строки - cправочник по Си</TITLE>
<meta charset="utf-8">
<LINK REL=STYLESHEET TYPE="text/css" HREF="../work/css.css">
</HEAD><BODY>
<A href="../main.htm#04">Содержание</A> | <A href="0403.htm">&lt;&lt;&lt;</A> | <A href="0405.htm">&gt;&gt;&gt;</A><HR>
<H1>Строки</H1>
<P class="tj">Одномерный массив наиболее часто применяется в виде строки символов. <I>Строка</I> — это одномерный массив символов, заканчивающийся нулевым символом. В языке С признаком окончания строки (нулевым символом) служит символ '<KBD>\0</KBD>'. Таким образом, строка содержит символы, составляющие строку, а также нулевой символ. Это единственный вид строки, определенный в С.</P>
<table class="table table-bordered">
<TR><td class="tdnote">На заметку<TD class="tj">В C++ дополнительно определен специальный класс строк, называющийся <KBD>String</KBD><SUP><A href="#11" id="1">[1]</A></SUP>, который позволяет обрабатывать строки объектно-ориентированными методами. Стандарт С не поддерживает <KBD>String</KBD>.
</TABLE>
<P class="tj">Объявляя массив символов, предназначенный для хранения строки, необходимо предусмотреть место для нуля, т.е. указать его размер в объявлении на один символ больше, чем наибольшее предполагаемое количество символов. Например, объявление массива <KBD>str</KBD>, предназначенного для хранения строки из 10 символов, должно выглядеть так:
<PRE>char str[11];</PRE>
<P class="tj">Последний, 11-й байт предназначен для нулевого символа.
<P class="tj">Записанная в тексте программы строка символов, заключенных в двойные кавычки, является строковой константой, например,
<PRE>"некоторая строка"</PRE>
<P class="tj">В конец строковой константы компилятор автоматически добавляет нулевой символ.
<P class="tj">Для обработки строк в С определено много различных библиотечных функций. Чаще всего используются следующие функции:</P>
<table class="table table-bordered">
<TR><TH><I>Имя функции</I><TH><I>Выполняемое действие</I>
<TR><TD><KBD>strcpy(<I>s1</I>,<I>s2</I>)</KBD><TD>Копирование <I>s2</I> в <I>s1</I>
<TR><TD><KBD>strcat(<I>s1</I>,<I>s2</I>)</KBD><TD>Конкатенация (присоединение) <I>s2</I> в конец <I>s1</I>
<TR><TD><KBD>strlen(<I>s1</I>)</KBD><TD>Возвращает длину строки <I>s1</I>
<TR><TD><KBD>strcmp(<I>s1</I>,<I>s2</I>)</KBD><TD>Возвращает 0, если <I>s1</I> и <I>s2</I> совпадают, отрицательное значение, если <I>s1</I>&lt;<I>s2</I> и положительное значение, если <I>s1</I>&gt;<I>s2</I>
<TR><TD><KBD>strchr(<I>s1</I>,<I>ch</I>)</KBD><TD>Возвращает указатель на первое вхождение символа <I>ch</I> в строку <I>s1</I>
<TR><TD><KBD>strstr(<I>s1</I>,<I>s2</I>)</KBD><TD>Возвращает указатель на первое вхождение строки <I>s2</I> в строку <I>s1</I>
</TABLE>
<P class="tj">Эти функции объявлены в заголовочном файле <KBD>&lt;string.h&gt;</KBD>. Применение библиотечных функций обработки строк иллюстрируется следующим примером:
<PRE>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
  char s1[80], s2[80];
  gets(s1);
  gets(s2);
  printf("Длина: %d %d\n", strlen(s1), strlen(s2));
  if(!strcmp(s1, s2)) printf("Строки равны\n");
  strcat(s1, s2);
  printf("%s\n", s1);
  strcpy(s1, "Проверка.\n");
  printf(s1);
  if(strchr("Алло", 'e')) printf(" л есть в Алло\n");
  if(strstr("Привет", "ив")) printf(" найдено ив ");
  return 0;
}
</PRE>
<P class="tj">Если эту программу выполнить и ввести в <KBD>s1</KBD> и в <KBD>s2</KBD> одну и ту же строку <KBD>"Алло!"</KBD>, то на экран будет выведено следующее:
<PRE>
Длина: 5 5
Строки равны
Алло!Алло!
Проверка,
л есть в Алло
найдено ив
</PRE>
<P class="tj">Следует помнить, что <KBD>strcmp()</KBD> принимает значение ЛОЖЬ, если строки совпадают (хоть это и несколько нелогично). Поэтому в тесте на совпадение нужно использовать логический оператор отрицания <KBD>!</KBD> как в предыдущем примере.
<p><IMG src="../work/sup.bmp" alt="----------">
<BLOCKQUOTE>
<P class="tj"><SUP><A href="#1" id="11">[1]</A></SUP><KBD>CString</KBD> в среде Visual C++</KBD>.
</BLOCKQUOTE>
<p>
</p>
<HR><A href="../main.htm#04">Содержание</A> | <A href="0403.htm">&lt;&lt;&lt;</A> | <A href="0405.htm">&gt;&gt;&gt;</A>
</BODY>
</html>
