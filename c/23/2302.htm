<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Представление разреженного массива в виде связного списка - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head><body>
<a href="../main.htm#23">Содержание</a> | <a href="2301.htm">&lt;&lt;&lt;</a> | <a href="2303.htm">&gt;&gt;&gt;</a><hr>
<h1>Представление разреженного массива в виде связного списка</h1>
<p class="tj">При реализации разреженного массива с помощью связанного списка первым делом необходимо создать структуру, содержащую следующие элементы:
<ul class="square">
<li>Хранимые в ячейке данные
<li>Логическая позиция ячейки в массиве
<li>Ссылки на предыдущий и следующий элементы
</ul>
<p class="tj">Каждая новая структура помещается в список так, что элементы остаются упорядоченными по индексу в массиве. Доступ к массиву производится путем перехода по ссылкам.
<p class="tj">Например, в качестве носителя элемента разреженного массива в электронной таблице можно использовать следующую структуру:
<pre>
struct cell {
  char cell_name[9];  /* имя ячейки, напр., A1, B34 */
  char  formula[128]; /* информация, напр., 10/B2 */
  struct cell *next;  /* указатель на следующую запись */
  struct cell *prior; /* указатель на предыдущую запись */
} ;
</pre>
<p class="tj">Поле <kbd>cell_name</kbd> содержит строку, соответствующую имени ячейки, например, А1, В34 или Z19. Строковое поле <kbd>formula</kbd> хранит формулу (данные) из соответствующей ячейки таблицы.
<p class="tj">Полная программа обработки электронных таблиц была бы слишком большой<sup><a href="#11" id="1">[1]</a></sup>, чтобы использовать ее в качестве примера. Вместо этого в данной главе рассмотрены ключевые функции, обеспечивающие реализацию разреженного массива на основе связанного списка. Следует помнить, что существует очень много способов реализации программы обработки электронных таблиц. Показанные здесь функции и структура данных — лишь примеры приемов работы с разреженными массивами.
<p class="tj">Следующие глобальные переменные указывают на начало и конец связанного списка:
<pre>
struct cell *start = NULL; /* первый элемент списка */
struct cell *last = NULL;  /* последний элемент списка */
</pre>
<p class="tj">В большинстве электронных таблиц при вводе формулы в ячейку создается новый элемент разреженного массива. Если электронная таблица построена на основе связанного списка, этот элемент вставляется в список с помощью функции, аналогичной функции <kbd>dls_store()</kbd>, приведенной в <a href="../22/22.htm">главе 22</a>. Помните, что список упорядочен по именам ячеек; например, А12 предшествует А13 и т.д.
<pre>
/* Вставка ячеек в упорядоченный список. */
void dls_store(struct cell *i, /* указатель на вставляемую ячейку */
               struct cell **start,
               struct cell **last)
{
  struct cell *old, *p;
  if(!*last) { /* первый элемент в списке */
    i->next = NULL;
    i->prior = NULL;
    *last = i;
    *start = i;
    return;
  }
  p = *start; /* начать с головы списка */
  old = NULL;
  while(p) {
    if(strcmp(p->cell_name, i->cell_name) < 0){
      old = p;
      p = p->next;
    }
    else {
      if(p->prior) { /* это элемент из середины */
        p->prior->next = i;
        i->next = p;
        i->prior = p->prior;
        p->prior = i;
        return;
      }
      i->next = p; /* новый первый элемент */
      i->prior = NULL;
      p->prior = i;
      *start = i;
      return;
    }
  }
  old->next = i; /* вставка в конец */
  i->next = NULL;
  i->prior = old;
  *last = i;
  return;
}
</pre>
<p class="tj">В приведенной выше функции параметр <kbd>i</kbd> — указатель на новую вставляемую ячейку. Параметры <kbd>start</kbd> и <kbd>last</kbd> являются соответственно указателями на указатели на начало и конец списка.
<p class="tj">Нижеследующая функция <kbd>deletecell()</kbd> удаляет из списка ячейку, имя которой передается в качестве параметра.
<pre>
void deletecell(char *cell_name,
            struct cell **start,
            struct cell **last)
{
  struct cell *info;
  info = find(cell_name, *start);
  if(info) {
    if(*start==info) {
      *start = info->next;
      if(*start) (*start)->prior = NULL;
      else *last = NULL;
    }
    else {
      if(info->prior) info->prior->next = info->next;
      if(info != *last)
          info->next->prior = info->prior;
      else
        *last = info->prior;
    }
    free(info); /* освободить системную память */
  }
}
</pre>
<p class="tj">Последняя функция, которая понадобится для реализации разреженного массива на основе связанного списка — это функция <kbd>find()</kbd>, находящая указанную ячейку. Для нахождения ячейки данной функции приходится выполнять линейный поиск, но, как было показано в <a href="../21/21.htm">главе 21</a>, среднее количество сравнений при линейном поиске равно <em>n</em>/2, где <em>n</em> — количество элементов в списке. Ниже приведен текст функции <kbd>find()</kbd>:
<pre>
struct cell *find(char *cell_name, struct cell *start)
{
  struct cell *info;
  info = start;
  while(info) {
    if(!strcmp(cell_name, info->cell_name)) return info;
    info = info->next; /* перейти к следующей ячейке */
  }
  printf("Ячейка не найдена.\n");
  return NULL; /* поиск неудачный */
}
</pre>
<h2>Анализ метода представления в виде связного списка</h2>
<p class="tj">Принципиальное преимущество метода реализации разреженного массива с помощью связанного списка заключается в том, что он позволяет эффективно использовать память — место выделяется только для тех элементов массива, которые действительно содержат информацию. Кроме того, он прост в реализации. Тем не менее, у этого метода есть один большой недостаток: для доступа к ячейкам в нем применяется линейный поиск. Причем процедура сохранения ячейки также использует линейный поиск, чтобы найти место вставки нового элемента. Эти проблемы можно разрешить, построив разреженный массив на основе двоичного дерева, как показано ниже.
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Многие пользователи шутят, что сама Microsoft не знает, сколько же точно занимает ее Excel. Конечно, это только шутка, но лично я иногда думаю, что в ней 100 % правды.
</blockquote>
<p>
</p>
<hr><a href="../main.htm#23">Содержание</a> | <a href="2301.htm">&lt;&lt;&lt;</a> | <a href="2303.htm">&gt;&gt;&gt;</a>
</body>
</html>
