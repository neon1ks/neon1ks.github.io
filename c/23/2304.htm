<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Представление разреженного массива в виде массива указателей - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head><body>
<a href="../main.htm#23">Содержание</a> | <a href="2303.htm">&lt;&lt;&lt;</a> | <a href="2305.htm">&gt;&gt;&gt;</a><hr>
<h1>Представление разреженного массива в виде массива указателей</h1>
<p class="tj">Допустим, что электронная таблица имеет размер 26x100 (от А1 до Z100), то есть состоит из 2`600 элементов. Теоретически можно хранить элементы таблицы в следующем массиве структур:
<pre>
struct cell {
  char cell_name[9];
  char  formula[128];
} list_entry[2600];   /* 2600 ячеек */
</pre>
<p class="tj">Ho 2`600, умноженное на 137 байтов (размер этой структуры в байтах), равняется 356`200 байтов памяти. Это слишком большой объем памяти, чтобы тратить его на не полностью используемый массив. Тем не менее, можно создать <em>массив указателей</em> (pointer array) на структуры типа <kbd>cell</kbd>. Для хранения массива указателей требуется намного меньше памяти, чем для массива структур. При каждом присвоении ячейке логического массива данных под эти данные выделяется память, а соответствующему указателю в массиве указателей присваивается адрес выделенного фрагмента. Такая схема позволяет добиться более высокой производительности, чем при связанном списке или двоичном дереве. Описание массива указателей выглядит следующим образом:
<pre>
struct cell {
  char cell_name[9];
  char formula[128];
} list_entry;
struct cell *sheet[2600]; /* массив из 2600 указателей */
</pre>
<p class="tj">Этот меньший по объему занимаемой памяти массив используется для хранения указателей на вводимые в электронную таблицу данные. При вводе очередной записи в соответствующую ячейку массива заносится указатель на введенные данные.  На рис. 23.2 показано, как выглядит в памяти разреженный массив, представленный в виде массива указателей.</p>
<table class="table">
<caption class="bottom"><p class="tj"><em>Рис. 23.2. Представление разреженного массива в виде массива указателей</em>
<tr><td>
<pre>
+-+-+-+-+-+-+-+-+-+-+-+-+
|.|.|0|0|.|0|0|0|.|0|0|0|
+|+|+-+-+|+-+-+-+|+-+-+-+
 | |     |       |  +----+
 | |     |       '->|A[8]|
 | |     |          +----+
 | |     |  +----+
 | |     '->|A[4]|
 | |        +----+
 | |  +----+
 | '->|A[1]|
 |    +----+
 |  +----+
 '->|A[0]|
    +----+
</pre>
</table>
<p class="tj">Перед использованием массива указателей каждый его элемент необходимо проинициализировать нулем (<kbd>NULL</kbd>), что означает отсутствие данной записи. Ниже показана функция инициализации массива:
<pre>
void init_sheet(void)
{
  register int t;
  for(t=0; t < 2600; ++t) sheet[t] = NULL;
}
</pre>
<p class="tj">Когда пользователь вводит формулу в ячейку, занимающую определенное положение в электронной таблице (а положение ячейки, как известно, определяется ее именем), вычисляется индекс в массиве указателей <kbd>sheet</kbd>. Этот индекс получается путем преобразования строкового представления имени ячейки в число, как показано в следующем листинге:
<pre>
void store(struct cell *i)
{
  int loc;
  char *p;
  /* вычисление индекса по заданному имени */
  loc = *(i->cell_name) - 'A'; /* столбец */
  p = &(i->cell_name[1]);
  loc += (atoi(p)-1) * 26; /* количество строк * ширина строки +
                              столбец */
  if(loc >= 2600) {
    printf("Ячейка за пределами массива.\n");
    return;
  }
  sheet[loc] = i; /* поместить указатель в массив */
}
</pre>
<p class="tj">При вычислении индекса в функции <kbd>store()</kbd> предполагается, что все имена ячеек начинаются с прописной буквы, за которой следует целое число, например, В34, С19 и т.д. Поэтому в результате вычислений по формуле, запрограммированной в функции <kbd>store()</kbd>, имя ячейки А1 соответствует индексу 0, имя В1 соответствует индексу 1, А2 — 26 и т.д. Поскольку имена ячеек уникальны, индексы также уникальны и указатель на каждую запись хранится в соответствующей позиции массива. Если сравнить эту процедуру с версиями, использующими связанный список или двоичное дерево, становится понятно, насколько она проще и короче.
<p class="tj">Функция удаления ячейки <kbd>deletecell()</kbd> также становится очень короткой. При вызове она просто обнуляет указатель на элемент и возвращает системе память.
<pre>
void deletecell(struct cell *i)
{
  int loc;
  char *p;
  /* вычисление индекса по заданному имени ячейки */
  loc = *(i->cell_name) - 'A'; /* столбец */
  p = &(i->cell_name[1]);
  loc += (atoi(p)-1) * 26; /* количества строк * ширина строки +
                              столбец */
  if(loc >= 2600) {
    printf("Ячейка за пределами массива.\n");
    return;
  }
  if(!sheet[loc]) return; /* не освобождать, если указатель нулевой
                             (null) */
  free(sheet[loc]);  /* освободить системную память */
  sheet[loc] = NULL;
}
</pre>
<p class="tj">Этот код также намного быстрее и проще, чем в версии со связанным списком.
<p class="tj">Процесс поиска ячейки по имени прост, поскольку имя ячейки однозначно определяет индекс в массиве указателей. Поэтому функция поиска принимает следующий вид:
<pre>
struct cell *find(char *cell_name)
{
  int loc;
  char *p;
  /* вычисление индекса по заданному имени ячейки */
  loc = *(cell_name) - 'A'; /* столбец */
  p = &(cell_name[1]);
  loc += (atoi(p)-1) * 26; /* количества строк * ширина строки +
                              столбец */
  if(loc>=2600 || !sheet[loc]) { /* эта ячейка пустая */
    printf("Ячейка не найдена.\n");
    return NULL;  /* поиск неуспешный */
  }
  else return sheet[loc];
}
</pre>
<h2>Анализ метода представления разреженного массива в виде массива указателей</h2>
<p class="tj">Метод реализации разреженного массива на основе массива указателей обеспечивает намного более быстрый доступ к элементам, чем методы на основе связанного списка и двоичного дерева. Если массив не очень большой, выделение памяти для массива указателей лишь незначительно уменьшает объем свободной памяти системы. Тем не менее, в массиве указателей для каждой ячейки выделяется некоторый объем памяти независимо от того, используется она или нет. В некоторых приложениях это может быть ограничением, хотя в общем случае это не является проблемой.
<p>
</p>
<hr><a href="../main.htm#23">Содержание</a> | <a href="2303.htm">&lt;&lt;&lt;</a> | <a href="2305.htm">&gt;&gt;&gt;</a>
</body>
</html>
