<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Хэширование - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head><body>
<a href="../main.htm#23">Содержание</a> | <a href="2304.htm">&lt;&lt;&lt;</a> | <a href="2306.htm">&gt;&gt;&gt;</a><hr>
<h1>Хэширование</h1>
<p class="tj"><em>Хэширование</em> (hashing) — это процесс получения индекса элемента массива непосредственно в результате операций, производимых над ключом, который хранится вместе с элементом или даже совпадает с ним. Генерируемый индекс называется <em>хэш-адресом</em> (hash). Традиционно хэширование применяется к дисковым файлам как одно из средств уменьшения времени доступа. Тем не менее, этот общий метод можно применить и с целью доступа к разреженным массивам. В предыдущем примере с массивом указателей использовалась специальная форма хэширования, которая называется <em>прямая адресация</em>. В ней каждый ключ соответствует одной и только одной ячейке массива<sup><a href="#11" id="1">[1]</a></sup>. Другими словами, каждый индекс, вычисленный в результате хэширования, уникальный. (При представлении разреженного массива в виде массива указателей хэш-функция не должна обязательно реализовывать прямую адресацию — просто это был очевидный подход к реализации электронной таблицы.) В реальной жизни схемы прямого хэширования встречаются редко; обычно требуется более гибкий метод. В данном разделе показано, как можно обобщить метод хэширования, придав ему большую мощь и гибкость.
<p class="tj">В примере с электронной таблицей понятно, что даже в самых сложных случаях используются не все ячейки таблицы. Предположим, что почти во всех случаях фактически занятые ячейки составляют не более 10 процентов потенциально доступных мест. Это значит, что если таблица имеет размер 260x100 (2`600 ячеек), в любой момент времени будет использоваться лишь примерно 260 ячеек. Этим подразумевается, что самый большой массив, который понадобится для хранения всех занятых ячеек, будет в обычных условиях состоять только из 260 элементов. Но как ячейки логического массива сопоставить этому меньшему физическому массиву? И что происходит, когда этот массив переполняется? Ниже предлагается одно из возможных решений.
<p class="tj">Когда пользователь вводит данные в ячейку электронной таблицы (т.е. заполняет элемент логического массива), позиция ячейки, определяемая по ее имени, используется для получения индекса (хэш-адреса) в меньшем физическом массиве. При выполнении хэширования физический массив называется также <em>первичным массивом</em>. Индекс в первичном массиве получается из имени ячейки, которое преобразуется в число, точно так, как и в примере с массивом указателей. Но затем это число делится на 10, в результате чего получается начальная точка входа в первичный массив. (Помните, что в данном случае размер физического массива составляет только 10 % размера логического массива.) Если ячейка физического массива по этому индексу свободна, в нее заносятся логический индекс и данные. Но поскольку 10 логических позиций соответствуют одной физической позиции, могут возникнуть коллизии при вычислении хэш-адресов<sup><a href="#22" id="2">[2]</a></sup>. Когда это происходит, записи сохраняются в связанном списке, иногда называемом <em>списком коллизий</em> (collision list). С каждой ячейкой первичного массива связан отдельный список коллизий. Конечно, до возникновения коллизии эти списки имеют нулевую длину, как показано на рис. 23.3.</p>
<table class="table">
<caption class="bottom"><p class="tj"><em>Рис. 23.3. Пример хэширования</em>
<tr><td>
<pre>
            Указатель
               на
             список
    Индекс  коллизий
   +------+----------+   +--+    +--+
 0 |  А1  |     -------->|B1|--->|C1|
   +------+----------+   +--+    +--+
 1 |  L1  |     -------->|P1|
   +------+----------+   +--+
 2 |  А2  |   NULL   |
   +------+----------+
 3 |  M2  |   NULL   |
   +------+----------+
 4 |      |   NULL   |
   +------+----------+  Порядок
   |      .          |  поступления:
   |      .          |            A1
   |      .          |            L1
   +------+----------+            B1
258|  А1  |   NULL   |            C1
   +------+----------+            P1
259|  А1  |   NULL   |            A2
   +------+----------+            M2
    Первичный массив
</pre>
</table>
<p class="tj">Предположим, требуется найти элемент в физическом массиве по его логическому индексу. Сначала необходимо преобразовать логический индекс в соответствующее значение хэш-адреса и проверить, соответствует ли логический индекс, хранящийся в полученной позиции физического массива, искомому. Если да, информацию можно извлечь. В противном случае необходимо просматривать список коллизий для данной позиции до тех пор, пока не будет найден требуемый логический индекс или пока не будет достигнут конец цепочки.
<p class="tj">В примере хэширования используется массив структур под названием <kbd>primary</kbd>:
<pre>
#define MAX 260
struct htype {
  int index;   /* логический индекс */
  int val;     /* собственно значение элемента данных */
  struct htype *next; /* указатель на следующий элемент с таким же
                         хэш-адресом */
} primary[MAX];
</pre>
<p class="tj">Перед использованием этого массива необходимо его инициализировать. Следующая функция присваивает полю <kbd>index</kbd> значение -1 (значение, которое по определению никогда не будет сгенерировано в качестве индекса); это значение обозначает пустой элемент. Значение <kbd>NULL</kbd> в поле <kbd>next</kbd> соответствует пустой цепочке хэширования<sup><a href="#33" id="3">[3]</a></sup>.
<pre>
/* Инициализация хэш-массива. */
void init(void)
{
  register int i;
  for (i=0; i&lt;MAX; i++) {
    primary[i].index = -1;
    primary[i].next = NULL;  /* пустая цепочка */
    primary[i].val = 0;
  }
}
</pre>
<p class="tj">Процедура <kbd>store()</kbd> преобразует имя ячейки в хэш-адрес в первичном массиве <kbd>primary</kbd>. Если позиция, на которую указывает значение хэш-адрес, занята, процедура автоматически добавляет запись в список коллизий с помощью модифицированной версии функции <kbd>slstore()</kbd> из предыдущей главы. Логический индекс также сохраняется, поскольку он понадобится при извлечении элемента. Данные функции показаны ниже:
<pre>
/* Вычисление хэш-адреса и сохранение значения. */
void store(char *cell_name, int v)
{
  int h, loc;
  struct htype *p;
  /* Получение хэш-адреса */
  loc = *cell_name - 'A'; /* столбец */
  loc += (atoi(&cell_name[1])-1) * 26; /* строка * ширина + столбец */
  h = loc/10; /* hash */
  /* Сохранить в полученной позиции, если она не занята
     либо если логические индексы совпадают - то есть, при обновлении.
  */
  if(primary[h].index==-1 || primary[h].index==loc) {
    primary[h].index = loc;
    primary[h].val = v;
    return;
  }
  /* в противном случае, создать список коллизий
     либо добавить в енго элемент */
  p = (struct htype *) malloc(sizeof(struct htype));
  if(!p) {
    printf("Не хватает памяти\n");
    return;
  }
  p-&gt;index = loc;
  p-&gt;val = v;
  slstore(p, &primary[h]);
}
/* Добавление элементов в список коллизий. */
void slstore(struct htype *i,
             struct htype *start)
{
  struct htype *old, *p;
  old = start;
  /* найти конец списка */
  while(start) {
    old = start;
    start = start-&gt;next;
  }
  /* связать с новой записью */
  old-&gt;next = i;
  i-&gt;next = NULL;
}
</pre>
<p class="tj">Для того чтобы получить значение элемента, программа должна сначала вычислить хэш-адрес и проверить, совпадает ли с искомым логический индекс, хранящийся в полученной позиции физического массива. Если совпадает, возвращается значение ячейки; в противном случае — производится поиск в списке коллизий. Функция <kbd>find()</kbd>, выполняющая эти задачи, показана ниже:
<pre>
/* Вычисление хэш-адреса и получение значения. */
int find(char *cell_name)
{
  int h, loc;
  struct htype *p;
  /* получение значения хэш-адреса */
  loc = *cell_name - 'A'; /* столбец */
  loc += (atoi(&cell_name[1])-1) * 26; /* строка * ширина + столбец */
  h = loc/10;
  /* вернуть значение, если ячейка найдена */
  if(primary[h].index == loc) return(primary[h].val);
  else { /* в противном случае просмотреть список коллизий */
    p = primary[h].next;
    while(p) {
      if(p->index == loc) return p->val;
      p = p->next;
    }
    printf("Ячейки нет в массиве\n");
    return -1;
  }
}
</pre>
<p class="tj">Создание функции удаления оставлено читателю в качестве упражнения. (<em>Подсказка</em>: Просто обратите процесс вставки.)
<p class="tj">Показанный выше алгоритм хэширования очень прост. Как правило, на практике применяются более сложные методы, обеспечивающие более равномерное распределение индексов в первичном массиве, что устраняет длинные цепочки хэширования. Тем не менее, основной принцип остается таким же.
<h2>Анализ метода хэширования</h2>
<p class="tj">В лучшем случае (довольно редком) каждый физический индекс, вычисляемый хэш-функцией, уникален, а время доступа примерно равно времени доступа при прямой адресации. Это значит, что списки коллизий не создаются, а все операции выборки являются по сути операциями прямого доступа. Однако так бывает редко, поскольку для этого требуется, чтобы логические индексы равномерно распределялись в пространстве физических индексов. В худшем случае (также редком) схема хэширования вырождается в связанный список. Это происходит, когда значения хэш-адресов всех логических индексов совпадают. В среднем (и наиболее вероятном) случае время доступа при хэшировании равно времени доступа при прямой адресации плюс некоторая константа, пропорциональная средней длине цепочек хэширования. Самый важный фактор при реализации разреженных массивов методом хэширования — выбор такого алгоритма хэширования, при котором равномерно распределяются физические индексы, что позволяет избежать образования длинных списков коллизий.
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Иными словами, хэш-функция является биекцией.
<p class="tj"><sup><a href="#2" id="22">[2]</a></sup>Т.е. ситуации, когда разным ключам k<sub>1</sub>&#8800;k<sub>2</sub> соответствует один и тот же хэш-адрес: h(k<sub>1</sub>)=h(k<sub>2</sub>) (здесь h — хэш-функция).
<p class="tj"><sup><a href="#3" id="33">[3]</a></sup><em>Цепочка хэширования</em> (hash chain) — цепочка, соединяющая элементы хэш-таблицы с одним и тем же хэш-кодом. Ранее автор назват ее <em>списком коллизий</em> (collision list). Иногда она называется также <em>пакетом переполнения</em>.
</blockquote>
<p>
</p>
<hr><a href="../main.htm#23">Содержание</a> | <a href="2304.htm">&lt;&lt;&lt;</a> | <a href="2306.htm">&gt;&gt;&gt;</a>
</body>
</html>
