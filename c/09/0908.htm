<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Стандартные потоки - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#09">Содержание</a> | <a href="0907.htm">&lt;&lt;&lt;</a> | <a href="../10/10.htm">&gt;&gt;&gt;</a><hr>
<h1>Стандартные потоки</h1>
<p class="tj">Что касается файловой системы языка С, то в начале выполнения программы автоматически открываются три потока. Это <kbd>stdin</kbd> (стандартный поток ввода), <kbd>stdout</kbd> (стандартный поток вывода) и <kbd>stderr</kbd> (стандартный поток ошибок). Обычно эти потоки направляются к консоли, но в средах, которые поддерживают перенаправление ввода/вывода, они могут быть перенаправлены операционной системой на другое устройство. (Перенаправление ввода/вывода поддерживается, например, такими операционными системами, как Windows, DOS, UNIX и OS/2.)
<p class="tj">Так как стандартные потоки являются указателями файлов, то они могут использоваться системой ввода/вывода языка С также для выполнения операций ввода/вывода на консоль. Например, <kbd>putchar()</kbd> может быть определена таким образом:
<pre>
int putchar(char c)
{
  return putc(c, stdout);
}
</pre>
<p class="tj">Вообще говоря, <kbd>stdin</kbd> используется для считывания с консоли, a <kbd>stdout</kbd> и <kbd>stderr</kbd> — для записи на консоль.
<p class="tj">В роли указателей файлов потоки <kbd>stdin</kbd>, <kbd>stdout</kbd> и <kbd>stderr</kbd> можно применять в любой функции, где используется переменная типа <kbd>FILE *</kbd>. Например, для ввода строки с консоли можно написать примерно такой вызов <kbd>fgets()</kbd>:
<pre>
char str[255];
fgets(str, 80, stdin);
</pre>
<p class="tj">И действительно, такое применение <kbd>fgets()</kbd> может оказаться достаточно полезным. Как уже говорилось в этой книге, при использовании <kbd>gets()</kbd> не исключена возможность, что массив, который используется для приема вводимых пользователем символов, будет переполнен. Это возможно потому, что <kbd>gets()</kbd> не проводит проверку на отсутствие нарушения границ. Полезной альтернативой <kbd>gets()</kbd> является функция <kbd>fgets()</kbd> с аргументом <kbd>stdin</kbd>, так как эта функция может ограничивать число читаемых символов и таким образом не допустить переполнения массива. Единственная проблема, связанная с <kbd>fgets()</kbd>, состоит в том, что она не удаляет символ новой строки (в то время как <kbd>gets()</kbd> удаляет!), поэтому его приходится удалять "вручную", как показано в следующей программе:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(void)
{
  char str[80];
  int i;
  printf("Введите строку: ");
  fgets(str, 10, stdin);
  /* удалить символ новой строки, если он есть */
  i = strlen(str)-1;
  if(str[i]=='\n') str[i] = '\0';
  printf("Это Ваша строка: %s", str);
  return 0;
}
</pre>
<p class="tj">He забывайте, что <kbd>stdin</kbd>, <kbd>stdout</kbd> и <kbd>stderr</kbd> — это не переменные в обычном смысле, и им нельзя присваивать значение с помощью <kbd>fopen()</kbd>. Кроме того, именно потому, что в начале работы программы эти указатели файлов создаются автоматически, в конце работы они и закрываются автоматически. Так что и не пытайтесь самостоятельно их закрыть.
<h2>Связь с консольным вводом / выводом</h2>
<p class="tj">В языке С консольный и файловый ввод/вывод не слишком отличаются друг от друга. Функции консольного ввода/вывода, описанные в <a href="../08/08.htm">главе 8</a>, на самом деле направляют результаты своих операций на один из потоков — <kbd>stdin</kbd> или <kbd>stdout</kbd>, и по сути, каждая из них является специальной версией соответствующей файловой функции. Функции консольного ввода/вывода для того и существуют, чтобы было удобно именно программисту.
<p class="tj">Как говорилось в предыдущем разделе, ввод/вывод на консоль можно выполнять с помощью любой файловой функции языка С. Однако для вас может быть сюрпризом, что, оказывается, операции ввода/вывода на дисковых файлах можно выполнять с помощью функции консольного ввода/вывода, например, <kbd>printf()</kbd>! Дело в том, что все функции консольного ввода/вывода, о которых говорилось в <a href="../08/08.htm">главе 8</a>, выполняют свои операции с потоками <kbd>stdin</kbd> и <kbd>stdout</kbd>. В средах, поддерживающих перенаправление ввода/вывода, это равносильно тому, что <kbd>stdin</kbd> или <kbd>stdout</kbd> могут быть перенаправлены на устройство, отличное от клавиатуры или экрана. Проанализируйте, например, следующую программу:
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
  char str[80];
  printf("Введите строку: ");
  gets(str);
  printf(str);
  return 0;
}
</pre>
<p class="tj">Предположим, что эта программа называется TEST. При ее нормальном выполнении на экран выводится подсказка, затем читается строка, введенная с клавиатуры, и, наконец, эта строка выводится на экран. Однако в средах, в которых поддерживается перенаправление ввода/вывода, один из потоков <kbd>stdin</kbd> или <kbd>stdout</kbd> (или оба одновременно) можно перенаправить в файл. Например, в среде DOS или Windows следующий запуск TEST
<pre>TEST &gt; OUTPUT</pre>
<p class="t">приводит к тому,  что вывод этой  программы  будет записан  в файл по имени OUTPUT. А следующий запуск TEST
<pre>TEST &lt; INPUT &gt; OUTPUT</pre>
<p class="t">направляет поток <kbd>stdin</kbd> в файл по имени INPUT, а поток стандартного вывода — в файл по имени OUTPUT.
<p class="tj">Когда С-программа завершается, то все перенаправленные потоки возвращаются в состояния, которые были установлены по умолчанию.
<h2>Перенаправление стандартных потоков: функция freopen()</h2>
<p class="tj">Для перенаправления стандартных потоков можно воспользоваться функцией <kbd>freopen()</kbd>. Эта функция связывает имеющийся поток с новым файлом. Так что она вполне может связать с новым файлом и стандартный поток. Вот прототип этой функции:
<pre>FILE *freopen(const char *<em>имя_файла</em>, const char *<em>режим</em>, FILE *<em>поток</em>);</pre>
<p class="t">где <em>имя_файла</em> — это указатель на имя файла, который требуется связать с потоком, на который указывает указатель <em>поток</em>. Файл открывается в режиме <em>режим</em>; этот параметр может принимать те же значения, что и соответствующий параметр функции <kbd>fopen()</kbd>. Если функция <kbd>freopen()</kbd> выполнилась успешно, то она возвращает <em>поток</em>, а если встретились ошибки, — то <kbd>NULL</kbd>.
<p class="tj">В следующей программе показано использование функции <kbd>freopen()</kbd> для перенаправления стандартного потока вывода <kbd>stdout</kbd> в файл с именем OUTPUT.
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
  char str[80];
  freopen("OUTPUT", "w", stdout);
  printf("Введите строку: ");
  gets(str);
  printf(str);
  return 0;
}
</pre>
<p class="tj">Вообще говоря, перенаправление стандартных потоков с помощью <kbd>freopen()</kbd> в некоторых случаях может быть полезно, например, при отладке. Однако выполнение дисковых операций ввода/вывода на перенаправленных потоках <kbd>stdin</kbd> и <kbd>stdout</kbd> не настолько эффективно, как использование таких функций, как <kbd>fread()</kbd> или <kbd>fwrite()</kbd>.
<hr><a href="../main.htm#09">Содержание</a> | <a href="0907.htm">&lt;&lt;&lt;</a> | <a href="../10/10.htm">&gt;&gt;&gt;</a>


</body>
</html>
