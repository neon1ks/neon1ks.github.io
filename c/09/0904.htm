<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Основы файловой системы - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head><body>
<a href="../main.htm#09">Содержание</a> | <a href="0903.htm">&lt;&lt;&lt;</a> | <a href="0905.htm">&gt;&gt;&gt;</a><hr>
<h1>Основы файловой системы</h1>
<p class="tj">Файловая система языка С состоит из нескольких взаимосвязанных функций. Самые распространенные из них показаны в табл. 9.1. Для их работы требуется заголовок <kbd>&lt;stdio.h&gt;</kbd>.</p>
<table class="table table-bordered">
<caption><strong>Таблица 9.1. Часто используемые функции файловой системы С</strong></caption>
<tr><th><em>Имя</em><th><em>Что делает</em>
<tr><td><kbd>fopen()</kbd><td class="t">Открывает файл
<tr><td><kbd>fclose()</kbd><td class="t">Закрывает файл
<tr><td><kbd>putc()</kbd><td class="t">Записывает символ в файл
<tr><td><kbd>fputc()</kbd><td class="t">To же, что и <kbd>putc()</kbd>
<tr><td><kbd>getc()</kbd><td class="t">Читает символ из файла
<tr><td><kbd>fgetc()</kbd><td class="t">To же, что и <kbd>getc()</kbd>
<tr><td><kbd>fgets()</kbd><td class="t">Читает строку из файла
<tr><td><kbd>fputs()</kbd><td class="t">Записывает строку в файл
<tr><td><kbd>fseek()</kbd><td class="t">Устанавливает указатель текущей позиции на определенный байт файла
<tr><td><kbd>ftell()</kbd><td class="t">Возвращает текущее значение указателя текущей позиции в файле
<tr><td><kbd>fprintf()</kbd><td class="t">Для файла то же, что <kbd>printf()</kbd> для консоли
<tr><td><kbd>fscanf()</kbd><td class="t">Для файла то же, что <kbd>scanf()</kbd> для консоли
<tr><td><kbd>feof()</kbd><td class="t">Возвращает значение true (истина), если достигнут конец файла
<tr><td><kbd>ferror()</kbd><td class="t">Возвращает значение true, если произошла ошибка
<tr><td><kbd>rewind()</kbd><td class="t">Устанавливает указатель текущей позиции в начало файла
<tr><td><kbd>remove()</kbd><td class="t">Стирает файл
<tr><td><kbd>fflush()</kbd><td class="t">Дозапись потока в файл
</table>
<p class="tj">Заголовок <kbd>&lt;stdio.h&gt;</kbd> предоставляет прототипы функций ввода/вывода и определяет следующие три типа: <kbd>size_t</kbd>, <kbd>fpos_t</kbd> и <kbd>FILE</kbd>. <kbd>size_t</kbd> и <kbd>fpos_t</kbd> представляют собой определенные разновидности такого типа, как целое без знака. А о третьем типе, <kbd>FILE</kbd>, рассказывается в следующем разделе.
<p class="tj">Кроме того, в <kbd>&lt;stdio.h&gt;</kbd> определяется несколько макросов. Из них к материалу этой главы относятся <kbd>NULL</kbd>, <kbd>EOF</kbd>, <kbd>FOPEN_MAX</kbd>, <kbd>SEEK_SET</kbd>, <kbd>SEEK_CUR</kbd> и <kbd>SEEK_END</kbd>. Макрос <kbd>NULL</kbd> определяет пустой (null) указатель. Макрос <kbd>EOF</kbd>, часто определяемый как -1, является значением, возвращаемым тогда, когда функция ввода пытается выполнить чтение после конца файла. <kbd>FOPEN_MAX</kbd> определяет целое значение, равное максимальному числу одновременно открытых файлов. Другие макросы используются вместе с <kbd>fseek()</kbd> — функцией, выполняющей операции прямого доступа к файлу.
<h2>Указатель файла</h2>
<p class="tj">Указатель файла — это то, что соединяет в единое целое всю систему ввода/вывода языка С. <em>Указатель файла</em> — это указатель на структуру типа <kbd>FILE</kbd>. Он указывает на структуру, содержащую различные сведения о файле, например, его имя, статус и указатель текущей позиции в начало файла. В сущности, указатель файла определяет конкретный файл и используется соответствующим потоком при выполнении функций ввода/вывода. Чтобы выполнять в файлах операции чтения и записи, программы должны использовать указатели соответствующих файлов. Чтобы объявить переменную-указатель файла, используйте такого рода оператор:
<pre>FILE *fp;</pre>
<h2>Открытие файла</h2>
<p class="tj">Функция <kbd>fopen()</kbd> открывает поток и связывает с этим потоком определенный файл. Затем она возвращает указатель этого файла. Чаще всего (а также в оставшейся части этой главы) под файлом подразумевается дисковый файл. Прототип функции <kbd>fopen()</kbd> такой:
<pre>FILE *fopen(const char *<em>имя_файла</em>, const char *<em>режим</em>);</pre>
<p class="t">где <em>имя_файла</em> — это указатель на строку символов, представляющую собой допустимое имя файла, в которое также может входить спецификация пути к этому файлу. Строка, на которую указывает <em>режим</em>, определяет, каким образом файл будет открыт. В табл. 9.2 показано, какие значения строки <em>режим</em> являются допустимыми. Строки, подобные "r+b" могут быть представлены и в виде "rb+".</p>
<table class="table table-bordered">
<caption><strong>Таблица 9.2. Допустимые значения режим</strong></caption>
<tr><th><em>Режим</em><th><em>Что означает</em>
<tr><td>r<td class="t">Открыть текстовый файл для чтения
<tr><td>w<td class="t">Создать текстовый файл для записи
<tr><td>a<td class="t">Добавить в конец текстового файла
<tr><td>rb<td class="t">Открыть двоичный файл для чтения
<tr><td>wb<td class="t">Создать двоичный файл для записи
<tr><td>ab<td class="t">Добавить в конец двоичного файла
<tr><td>r+<td class="t">Открыть текстовый файл для чтения/записи
<tr><td>w+<td class="t">Создать текстовый файл для чтения/записи
<tr><td>a+<td class="t">Добавить  в конец текстового файла или создать текстовый файл для  чтения/записи
<tr><td>r+b<td class="t">Открыть двоичный файл для чтения/записи
<tr><td>w+b<td class="t">Создать двоичный файл для чтения/записи
<tr><td>a+b<td class="t">Добавить в конец двоичного файла или создать двоичный файл для чтения/записи
</table>
<p class="tj">Как уже упоминалось, функция <kbd>fopen()</kbd> возвращает указатель файла. Никогда не следует изменять значение этого указателя в программе. Если при открытии файла происходит ошибка, то <kbd>fopen()</kbd> возвращает пустой (null) указатель.
<p class="tj">В следующем коде функция <kbd>fopen()</kbd> используется для открытия файла по имени TEST для записи.
<pre>
FILE *fp;
fp = fopen("test", "w");
</pre>
<p class="tj">Хотя предыдущий код технически правильный, но его обычно пишут немного по-другому:
<pre>
FILE *fp;
if ((fp = fopen("test","w"))==NULL) {
  printf("Ошибка при открытии файла.\n");
  exit(1);
}
</pre>
<p class="tj">Этот метод помогает при открытии файла обнаружить любую ошибку, например, защиту от записи или полный диск, причем обнаружить еще до того, как программа попытается в этот файл что-либо записать. Вообще говоря, всегда нужно вначале получить подтверждение, что функция - <kbd>fopen()</kbd> выполнилась успешно, и лишь затем выполнять с файлом другие операции.
<p class="tj">Хотя название большинства файловых режимов объясняет их смысл, однако не помешает сделать некоторые дополнения. Если попытаться открыть файл только для чтения, а он не существует, то работа <kbd>fopen()</kbd> завершится отказом. А если попытаться открыть файл в режиме дозаписи, а сам этот файл не существует, то он просто будет создан. Более того, если файл открыт в режиме дозаписи, то все новые данные, которые записываются в него, будут добавляться в конец файла. Содержимое, которое хранилось в нем до открытия (если только оно было), изменено не будет. Далее, если файл открывают для записи, но выясняется, что он не существует, то он будет создан. А если он существует, то содержимое, которое хранилось в нем до открытия, будет утеряно, причем будет создан новый файл. Разница между режимами <kbd>r+</kbd> и <kbd>w+</kbd> состоит в том, что если файл не существует, то в режиме открытия <kbd>r+</kbd> он создан не будет, а в режиме <kbd>w+</kbd> все произойдет наоборот: файл будет создан! Более того, если файл уже существует, то открытие его в режиме <kbd>w+</kbd> приведет к утрате его содержимого, а в режиме <kbd>r+</kbd> оно останется нетронутым.
<p class="tj">Из табл. 9.2 видно, что файл можно открыть либо в одном из текстовых, либо в одном из двоичных режимов. В большинстве реализаций в текстовых режимах каждая комбинация кодов возврата каретки (ASCII 13) и конца строки (ASCII 10) преобразуется при вводе в символ новой строки. При выводе же происходит обратный процесс: символы новой строки преобразуются в комбинацию кодов возврата каретки (ASCII 13) и конца строки (ASCII 10). В двоичных режимах такие преобразования не выполняются.
<p class="tj">Максимальное число одновременно открытых файлов определяется FOPEN_MAX. Это значение не меньше 8, но чему оно точно равняется — это должно быть написано в документации по компилятору.
<h2>Закрытие файла</h2>
<p class="tj">Функция <kbd>fclose()</kbd> закрывает поток, который был открыт с помощью вызова <kbd>fopen()</kbd>.Функция <kbd>fclose()</kbd> записывает в файл все данные, которые еще оставались в дисковом буфере, и проводит, так сказать, официальное закрытие файла на уровне операционной системы. Отказ при закрытии потока влечет всевозможные неприятности, включая потерю данных, испорченные файлы и возможные периодические ошибки в программе. Функция <kbd>fclose()</kbd> также освобождает блок управления файлом, связанный с этим потоком, давая возможность использовать этот блок снова. Так как количество одновременно открытых файлов ограничено, то, возможно, придется закрывать один файл, прежде чем открывать другой. Прототип функции <kbd>fclose()</kbd> такой:
<pre>int fclose(FILE *<em>уф</em>);</pre>
<p class="t">где <em>уф</em> — указатель файла, возвращенный в результате вызова <kbd>fopen()</kbd>. Возвращение нуля означает успешную операцию закрытия. В случае же ошибки возвращается <kbd>EOF</kbd>. Чтобы точно узнать, в чем причина этой ошибки, можно использовать стандартную функцию <kbd>ferror()</kbd> (о которой вскоре пойдет речь). Обычно отказ при выполнении <kbd>fclose()</kbd> происходит только тогда, когда диск был преждевременно удален (стерт) с дисковода или на диске не осталось свободного места.
<h2>Запись символа</h2>
<p class="tj">В системе ввода/вывода языка С определяются две эквивалентные функции, предназначенные для вывода символов: <kbd>putc()</kbd> и <kbd>fputc()</kbd>. (На самом деле <kbd>putc()</kbd> обычно реализуется в виде макроса.) Две идентичные функции имеются просто потому, чтобы сохранять совместимость со старыми версиями С. В этой книге используется <kbd>putc()</kbd>, но применение <kbd>fputc()</kbd> также вполне возможно.
<p class="tj">Функция <kbd>putc()</kbd> записывает символы в файл, который с помощью <kbd>fopen()</kbd> уже открыт в режиме записи. Прототип этой функции следующий:
<pre>int putc(int <em>ch</em>, FILE *<em>уф</em>);</pre>
<p class="t">где <em>уф</em> — это указатель файла, возвращенный функцией <kbd>fopen()</kbd>, a <em>ch</em> — выводимый символ. Указатель файла сообщает <kbd>putc()</kbd>, в какой именно файл следует записывать символ. Хотя <em>ch</em> и определяется как <kbd>int</kbd>, однако записывается только младший байт.
<p class="tj">Если функция <kbd>putc()</kbd> выполнилась успешно, то возвращается записанный символ. В противном же случае возвращается <kbd>EOF</kbd>.
<h2>Чтение символа</h2>
<p class="tj">Для ввода символа также имеются две эквивалентные функции: <kbd>getc()</kbd> и <kbd>fgetc()</kbd>. Обе определяются для сохранения совместимости со старыми версиями С. В этой книге используется <kbd>getc()</kbd> (которая обычно реализуется в виде макроса), но если хотите, применяйте <kbd>fgetc()</kbd>.
<p class="tj">Функция <kbd>getc()</kbd> записывает символы в файл, который с помощью <kbd>fopen()</kbd> уже открыт в режиме для чтения. Прототип этой функции следующий:
<pre>int getc(FILE *<em>уф</em>);</pre>
<p class="t">где <em>уф</em> — это указатель файла, имеющий тип <kbd>FILE</kbd> и возвращенный функцией <kbd>fopen()</kbd>. Функция <kbd>getc()</kbd> возвращает целое значение, но символ находится в младшем байте. Если не произошла ошибка, то старший байт (байты) будет обнулен.
<p class="tj">Если достигнут конец файла, то функция <kbd>getc()</kbd> возвращает <kbd>EOF</kbd>. Поэтому, чтобы прочитать символы до конца текстового файла, можно использовать следующий код;
<pre>
do {
  ch = getc(fp);
} while(ch!=EOF);
</pre>
<p class="tj">Однако <kbd>getc()</kbd> возвращает <kbd>EOF</kbd> и в случае ошибки. Для определения того, что же на самом деле произошло, можно использовать <kbd>ferror()</kbd>.
<h2>Использование fopen(), getc(), putc(), и fclose()</h2>
<p class="tj">Функции <kbd>fopen()</kbd>, <kbd>getc()</kbd>, <kbd>putc()</kbd> и <kbd>fclose()</kbd> — это минимальный набор функций для операций с файлами. Следующая программа, KTOD, представляет собой простой пример, в котором используются только функции <kbd>putc()</kbd>, <kbd>fopen()</kbd> и <kbd>fclose()</kbd>. В этой программе символы считываются с клавиатуры и записываются в дисковый файл до тех пор, пока пользователь не введет знак доллара. Имя файла определяется в командной строке. Например, если вызвать программу KTOD, введя в командной строке <kbd>KTOD TEST</kbd>, то строки текста будут вводиться в файл TEST.
<pre>
/* KTOD: программа ввода с клавиатуры на диск. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(int argc, char *argv[])
{
  FILE *fp;
  char ch;
  if(argc!=2) {
    printf("Вы забыли ввести имя файла.\n");
    exit(1);
  }
  if((fp=fopen(argv[1], "w"))==NULL) {
    printf("Ошибка при открытии файла.\n");
    exit(1);
  }
  do {
    ch = getchar();
    putc(ch, fp);
  } while (ch != '$');
  fclose(fp);
  return 0;
}
</pre>
<p class="tj">Программа DTOS, являющаяся дополнением к программе KTOD, читает любой текстовый файл и выводит его содержимое на экран.
<pre>
/* DTOS: программа, которая читает файлы
         и выводит их на экран. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(int argc, char *argv[])
{
  FILE *fp;
  char ch;
  if(argc!=2) {
    printf("Вы забыли ввести имя файла.\n");
    exit(1);
  }
  if((fp=fopen(argv[1], "r"))==NULL) {
    printf("Ошибка при открытии файла.\n");
    exit(1);
  }
  ch = getc(fp);   /* чтение одного символа */
  while (ch!=EOF) {
    putchar(ch);  /* вывод на экран */
    ch = getc(fp);
  }
  fclose(fp);
  return 0;
}
</pre>
<p class="tj">Испытывая эти две программы, вначале с помошью KTOD создайте текстовый файл, а затем с помошью DTOS прочитайте его содержимое.
<h2>Использование feof()</h2>
<p class="tj">Как уже говорилось, если достигнут конец файла, то <kbd>getc()</kbd> возвращает <kbd>EOF</kbd>. Однако проверка значения, возвращенного <kbd>getc()</kbd>, возможно, не является наилучшим способом узнать, достигнут ли конец файла. Во-первых, файловая система языка С может работать как с текстовыми, так и с двоичными файлами. Когда файл открывается для двоичного ввода, то может быть прочитано целое значение, которое, как выяснится при проверке, равняется <kbd>EOF</kbd>. В таком случае программа ввода сообщит о том, что достигнут конец файла, чего на самом деле может и не быть. Во-вторых, функция <kbd>getc()</kbd> возвращает <kbd>EOF</kbd> и в случае отказа, а не только тогда, когда достигнут конец файла. Если использовать только возвращаемое значение <kbd>getc()</kbd>, то невозможно определить, что же на самом деле произошло. Для решения этой проблемы в С имеется функция <kbd>feof()</kbd>, которая определяет, достигнут ли конец файла. Прототип функции <kbd>feof()</kbd> такой:
<pre>int feof(FILE *<em>уф</em>);</pre>
<p class="tj">Если достигнут конец файла, то <kbd>feof()</kbd> возвращает <em>true</em> (истина); в противном же случае эта функция возвращает нуль. Поэтому следующий код будет читать двоичный файл до тех пор, пока не будет достигнут конец файла:
<pre>while(!feof(fp)) ch = getc(fp);</pre>
<p class="tj">Ясно, что этот метод можно применять как к двоичным, так и к текстовым файлам.
<p class="tj">В следующей программе, которая копирует текстовые или двоичные файлы, имеется пример применения <kbd>feof()</kbd>. Файлы открываются в двоичном режиме, а затем <kbd>feof()</kbd> проверяет, не достигнут ли конец файла.
<pre>
/* Копирование файла. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main(int argc, char *argv[])
{
  FILE *in, *out;
  char ch;
  if(argc!=3) {
    printf("Вы забыли ввести имя файла.\n");
    exit(1);
  }
  if((in=fopen(argv[1], "rb"))==NULL) {
    printf("Нельзя открыть исходный файл.\n");
    exit(1);
  }
  if((out=fopen(argv[2], "wb")) == NULL) {
    printf("Нельзя открыть файл результатов.\n");
    exit(1);
  }
  /* Именно этот код копирует файл. */
  while(!feof(in)) {
    ch = getc(in);
    if(!feof(in)) putc(ch, out);
  }
  fclose(in);
  fclose(out);
  return 0;
}
</pre>
<h2>Ввод / вывод строк: fputs() и fgets()</h2>
<p class="tj">Кроме <kbd>getc()</kbd> и <kbd>putc()</kbd>, в языке С также поддерживаются родственные им функции <kbd>fgets()</kbd> и <kbd>fputs()</kbd>. Первая из них читает строки символов из файла на диске, а вторая записывает строки такого же типа в файл, тоже находящийся на диске. Эти функции работают почти как <kbd>putc()</kbd> и <kbd>getc()</kbd>, но читают и записывают не один символ, а целую строку. Прототипы функций <kbd>fgets()</kbd> и <kbd>fputs()</kbd> следующие:
<pre>
int fputs(const char *<em>cmp</em>, FILE *<em>уф</em>);
char *fgets(char *<em>cmp</em>, int <em>длина</em>, FILE *<em>уф</em>);
</pre>
<p class="tj">Функция <kbd>fputs()</kbd> пишет в определенный поток строку, на которую указывает <em>cmp</em>. В случае ошибки эта функция возвращает <kbd>EOF</kbd>.
<p class="tj">Функция <kbd>fgets()</kbd> читает из определенного потока строку, и делает это до тех пор, пока не будет прочитан символ новой строки или количество прочитанных символов не станет равным <em>длина</em>-1. Если был прочитан разделитель строк, он записывается в строку, чем функция <kbd>fgets()</kbd> отличается от функции <kbd>gets()</kbd>. Полученная в результате строка будет оканчиваться символом конца строки ('0'). При успешном завершении работы функция возвращает <em>cmp</em>, а в случае ошибки — пустой указатель (null).
<p class="tj">В следующей программе показано использование функции <kbd>fputs()</kbd>. Она читает строки с клавиатуры и записывает их в файл, который называется TEST. Чтобы завершить выполнение программы, введите пустую строку. Так как функция <kbd>gets()</kbd> не записывает разделитель строк, то его приходится специально вставлять перед каждой строкой, записываемой в файл; это делается для того, чтобы файл было легче читать:
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int main(void)
{
  char str[80];
  FILE *fp;
  if((fp = fopen("TEST", "w"))==NULL) {
    printf("Ошибка при открытии файла.\n");
    exit(1);
  }
  do {
    printf("Введите строку (пустую - для выхода):\n");
    gets(str);
    strcat(str, "\n");  /* добавление разделителя строк */
    fputs(str, fp);
  } while(*str!='\n');
  return 0;
}
</pre>
<h2>Функция rewind()</h2>
<p class="tj">Функция <kbd>rewind()</kbd> устанавливает указатель текущей позиции в файле на начало файла, указанного в качестве аргумента этой функции. Иными словами, функция <kbd>rewind()</kbd> выполняет "перемотку" (rewind) файла. Вот ее прототип:
<pre>void rewind(FILE *<em>уф</em>);</pre>
<p class="t">где <em>уф</em> — это допустимый указатель файла.
<p class="tj">Чтобы познакомиться с <kbd>rewind()</kbd>, изменим программу из предыдущего раздела таким образом, чтобы она отображала содержимое файла сразу после его создания. Чтобы выполнить отображение, программа после завершения ввода "перематывает" файл, а затем с помощью <kbd>fback()</kbd> читает его с самого начала. Обратите внимание, что сейчас файл необходимо открыть в режиме чтения/записи, используя в качестве аргумента, задающего режим, строку "w+".
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
int main(void)
{
  char str[80];
  FILE *fp;
  if((fp = fopen("TEST", "w+"))==NULL) {
    printf("Ошибка при открытии файла.\n");
    exit(1);
  }
  do {
    printf("Введите строку (пустую - для выхода):\n");
    gets(str);
    strcat(str, "\n");  /* ввод разделителя строк */
    fputs(str, fp);
  } while(*str!='\n');
  /* теперь выполняется чтение и отображение файла */
  rewind(fp);  /* установить указатель
                  текущей позиции на начало файла. */
  while(!feof(fp)) {
    fgets(str, 79, fp);
    printf(str);
  }
  return 0;
}
</pre>
<h2>Функция ferror()</h2>
<p class="tj">Функция <kbd>ferror()</kbd> определяет, произошла ли ошибка во время выполнения операции с файлом. Прототип этой функции следующий:
<pre>int ferror(FILE *<em>уф</em>);</pre>
<p class="t">где <em>уф</em> — допустимый указатель файла. Она возвращает значение <em>true</em> (истина), если при последней операции с файлом произошла ошибка; в противном же случае она возвращает <em>false</em> (ложь). Так как при любой операции с файлом устанавливается свое условие ошибки, то после каждой такой операции следует сразу вызывать <kbd>ferror()</kbd>, а иначе данные об ошибке могут быть потеряны.
<p class="tj">В следующей программе показано применение <kbd>ferror()</kbd>. Программа удаляет табуляции из файла, заменяя их соответствующим количеством пробелов. Размер табуляции определяется макросом <kbd>TAB_SIZE</kbd>. Обратите внимание, что <kbd>ferror()</kbd> вызывается после каждой операции с файлом. При запуске этой программы указывайте в командной строке имена входного и выходного файлов.
<pre>
/* Программа заменяет в текстовом файле символы
   табуляции пробелами и отслеживает ошибки. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define TAB_SIZE 8
#define IN 0
#define OUT 1
void err(int e);
int main(int argc, char *argv[])
{
  FILE *in, *out;
  int tab, i;
  char ch;
  if(argc!=3) {
    printf("Синтаксис: detab &lt;входной_файл&gt; &lt;выходной файл&gt;\n");
    exit(1);
  }
  if((in = fopen(argv[1], "rb"))==NULL) {
    printf("Нельзя открыть %s.\n", argv[1]);
    exit(1);
  }
  if((out = fopen(argv[2], "wb"))==NULL) {
    printf("Нельзя открыть %s.\n", argv[2]);
    exit(1);
  }
  tab = 0;
  do {
    ch = getc(in);
    if(ferror(in)) err(IN);
    /* если найдена табуляция, выводится
       соответствующее число пробелов */
    if(ch=='\t') {
      for(i=tab; i&lt;8; i++) {
        putc(' ', out);
        if(ferror(out)) err(OUT);
      }
      tab = 0;
    }
    else {
      putc(ch, out);
      if(ferror(out)) err(OUT);
      tab++;
      if(tab==TAB_SIZE) tab = 0;
      if(ch=='\n' || ch=='\r') tab = 0;
    }
  } while(!feof(in));
  fclose(in);
  fclose(out);
  return 0;
}
void err(int e)
{
  if(e==IN) printf("Ошибка при вводе.\n");
  else printf("Ошибка привыводе.\n");
  exit(1);
}
</pre>
<h2>Стирание файлов</h2>
<p class="tj">Функция <kbd>remove()</kbd> стирает указанный файл. Вот ее прототип:
<pre>int remove(const char *<em>имя_файла</em>);</pre>
<p class="tj">В случае успешного выполнения эта функция возвращает нуль, а в противном случае — ненулевое значение.
<p class="tj">Следующая программа стирает файл, указанный в командной строке. Однако вначале она дает возможность передумать. Утилита, подобная этой, может пригодиться компьютерным пользователям-новичкам.
<pre>
/* Двойная проверка перед стиранием. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
int main(int argc, char *argv[])
{
  char str[80];
  if(argc!=2) {
    printf("Синтаксис: xerase &lt;имя_файла&gt;\n");
    exit(1);
  }
  printf("Стереть %s? (Y/N): ", argv[1]);
  gets(str);
  if(toupper(*str)=='Y')
    if(remove(argv[1])) {
      printf("Нельзя стиреть файл.\n");
      exit(1);
    }
  return 0;
}
</pre>
<h2>Дозапись потока</h2>
<p class="tj">Для дозаписи содержимого выводного потока в файл применяется функция <kbd>fflush()</kbd>. Вот ее прототип:
<pre>int fflush(FILE *<em>уф</em>);</pre>
<p class="tj">Эта функция записывает все данные, находящиеся в буфере в файл, который указан с помощью <em>уф</em>. При вызове функции <kbd>fflush()</kbd> с пустым (null) указателем файла <em>уф</em> будет выполнена дозапись во все файлы, открытые для вывода.
<p class="tj">После своего успешного выполнения <kbd>fflush()</kbd> возвращает нуль, в противном случае — <kbd>EOF</kbd>.
<p>
</p>
<hr><a href="../main.htm#09">Содержание</a> | <a href="0903.htm">&lt;&lt;&lt;</a> | <a href="0905.htm">&gt;&gt;&gt;</a>
</body>
</html>
