<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Двоичные деревья - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#22">Содержание</a> | <a href="2207.htm">&lt;&lt;&lt;</a> | <a href="../23/23.htm">&gt;&gt;&gt;</a><hr>
<h1>Двоичные деревья</h1>
<p class="tj">Напоследок мы рассмотрим структуру данных, которая называется <em>двоичное дерево</em> (binary tree). Несмотря на то, что бывает много различных типов деревьев, двоичные деревья играют особую роль, так как в отсортированном состоянии позволяют очень быстро выполнять вставку, удаление и поиск. Каждый элемент двоичного дерева состоит из информационной части и указателей на левый и правый элементы. На рис. 22.8 показано небольшое двоичное дерево.</p>
<table class="table">
<caption class="bottom"><p class="tj"><em>Рис. 22.8. Пример двоичного дерева, высота которого равна 3</em>
<tr><td>
<pre>
                                 корень
                               &#8601;
                      +-------+
                      |данные |
                      +---+---+
      левое           |   |   |           правое
     поддерево        +---+---+          поддерево
         &#8600;          &#8601;          &#8600;          &#8601;
           +-------+             +-------+
           |данные |             |данные |
           +---+---+             +---+---+
           |   |   |             | 0 |   |
           +---+---+             +---+---+
         &#8601;          &#8600;                     &#8600;
+-------+             +-------+             +-------+
|данные |             |данные |             |данные |
+---+---+             +---+---+             +---+---+
| 0 | 0 |             | 0 | 0 |             | 0 | 0 |
+---+---+             +---+---+             +---+---+
      &#8593;                   &#8593;                   &#8593;
      '----------------листья-----------------'
</pre>
</table>
<p class="tj">При обсуждении деревьев применяется специальная терминология. Программисты не являются специалистами в области филологии, и поэтому терминология, применяемая в теории графов (а ведь деревья представляют собой частный случай графов!), является классическим примером неправильного употребления слов. Первый элемент дерева называется <em>корнем</em> (root). Каждый элемент данных называется <em>вершиной дерева</em> (node), а любой фрагмент дерева называется <em>поддеревом</em> (subtree). Вершина, к которой не присоединены поддеревья, называется <em>заключительным узлом</em> (terminal node) или <em>листом</em> (leaf). <em>Высота</em> (height) дерева равняется максимальному количеству уровней от корня до листа. При работе с деревьями можно допустить, что в памяти они существуют в том же виде, что и на бумаге. Но помните, что дерево — всего лишь способ логической организации данных в памяти, а память линейна.
<p class="tj">В некотором смысле двоичное дерево является особым видом связанного списка. Элементы можно вставлять, удалять и извлекать в любом порядке. Кроме того, операция извлечения не является разрушающей. Несмотря на то, что деревья легко представить в воображении, в теории программирования с ними связан ряд сложных задач. В данном разделе деревья затрагиваются лишь поверхностно.
<p class="tj">Большинство функций, работающих с деревьями, рекурсивны, поскольку дерево по своей сути является рекурсивной структурой данных. Другими словами, каждое поддерево, в свою очередь, является деревом. Поэтому разрабатываемые здесь функции будут рекурсивными. Существуют и не рекурсивные версии этих функций, но их код понять намного сложнее.
<p class="tj">Способ упорядочивания дерева зависит от того, как к нему впоследствии будет осуществляться доступ. Процесс поочередного доступа к каждой вершине дерева называется <em>обходом (вершин) дерева</em> (tree traversal). Рассмотрим следующее дерево:
<pre>
      d
    &#8601;   &#8600;
   b      f
 &#8601;  &#8600;   &#8601;  &#8600;
a    c  e   g
</pre>
<p class="tj">Существует три порядка обхода дерева: <em>обход симметричным способом</em>, или <em>симметричный обход</em> (inorder), <em>обход в прямом порядке, прямой обход, упорядоченный обход, обход сверху</em>, или <em>обход в ширину</em> (preorder) и обход в <em>обратном порядке, обход в глубину, обратный обход, обход снизу</em> (postorder). При симметричном обходе обрабатывается сначала левое поддерево, затем корень, а затем правое поддерево. При прямом обходе обрабатывается сначала корень, затем левое поддерево, а потом правое. При обходе снизу сначала обрабатывается левое поддерево, затем правое и, наконец корень. Последовательность доступа при каждом методе обхода показана ниже:
<pre>
Симметричный обход       <strong>a b c d e f g</strong>
Прямой обход             <strong>d b a c f e g</strong>
Обход снизу              <strong>a c b e g f d</strong>
</pre>
<p class="tj">Несмотря на то, что дерево не должно быть обязательно упорядоченным, в большинстве задач используются именно такие деревья. Конечно, структура упорядоченного дерева зависит от способа его обхода. В оставшейся части данной главы предполагается симметричный обход. Поэтому упорядоченным двоичным деревом будет считаться такое дерево, в котором левое поддерево содержит вершины, меньшие или равные корню, а правое содержит вершины, большие корня.
<p class="tj">Приведенная ниже функция <kbd>stree()</kbd> создает упорядоченное двоичное дерево:
<pre>
struct tree {
  char info;
  struct tree *left;
  struct tree *right;
};
struct tree *stree(
  struct tree *root,
  struct tree *r,
  char info)
{
  if(!r) {
    r = (struct tree *) malloc(sizeof(struct tree));
    if(!r) {
      printf("Не хватает памяти\n");
      exit(0);
    }
    r->left = NULL;
    r->right = NULL;
    r->info = info;
    if(!root) return r; /* первый вход */
    if(info < root->info) root->left = r;
    else root->right = r;
    return r;
  }
  if(info < r->info)
    stree(r,r->left,info);
  else
    stree(r,r->right,info);
  return root;
}
</pre>
<p class="tj">Приведенный выше алгоритм просто следует по ссылкам дерева, переходя к левой или правой ветви очередной вершины на основании содержимого поля <kbd>info</kbd> до достижения места вставки нового элемента. Чтобы использовать эту функцию, необходимо иметь глобальную переменную-указатель на корень дерева. Этот указатель изначально должен иметь значение нуль (<kbd>NULL</kbd>). При первом вызове функция <kbd>stree()</kbd> возвращает указатель на корень дерева, который нужно присвоить глобальной переменной. При последующих вызовах функция продолжает возвращать указатель на корень. Допустим, что глобальная переменная, содержащая корень дерева, называется <kbd>rt</kbd>. Тогда функция <kbd>stree()</kbd> вызывается следующим образом:
<pre>
/* вызов функции street() */
rt = street(rt, rt, info);
</pre>
<p class="tj">Функция <kbd>stree()</kbd> использует рекурсивный алгоритм, как и большинство процедур работы с деревьями. Точно такая же функция, основанная на итеративных методах, была бы в несколько раз длиннее. Функцию <kbd>stree()</kbd> необходимо вызывать со следующими параметрами (слева направо): указатель на корень всего дерева, указатель на корень следующего поддерева, в котором осуществляется поиск, и сохраняемые данные. При первом вызове оба первых параметрах указывают на корень всего дерева. Для простоты в вершинах дерева хранятся одиночные символы. Тем не менее, вместо них можно использовать любой тип данных.
<p class="tj">Чтобы обойти созданное функцией <kbd>stree()</kbd> дерево в симметричном порядке и распечатать поле <kbd>info</kbd> в каждой вершине, можно применить приведенную ниже функцию <kbd>inorder()</kbd>:
<pre>
void inorder(struct tree *root)
{
  if(!root) return;
  inorder(root->left);
  if(root->info) printf("%c ", root->info);
  inorder(root->right);
}
</pre>
<p class="tj">Данная рекурсивная функция завершает работу тогда, когда находит заключительный узел (нулевой указатель).
<p class="tj">В следующем листинге показаны функции, выполняющие обход дерева в ширину и в глубину.
<pre>
void preorder(struct tree *root)
{
  if(!root) return;
  if(root->info) printf("%c ", root->info);
  preorder(root->left);
  preorder(root->right);
}
void postorder(struct tree *root)
{
  if(!root) return;
  postorder(root->left);
  postorder(root->right);
  if(root->info) printf("%c ", root->info);
}
</pre>
<p class="tj">Теперь давайте рассмотрим короткую, но интересную программу, которая строит упорядоченное двоичное дерево, а затем, обходя его симметричным образом, отображает его на экране боком. Для отображения дерева требуется лишь слегка модифицировать функцию <kbd>inorder()</kbd>. Поскольку на экране дерево распечатывается боком, для корректного отображения правое поддерево необходимо печатать прежде левого. (Технически это противоположность симметричного обхода.) Новая функция называется <kbd>printtree()</kbd>, а ее код показан ниже:
<pre>
void print_tree(struct tree *r, int l)
{
  int i;
  if(r == NULL) return;
  print_tree(r->right, l+1);
  for(i=0; i<l; ++i) printf(" ");
  printf("%c\n", r->info);
  print_tree(r->left, l+1);
}
</pre>
<p class="tj">Далее следует текст всей программы печати дерева. Попробуйте вводить различные деревья, чтобы увидеть, как они строятся.
<pre>
/* Эта программа выводит на экран двоичное дерево. */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
struct tree {
  char info;
  struct tree *left;
  struct tree *right;
};
struct tree *root; /* начальная вершина дерева */
struct tree *stree(struct tree *root,
                   struct tree *r, char info);
void print_tree(struct tree *root, int l);
int main(void)
{
  char s[80];
  root = NULL;  /* инициализация корня дерева */
  do {
    printf("Введите букву: ");
    gets(s);
    root = stree(root, root, *s);
  } while(*s);
  print_tree(root, 0);
  return 0;
}
struct tree *stree(
  struct tree *root,
  struct tree *r,
  char info)
{
  if(!r) {
    r = (struct tree *) malloc(sizeof(struct tree));
    if(!r) {
      printf("Не хватает памяти\n");
      exit(0);
    }
    r->left = NULL;
    r->right = NULL;
    r->info = info;
    if(!root) return r; /* первый вход */
    if(info < root->info) root->left = r;
    else root->right = r;
    return r;
  }
  if(info < r->info)
    stree(r, r->left, info);
  else
    stree(r, r->right, info);
  return root;
}
void print_tree(struct tree *r, int l)
{
  int i;
  if(!r) return;
  print_tree(r->right, l+1);
  for(i=0; i<l; ++i) printf(" ");
  printf("%c\n", r->info);
  print_tree(r->left, l+1);
}
</pre>
<p class="tj">По существу, данная программа сортирует вводимую информацию. Метод сортировки является одной из разновидностей сортировки методом вставок, которая была рассмотрена в предыдущей главе. В среднем случае производительность может быть вполне хорошей.
<p class="tj">Если вы запускали программу печати дерева, вы, вероятно, заметили, что некоторые деревья являются <em>сбалансированными</em> (balanced), т.е. каждое поддерево имеет примерно такую же высоту, как и остальные, а некоторые деревья очень далеки от этого состояния. Например, дерево <strong>a</strong>&#8658;<strong>b</strong>&#8658;<strong>c</strong>&#8658;<strong>d</strong> выглядит следующим образом:
<pre>
a
 &#8600;
   b
    &#8600;
      c
       &#8600;
         d
</pre>
<p class="tj">В этом дереве нет левых поддеревьев. Такое дерево называется <em>вырожденным</em>, поскольку фактически оно выродилось в линейный список. В общем случае, если при построении дерева вводимые данные являются случайными, то получаемое дерево оказывается близким к сбалансированному. Если же информация предварительно отсортирована, создается вырожденное дерево. (Поэтому иногда при каждой вставке дерево корректируют так, чтобы оно было сбалансированным, но этот процесс довольно сложен и выходит за рамки данной главы.)
<p class="tj">В двоичных деревьях легко реализовываются функции поиска. Приведенная ниже функция возвращает указатель на вершину дерева, в которой информация совпадает с ключом поиска, либо нуль (<kbd>NULL</kbd>), если такой вершины нет.
<pre>
struct tree *search_tree(struct tree *root, char key)
{
  if(!root) return root;  /* пустое дерево */
  while(root->info != key) {
    if(key<root->info) root = root->left;
    else root = root->right;
    if(root == NULL) break;
  }
  return root;
}
</pre>
<p class="tj">К сожалению, удалить вершину дерева не так просто, как отыскать. Удаляемая вершина может быть либо корнем, либо левой, либо правой вершиной. Помимо того, к вершине могут быть присоединены поддеревья (количество присоединенных поддеревьев может равняться 0, 1 или 2). Процесс переустановки указателей подсказывает рекурсивный алгоритм, приведенный ниже:
<pre>
struct tree *dtree(struct tree *root, char key)
{
  struct tree *p,*p2;
  if(!root) return root; /* вершина не найдена */
  if(root->info == key) { /* удаление корня */
    /* это означает пустое дерево */
    if(root->left == root->right){
      free(root);
      return NULL;
    }
    /* или если одно из поддеревьев пустое */
    else if(root->left == NULL) {
      p = root->right;
      free(root);
      return p;
    }
    else if(root->right == NULL) {
      p = root->left;
      free(root);
      return p;
    }
    /* или есть оба поддерева */
    else {
      p2 = root->right;
      p = root->right;
      while(p->left) p = p->left;
      p->left = root->left;
      free(root);
      return p2;
    }
  }
  if(root->info < key) root->right = dtree(root->right, key);
  else root->left = dtree(root->left, key);
  return root;
}
</pre>
<p class="tj">Необходимо также следить за правильным обновлением указателя на корень дерева, описанного вне данной функции, поскольку удаляемая вершина может быть корнем. Лучше всего с этой целью указателю на корень присваивать значение, возвращаемое функцией <kbd>dtree()</kbd>:
<pre>root = dtree(root, key);</pre>
<p class="tj">Двоичные деревья — исключительно мощное, гибкое и эффективное средство. Поскольку при поиске в сбалансированном дереве выполняется в худшем случае log<sub>2</sub>n сравнений, оно намного лучше, чем связанный список, в котором возможен лишь последовательный поиск.
<p>
</p>
<hr><a href="../main.htm#22">Содержание</a> | <a href="2207.htm">&lt;&lt;&lt;</a> | <a href="../23/23.htm">&gt;&gt;&gt;</a>


</body>
</html>
