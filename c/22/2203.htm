<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Стеки - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#22">Содержание</a> | <a href="2202.htm">&lt;&lt;&lt;</a> | <a href="2204.htm">&gt;&gt;&gt;</a><hr>
<h1>Стеки</h1>
<p class="tj"><em>Стек</em> (stack) является как бы противоположностью очереди, поскольку он работает по принципу "последним пришел — первым вышел" (last-in, first-out, LIFO)<sup><a href="#11" id="1">[1]</a></sup>. Чтобы наглядно представить себе стек, вспомните стопку тарелок. Первая тарелка, стоящая на столе, будет использована последней, а последняя тарелка, положенная наверх — первой. Стеки часто применяются в системном программном обеспечении, включая компиляторы и интерпретаторы.
<p class="tj">При работе со стеками операции занесения и извлечения элемента являются основными. Данные операции традиционно называются "затолкать в стек" (push)<sup><a href="#22" id="2">[2]</a></sup> и "вытолкнуть из стека" (pop)<sup><a href="#33" id="3">[3]</a></sup>. Поэтому для реализации стека необходимо написать две функции: <kbd>push()</kbd>, которая "заталкивает" значение в стек, и <kbd>pop()</kbd>, которая "выталкивает" значение из стека. Также необходимо выделить область памяти, которая будет использоваться в качестве стека. Для этой цели можно отвести массив или динамически выделить фрагмент памяти с помощью функций языка С, предусмотренных для динамического распределения памяти. Как и в случае очереди, функция извлечения получает из списка элемент и удаляет его, если он не хранится где-либо еше. Ниже приведена общая форма функций <kbd>push()</kbd> и <kbd>pop()</kbd>, работающих с целочисленным массивом. Стеки данных другого типа можно организовывать, изменив базовый тип данных массива.
<pre>
int stack[MAX];
int tos=0;   /* вершина стека */
/* Затолкать элемент в стек. */
void push(int i)
{
  if(tos >= MAX) {
    printf("Стак полон\n");
    return;
  }
  stack[tos] = i;
  tos++;
}
/* Получить верхний элемент стека. */
int pop(void)
{
  tos--;
  if(tos < 0) {
    printf("Стек пуст\n");
    return 0;
  }
  return stack[tos];
}
</pre>
<p class="tj">Переменная <kbd>tos</kbd> ("top of stack" — "вершина стека"<sup><a href="#44" id="4">[4]</a></sup>) содержит индекс вершины стека. При реализации данных функций необходимо учитывать случаи, когда стек заполнен или пуст. В нашем случае признаком пустого стека является равенство <kbd>tos</kbd> нулю, а признаком переполнения стека — такое увеличение <kbd>tos</kbd>, что его значение указывает куда-нибудь за пределы последней ячейки массива. Пример работы стека показан в табл. 22.2.</p>
<table class="table table-bordered">
<caption><strong>Таблица 22.2. Действие стека</strong></caption>
<tr><th><em>Действие</em><th><em>Содержимое стека</em>
<tr><td><kbd>push(A)</kbd><td>A
<tr><td><kbd>push(B)</kbd><td>В А
<tr><td><kbd>push(C)</kbd><td>C B A
<tr><td><kbd>рор()</kbd> извлекает С<td>В А
<tr><td><kbd>push(F)</kbd><td>F В А
<tr><td><kbd>рор()</kbd> извлекает F<td>В А
<tr><td><kbd>рор()</kbd> извлекает В<td>А
<tr><td><kbd>рор()</kbd> извлекает А<td>пусто
</table>
<p class="tj">Прекрасный пример использования стека — калькулятор с четырьмя действиями. Большинство современных калькуляторов воспринимают стандартную запись выражений, называемую <em>инфиксной записью</em><sup><a href="#55" id="5">[5]</a></sup>, общая форма которой выглядит как <em>операнд-оператор-операнд</em>. Например, чтобы сложить 100 и 200, необходимо ввести <kbd>100</kbd>, нажать кнопку "плюс" ("+"), затем ввести <kbd>200</kbd> и нажать кнопку "равно" ("="). Напротив, во многих ранних калькуляторах (и некоторых из производимых сегодня) применяется <em>постфиксная запись</em><sup><a href="#66" id="6">[6]</a></sup>, в которой сначала вводятся оба операнда, а затем оператор. Например, чтобы сложить 100 и 200 в постфиксной записи, необходимо ввести <kbd>100</kbd>, затем <kbd>200</kbd>, а потом нажать клавишу "плюс". В этом методе операнды при вводе заталкиваются в стек. При вводе оператора операнды извлекаются (выталкиваются) из стека, а результат помещается обратно в стек. Одно из преимуществ постфиксной формы заключается в легкости ввода длинных сложных выражений.
<p class="tj">Следующий пример демонстрирует использование стека в программе, реализующей постфиксный калькулятор для целочисленных выражений. Для начала необходимо модифицировать функции <kbd>push()</kbd> и <kbd>pop()</kbd>, как показано ниже. Следует знать, что стек будет размешаться в динамически распределяемой памяти, а не в массиве фиксированного размера. Хотя применение динамического распределения памяти и не требуется в таком простом примере, мы увидим, как использовать динамическую память для хранения данных стека.
<pre>
int *p;   /* указатель на область свободной памяти */
int *tos; /* указатель на вершину стека */
int *bos; /* указатель на дно стека */
/* Занесение элемента в стек. */
void push(int i)
{
  if(p > bos) {
    printf("Стек полон\n");
    return;
  }
  *p = i;
  p++;
}
/* Получение верхнего элемента из стека. */
int pop(void)
{
  p--;
  if(p < tos) {
    printf("Стек пуст\n");
    return 0;
  }
  return *p;
}
</pre>
<p class="tj">Перед использованием этих функций необходимо выделить память из области свободной памяти с помощью функции <kbd>malloc()</kbd> и присвоить переменой <kbd>tos</kbd> адрес начала этой области, а переменной <kbd>bos</kbd> — адрес ее конца.
<p class="tj">Текст программы постфиксного калькулятора целиком приведен ниже.
<pre>
/* Простой калькулятор с четырмя действиями. */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define MAX 100
int *p;   /* указатель на область свободной памяти */
int *tos; /* указатель на вершину стека */
int *bos; /* указатель на дно стека */
void push(int i);
int pop(void);
int main(void)
{
  int a, b;
  char s[80];
  p = (int *) malloc(MAX*sizeof(int)); /* получить память для стека */
  if(!p) {
    printf("Ошибка при выделении памяти\n");
    exit(1);
  }
  tos = p;
  bos = p + MAX-1;
  printf("Калькулятор с четырьмя действиями\n");
  printf("Нажмите 'q' для выхода\n");
  do {
    printf(": ");
    gets(s);
    switch(*s) {
      case '+':
        a = pop();
        b = pop();
        printf("%d\n", a+b);
        push(a+b);
        break;
      case '-':
        a = pop();
        b = pop();
        printf("%d\n", b-a);
        push(b-a);
        break;
      case '*':
        a = pop();
        b = pop();
        printf("%d\n", b*a);
        push(b*a);
        break;
      case '/':
        a = pop();
        b = pop();
        if(a==0) {
          printf("Деление на 0.\n");
          break;
        }
        printf("%d\n", b/a);
        push(b/a);
        break;
      case '.': /* показать содержимое вершины стека */
        a = pop();
        push(a);
        printf("Текущее значение на вершине стека: %d\n", a);
        break;
      default:
        push(atoi(s));
    }
  } while(*s != 'q');
  return 0;
}
/* Занесение элемента в стек. */
void push(int i)
{
  if(p &gt; bos) {
    printf("Стек полон\n");
    return;
  }
  *p = i;
  p++;
}
/* Получение верхнего элемента из стека. */
int pop(void)
{
  p--;
  if(p &lt; tos) {
    printf("Стек пуст\n");
    return 0;
  }
  return *p;
}
</pre>
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Иными словами, в <em>магазинном порядке</em>.
<p class="tj"><sup><a href="#2" id="22">[2]</a></sup>А также: <em>проталкивать (в стек), помещать на стек, класть в стек, поместить в стек, положить в стек, сохранить в стеке</em>.
<p class="tj"><sup><a href="#3" id="33">[3]</a></sup>А также: <em>выталкивать данные из стека, выталкивание из стека, выталкивание данных из стека, снимать со стека, вынимать из стека, считывать из стека, вытаскивать из стека</em>.
<p class="tj"><sup><a href="#4" id="44">[4]</a></sup>Называется также <em>верхушкой</em>.
<p class="tj"><sup><a href="#5" id="55">[5]</a></sup>Другие названия: <em>инфиксное представление, инфиксная нотация</em>.
<p class="tj"><sup><a href="#6" id="66">[6]</a></sup>Другие названия: <em>постфиксная нотация, польская инверсная запись</em>.
</blockquote>
<hr><a href="../main.htm#22">Содержание</a> | <a href="2202.htm">&lt;&lt;&lt;</a> | <a href="2204.htm">&gt;&gt;&gt;</a>


</body>
</html>
