<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Очереди - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#22">Содержание</a> | <a href="22.htm">&lt;&lt;&lt;</a> | <a href="2202.htm">&gt;&gt;&gt;</a><hr>
<h1>Очереди</h1>
<p class="tj">Очередь — это линейный список информации, работа с которой происходит по принципу "первым пришел — первым вышел" (first-in, first-out); этот принцип (и очередь как структура данных) иногда еще называется FIFO<sup><a href="#11" id="1">[1]</a></sup>. Это значит, что первый помещенный в очередь элемент будет получен из нее первым, второй помещенный элемент будет извлечен вторым и т.д. Это единственный способ работы с очередью; произвольный доступ к отдельным элементам не разрешается.
<p class="tj">Очереди очень часто встречаются в реальной жизни, например, около банков или ресторанов быстрого обслуживания. Чтобы представить себе работу очереди, давайте введем две функции: <kbd>qstore()</kbd> и <kbd>qretrieve()</kbd> (от "store"— "сохранять", "retrieve" — "получать"). Функция <kbd>qstore()</kbd> помещает элемент в конец очереди, а функция <kbd>qretrieve()</kbd> удаляет элемент из начала очереди и возвращает его значение. В табл. 22.1 показано действие последовательности таких операций.</p>
<table class="table table-bordered">
<caption><strong>Таблица 22.1. Работа очереди</strong></caption>
<tr><th><em>Действие</em><th><em>Содержимое очереди</em>
<tr><td><kbd>qstore(A)</kbd><td>A
<tr><td><kbd>qstore(B)</kbd><td>А В
<tr><td><kbd>qstore(C)</kbd><td>A B C
<tr><td><kbd>qretrieve()</kbd> возвращает А<td>В С
<tr><td><kbd>qstore(D)</kbd><td>B C D
<tr><td><kbd>qretrieve()</kbd> возвращает В<td>C D
<tr><td><kbd>qretrieve()</kbd> возвращает С<td>D
</table>
<p class="tj">Следует иметь в виду, что операция извлечения удаляет элемент из очереди и уничтожает его, если он не хранится где-нибудь в другом месте. Поэтому после извлечения всех элементов очередь будет пуста.
<p class="tj">В программировании очереди применяются при решении многих задач. Один из наиболее популярных видов таких задач — симуляция. Очереди также применяются в планировщиках задач операционных систем и при буферизации ввода/вывода.
<p class="tj">Чтобы проиллюстрировать работу очереди, мы напишем простую программу планирования встреч. Эта программа позволяет сохранять информацию о некотором количестве встреч; потом по мере прохождения каждой встречи она удаляется из списка. Для упрощения описание встреч ограничено 255 символами, а количество встреч — произвольным числом 100.
<p class="tj">При разработке этой простой программы планирования необходимо прежде всего реализовать описанные здесь функции <kbd>qstore()</kbd> и <kbd>qretrieve()</kbd>. Они будут хранить указатели на строки, содержащие описания встреч.
<pre>
#define MAX 100
char *p[MAX];
int spos = 0;
int rpos = 0;
/* Сохранение встречи. */
void qstore(char *q)
{
  if(spos==MAX) {
    printf("Список переполнен\n");
    return;
  }
  p[spos] = q;
  spos++;
}
/* Получение встречи. */
char *qretrieve()
{
  if(rpos==spos) {
    printf("Встреч больше нет.\n");
    return '\0';
  }
  rpos++;
  return p[rpos-1];
}
</pre>
<p class="tj">Обратите внимание, что этим двум функциям требуются две глобальные переменные: <kbd>spos</kbd>, в которой хранится индекс следующего свободного места в списке, и <kbd>rpos</kbd>, в которой хранится индекс следующего элемента, подлежащего выборке. С помощью этих функций можно организовать очередь данных другого типа, просто поменяв базовый тип обрабатываемого ими массива.
<p class="tj">Функция <kbd>qstore()</kbd> помещает описания новых встреч в конец списка и проверяет, не переполнен ли список. Функция <kbd>qretrieve()</kbd> извлекает встречи из очереди, если таковые имеются. При назначении встреч увеличивается значение переменной <kbd>spos</kbd>, а по мере их прохождения увеличивается значение переменной <kbd>rpos</kbd>. По существу, <kbd>rpos</kbd> "догоняет" <kbd>spos</kbd> в очереди. На рис 22.1 показано, что может происходить в памяти при выполнении программы. Если <kbd>rpos</kbd> и <kbd>spos</kbd> равны, назначенные события отсутствуют. Даже несмотря на то, что функция <kbd>qretrieve()</kbd> не уничтожает хранящуюся в очереди информацию физически, эту информацию можно считать уничтоженной, так как повторно получить доступ к ней невозможно.</p>
<table class="table">
<caption class="bottom"><p class="tj"><em>Рис. 22.1. Индекс выборки "догоняет" индекс вставки</em>
<tr><td>
<pre>
	<strong>Начальное сосотояние очереди</strong>
  &#8595;spos
+---+---+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+
  &#8593;rpos
	<strong>qstore('A')</strong>
      &#8595;spos
+---+---+---+---+---+---+---+---+---+---+---+
| A |   |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+
  &#8593;rpos
	<strong>qstore('B')</strong>
          &#8595;spos
+---+---+---+---+---+---+---+---+---+---+---+
| A | B |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+
  &#8593;rpos
	<strong>qretrive()</strong>
          &#8595;spos
+---+---+---+---+---+---+---+---+---+---+---+
|   | B |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+
      &#8593;rpos
	<strong>qretrive()</strong>
          &#8595;spos
+---+---+---+---+---+---+---+---+---+---+---+
|   |   |   |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+
          &#8593;rpos
	<strong>qstore('A')</strong>
              &#8595;spos
+---+---+---+---+---+---+---+---+---+---+---+
|   |   | C |   |   |   |   |   |   |   |   |
+---+---+---+---+---+---+---+---+---+---+---+
          &#8593;rpos
</pre>
</table>
<p class="tj">Текст программы простого планировщика встреч целиком приведен ниже. Вы можете доработать эту программу по своему усмотрению.
<pre>
/* Мини-планировщик событий */
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;
#define MAX 100
char *p[MAX], *qretrieve(void);
int spos = 0;
int rpos = 0;
void enter(void), qstore(char *q), review(void), delete_ap(void);
int main(void)
{
  char s[80];
  register int t;
  for(t=0; t &lt; MAX; ++t) p[t] = NULL; /* иницилизировать массив
                                         пустыми указателями */
  for(;;) {
    printf("Ввести (E), Список (L), Удалить (R), Выход (Q): ");
    gets(s);
    *s = toupper(*s);
    switch(*s) {
      case 'E':
        enter();
        break;
      case 'L':
        review();
        break;
      case 'R':
        delete_ap();
        break;
      case 'Q':
        exit(0);
    }
  }
  return 0;
}
/* Вставка в очередь новой встречи. */
void enter(void)
{
  char s[256], *p;
  do {
    printf("Введите встречу %d: ", spos+1);
    gets(s);
    if(*s==0) break; /* запись не была произведена */
    p = (char *) malloc(strlen(s)+1);
    if(!p) {
      printf("Не хватает памяти.\n");
      return;
    }
    strcpy(p, s);
    if(*s) qstore(p);
  } while(*s);
}
/* Просмотр содержимого очереди. */
void review(void)
{
  register int t;
  for(t=rpos; t &lt; spos; ++t)
    printf("%d. %s\n", t+1, p[t]);
}
/* Удаление встречи из очереди. */
void delete_ap(void)
{
  char *p;
  if((p=qretrieve())==NULL) return;
  printf("%s\n", p);
}
/* Вставка встречи. */
void qstore(char *q)
{
  if(spos==MAX) {
    printf("List Full\n");
    return;
  }
  p[spos] = q;
  spos++;
}
/* Извлечение встречи. */
char *qretrieve(void)
{
  if(rpos==spos) {
    printf("Встречь больше нет.\n");
    return NULL;
  }
  rpos++;
  return p[rpos-1];
}
</pre>
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Этот принцип имеет и другие названия: <em>"первым пришел — первым обслужен", "в порядке поступления", "первым пришел — первым вышел", "обратного магазинного типа".</em>
</blockquote>
<p>
</p>
<hr><a href="../main.htm#22">Содержание</a> | <a href="22.htm">&lt;&lt;&lt;</a> | <a href="2202.htm">&gt;&gt;&gt;</a>


</body>
</html>
