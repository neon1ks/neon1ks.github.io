<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Директива #define - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head><body>
<a href="../main.htm#10">Содержание</a> | <a href="1001.htm">&lt;&lt;&lt;</a> | <a href="1003.htm">&gt;&gt;&gt;</a><hr>
<h1>Директива #define</h1>
<p class="tj">Директива <kbd>#define</kbd> определяет идентификатор и последовательность символов, которая будет подставляться вместо идентификатора каждый раз, когда он встретится в исходном файле. Идентификатор называется <em>именем макроса</em>, а сам процесс замены — <em>макрозаменой</em><sup><a href="#11" id="1">[1]</a></sup>. В общем виде директива выглядит таким образом:
<pre>#define <em>имя_макроса последовательность_символов</em></pre>
<p class="tj">Обратите внимание, что в этом выражении нет точки с запятой. Между идентификатором и последовательностью символов <em>последовательность_символов</em> может быть любое количество пробелов, но признаком конца последовательности символов может быть только разделитель строк.
<p class="tj">Предположим, например, что вместо значения 1 нужно использовать слово <kbd>LEFT</kbd> (левый), а вместо значения 0 — слово <kbd>RIGHT</kbd> (правый). Тогда можно сделать следующие объявления с помощью директивы <kbd>#define</kbd>:
<pre>
#define LEFT 1
#define RIGHT 0
</pre>
<p class="tj">В результате компилятор будет подставлять 1 или 0 каждый раз, когда в вашем файле исходного кода встречается идентификатор соответственно LEFT или RIGHT. Например, следующий код выводит на экран 0 1 2:
<pre>printf("%d %d %d", RIGHT, LEFT, LEFT+1);</pre>
<p class="tj">После определения имя макроса можно использовать в определениях других имен макросов. Вот, например, код, определяющий значения ONE (один), TWO (два) и three (три):
<pre>
#define ONE    1
#define TWO    ONE+ONE
#define THREE  ONE+TWO
</pre>
<p class="tj">Макроподстановка — это просто замена какого-либо идентификатора связанной с ним последовательностью символов. Поэтому если требуется определить стандартное сообщение об ошибке, то можно написать примерно следующее:
<pre>
#define E_MS "стандартная ошибка при вводе\n"
/* ... */
printf(E_MS);
</pre>
<p class="tj">Теперь каждый раз, когда встретится идентификатор <kbd>E_MS</kbd>, компилятор будет его заменять строкой "стандартная ошибка при вводе\n". Для компилятора выражение <kbd>printf()</kbd> на самом деле будет выглядеть таким образом:
<pre>
printf("стандартная ошибка при вводе\n");
</pre>
<p class="tj">Если идентификатор находится внутри строки, заключенной в кавычки, то замены не будет. Например, при выполнении кода
<pre>
#define XYZ это проверка
printf("XYZ");
</pre>
<p class="t">вместо сообщения <kbd>это проверка</kbd> будет выводиться последовательность символов <kbd>XYZ</kbd>.
<p class="tj">Если <em>последовательность_символов</em> не помещается в одной строке, то эту последовательность можно продолжить на следующей строке, поместив в конце предыдущей, как показано ниже, обратную косую черту:
<pre>
#define LONG_STRING "это очень длинная \
строка, используемая в качестве примера"
</pre>
<p class="tj">Программисты, пишущие программы на языке С, в именах определяемых идентификаторов часто используют буквы верхнего регистра. Если разработчики программ следуют этому правилу, то тот, кто будет читать их программу, с первого взгляда поймет, что будет происходить макрозамена. Кроме того, все директивы <kbd>#define</kbd> обычно лучше всего помещать в самом начале файла или в отдельном заголовочном файле, а не разбрасывать по всей программе.
<p class="tj">Имена макросов часто используются для определения имен так называемых "магических чисел" (встречающихся в программе). Например, имеется программа, в которой определяется массив и несколько процедур, получающих доступ к этому массиву. Вместо того чтобы размер массива "зашивать в код" в виде константы, этот размер можно определить с помощью оператора <kbd>#define</kbd>, а затем использовать это имя макроса везде, где требуется размер массива. Таким образом, если требуется изменить этот размер, то потребуется изменить только соответствующий оператор <kbd>#define</kbd>, a затем перекомпилировать программу. Рассмотрим, например, фрагмент программы
<pre>
#define MAX_SIZE 100
/* ... */
float balance[MAX_SIZE];
/* ... */
for(i=0; i&lt;MAX_SIZE; i++) printf("%f", balance[i]);
/* ... */
for(i=0; i&lt;MAX_SIZE; i++) x =+ balance[i];
</pre>
<p class="tj">Размер массива <kbd>balance</kbd> определяется именем макроса <kbd>MAX_SIZE</kbd>, и поэтому если этот размер потребуется в будущем изменить, то надо будет изменить только определение <kbd>MAX_SIZE</kbd>. В результате при перекомпиляции программы все обращения к этому имени макроса, находящиеся после измененного определения, будут автоматически изменены.
<h2>Определение макросов с формальными параметрами</h2>
<p class="tj">У директивы <kbd>#define</kbd> имеется еще одно большое достоинство: имя макроса может определяться с формальными параметрами. Тогда каждый раз, когда в программе встречается имя макроса, то используемые в его определении формальные параметры заменяются теми аргументами, которые встретились в программе. Такого рода макросы называются <em>макросами с формальными параметрами</em><sup><a href="#22" id="2">[2]</a></sup>. Например,
<pre>
#include &lt;stdio.h&gt;
#define ABS(a)  (a) &lt; 0 ? -(a) : (a)
int main(void)
{
  printf("модули чисел -1 и 1 равны соответственно %d и %d",
         ABS(-1), ABS(1));
  return 0;
}
</pre>
<p class="tj">Во время компиляции этой программы вместо формального параметра <kbd>а</kbd> из определения макроса будут подставляться значения -1 и 1. Скобки, в которых находится <kbd>а</kbd>, позволяют в любом случае сделать правильную замену. Например, если скобки, стоящие вокруг <kbd>а</kbd>, удалить, то выражение
<pre>ABS(10-20)</pre>
<p class="t">после макрозамены будет преобразовано в
<pre>10-20 &lt; 0 ? -10-20 : 10-20</pre>
<p class="t">и может привести к неправильному результату.
<p class="tj">Использование вместо настоящих функций макросов с формальными параметрами дает одно существенное преимущество: увеличивается скорость выполнения кода, потому что в таких случаях не надо тратить ресурсы на вызов функций. Однако если у макроса с формальными параметрами очень большие размеры, то тогда из-за дублирования кода увеличение скорости достигается за счет увеличения размеров программы.
<p class="tj">И вот еще что: хотя макросы с формальными параметрами являются полезным средством, но в С99 (и в C++) есть еще более эффективный способ создания машинной программы — с использованием ключевого слово <kbd>inline</kbd>.</p>
<table class="table table-bordered">
<tr><td class="tdnote">На заметку<td class="tj">В С99 можно определить макрос с переменным количеством формальных параметров; об этом рассказывается в <a href="../II.htm">части II</a> этой книги.
</table>
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>А также <em>макрорасширением</em>, <em>макрогенерацией</em> и <em>макроподстановкой</em>. Определение макроса часто называют <em>макроопределением</em>, а обращение к макросу — <em>макровызовом</em> или <em>макрокомандой</em>. Впрочем, иногда макроопределение также называется макрокомандой.
<p class="tj"><sup><a href="#2" id="22">[2]</a></sup>А также <em>макроопределениями с параметрами</em> и <em>макросами, напоминающими функции</em>.
</blockquote>
<p>
</p>
<hr><a href="../main.htm#10">Содержание</a> | <a href="1001.htm">&lt;&lt;&lt;</a> | <a href="1003.htm">&gt;&gt;&gt;</a>
</body>
</html>
