<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Поиск - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head><body>
<a href="../main.htm#21">Содержание</a> | <a href="2110.htm">&lt;&lt;&lt;</a> | <a href="../22/22.htm">&gt;&gt;&gt;</a><hr>
<h1>Поиск</h1>
<p class="tj">Базы данных существуют для того, чтобы время от времени пользователи могли найти нужную запись, введя ее ключ. Существует один метод поиска информации в неупорядоченном массиве, и другой для поиска в упорядоченном массиве. В набор стандартной библиотеки компиляторов языка С входит стандартная функция <kbd>bsearch()</kbd>. Тем не менее, как и в случае сортировки, процедуры общего назначения иногда совсем не эффективны при использовании в критических ситуациях из-за накладных расходов, связанных с их обобщением. Кроме того, функцию <kbd>bsearch()</kbd> невозможно применить к неупорядоченным данным.
<h2>Методы поиска</h2>
<p class="tj">Для нахождения информации в неупорядоченном массиве требуется последовательный поиск, начинающийся с первого элемента и заканчивающийся при обнаружении подходящих данных либо при достижении конца массива. Этот метод применим для неупорядоченной информации, но также можно использовать его и на отсортированных данных. Однако если данные уже отсортированы, можно применить двоичный поиск, который находит данные быстрее.
<h2>Последовательный поиск</h2>
<p class="tj">Последовательный поиск очень легко запрограммировать. Приведенная ниже функция осуществляет поиск в массиве символов известной длины, пока не будет найден элемент с заданным ключом:
<pre>
/* Последовательный поиск */
int sequential_search(char *items, int count, char key)
{
  register int t;
  for(t=0; t &lt; count; ++t)
    if(key == items[t]) return t;
  return -1; /* ключ не найден */
}
</pre>
<p class="tj">Здесь <kbd>items</kbd> — указатель на массив, содержащий информацию. Функция возвращает индекс подходящего элемента, если таковой существует, либо -1 в противном случае.
<p class="tj">Понятно, что последовательный поиск в среднем просматривает <em>n/2</em> элементов. В лучшем случае он проверяет только один элемент, а в худшем — <em>n</em>. Если информация хранится на диске, поиск может занимать продолжительное время. Но если данные не упорядочены, последовательный поиск — единственно возможный метод.
<h2>Двоичный поиск</h2>
<p class="tj">Если данные, в которых производится поиск, отсортированы, для нахождения элемента можно применять метод, намного превосходящий предыдущий — <em>двоичный поиск</em><sup><a href="#11" id="1">[1]</a></sup>. В нем применяется метод половинного деления. Сначала проверим средний элемент. Если он больше, чем искомый ключ, проверим средний элемент первой половины, в противном случае — средний элемент второй половины. Будем повторять эту процедуру до тех пор, пока искомый элемент не будет найден либо пока не останется очередного элемента.
<p class="tj">Например, чтобы найти число 4 в массиве
<p class="t">1 2 3 4 5 6 7 8 9
<p class="t">при двоичном поиске сначала проверяется средний элемент — число 5. Поскольку оно больше, чем 4, поиск продолжается в первой половине:
<p class="t">1 2 3 4 5
<p class="t">Средний элемент теперь равен 3. Это меньше, чем 4, поэтому первая половина отбрасывается. Поиск продолжается в части
<p class="t">4 5
<p class="t">На этот раз искомый элемент найден.
<p class="t">В двоичном поиске количество сравнений в худшем случае равно
<p class="t">log<sub>2</sub><em>n</em>
<p class="t">В среднем случае количество немного ниже, а в лучшем — количество сравнений равно 1.
<p class="tj">Ниже приведена функция двоичного поиска для массивов символов. Этот поиск можно адаптировать для произвольных структур данных, изменив фрагмент сравнения.
<pre>
/* Двоичный поиск */
int binary_search(char *items, int count, char key)
{
  int low, high, mid;
  low = 0; high = count-1;
  while(low &lt;= high) {
    mid = (low+high)/2;
    if(key &lt; items[mid]) high = mid-1;
    else if(key &gt; items[mid]) low = mid+1;
    else return mid; /* ключ найден */
  }
  return -1;
}
</pre>
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Есть и другие названия: <em>дихотомический поиск</em>, <em>логарифмический поиск</em>, <em>поиск делением пополам</em>. Этот метод поиска данных состоит в том, что все множество данных делится пополам и определяется, в какой из половин находится искомое данное, после чего половина, в которой находится данное, в свою очередь делится пополам и т.д. Процесс продолжается до тех пор, пока очередное полученное множество не станет равным единственному данному, которое будет искомым, либо будет установлен факт отсутствия искомого данного в этом множестве.
</blockquote>
<p>
</p>
<hr><a href="../main.htm#21">Содержание</a> | <a href="2110.htm">&lt;&lt;&lt;</a> | <a href="../22/22.htm">&gt;&gt;&gt;</a>
</body>
</html>
