<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Сортировка других структур данных - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#21">Содержание</a> | <a href="2108.htm">&lt;&lt;&lt;</a> | <a href="2110.htm">&gt;&gt;&gt;</a><hr>
<h1>Сортировка других структур данных</h1>
<p class="tj">До сих пор мы сортировали только массивы символов. Очевидно, что приведенные выше функции можно переделать для сортировки массивов любого из встроенных типов данных, просто поменяв типы параметров и переменных. Тем не менее, обычно возникает необходимость сортировать составные типы данных, например строки, или агрегированные данные, например структуры. Большинство задач сортировки имеют дело с ключом и информацией, связанной с этим ключом. Чтобы адаптировать алгоритмы для обработки подобных данных, необходимо модифицировать код сравнения, код обмена или оба фрагмента. Сам алгоритм при этом не меняется.
<p class="tj">Поскольку быстрая сортировка в настоящее время является одним из лучших методов сортировки общего назначения, она используется в последующих примерах. Тем не менее, тот же принцип относится и ко всем остальным методам, описанным ранее.
<h2>Сортировка строк</h2>
<p class="tj">Сортировка строк является распространенной задачей программирования. Строки легче всего сортировать, когда они хранятся в таблице строк. Таблица строк — это просто массив строк. А массив строк — это двумерный массив символов, в котором количество строк в таблице определяется размером левого измерения, а максимальная длина строки — размером правого измерения. (О массивах строк рассказывалось в <a href="../04/04.htm">главе 4</a>.) Нижеследующая строковая версия быстрой сортировки принимает массив строк, в котором размер каждой строки ограничен десятью символами. (Можете изменить эту длину, если хотите.) Данная версия сортирует строки в лексикографическом порядке.
<pre>
/* Быстрая сортировка строк. */
void quick_string(char items[][10], int count)
{
  qs_string(items, 0, count-1);
}
void qs_string(char items[][10], int left, int right)
{
  register int i, j;
  char *x;
  char temp[10];
  i = left; j = right;
  x = items[(left+right)/2];
  do {
    while((strcmp(items[i],x) &lt; 0) && (i &lt; right)) i++;
    while((strcmp(items[j],x) &gt; 0) && (j &gt; left)) j--;
    if(i &lt;= j) {
      strcpy(temp, items[i]);
      strcpy(items[i], items[j]);
      strcpy(items[j], temp);
      i++; j--;
   }
  } while(i &lt;= j);
  if(left &lt; j) qs_string(items, left, j);
  if(i &lt; right) qs_string(items, i, right);
}
</pre>
<p class="tj">Обратите внимание, что во фрагменте сравнения теперь используется функция <kbd>strcmp()</kbd>. Эта функция возвращает отрицательное число, если первая строка лексикографически меньше второй, возвращает ноль, если строки равны, и положительное число, если первая строка лексикографически больше второй. Также следует отметить, что для обмена двух строк требуется три вызова функции <kbd>strcpy()</kbd>.
<p class="tj">Имейте в виду, что функция <kbd>strcmp()</kbd> замедляет сортировку по двум причинам. Во-первых, в программе появляется вызов функции, что всегда отнимает время. Во-вторых, сама функция <kbd>strcmp()</kbd> выполняет несколько сравнений, чтобы определить, какая из двух строк больше. В первом случае, если скорость очень важна, можно поместить код сравнения строк непосредственно в функцию сортировки, продублировав код функции <kbd>strcmp()</kbd>. Во втором случае нет никакого способа избежать сравнения строк, поскольку по определению это именно то, что требуется в данной задаче. Те же рассуждения относятся и к функции <kbd>strcpy()</kbd>. Обмен двух строк с помощью <kbd>strcpy()</kbd> включает в себя вызов функции и посимвольный обмен содержимого строк — каждая из этих операций занимает время. Накладные расходы на вызов функции можно устранить, вставив код копирования прямо в алгоритм сортировки. Однако тот факт, что обмен двух строк означает обмен отдельных символов (один за другим), изменить невозможно.
<p class="tj">Ниже приведена простая функция <kbd>main()</kbd>, демонстрирующая работу функции быстрой сортировки строк <kbd>quick_string()</kbd>:
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void quick_string(char items[][10], int count);
void qs_string(char items[][10], int left, int right);
char str[][10] = { "один",
                   "два",
                   "три",
                   "четыре"
                 };
int main(void)
{
  int i;
  quick_string(str, 4);
  for(i=0; i&lt;4; i++) printf("%s ", str[i]);
  return 0;
}
</pre>
<h2>Сортировка структур</h2>
<p class="tj">В большинстве прикладных программ, в которых используется сортировка, предусмотрена сортировка совокупностей данных. Например, списки почтовой рассыпки, складские базы данных и журналы сотрудников содержат наборы разнотипных данных. Как вам известно, в программах на языке С совокупности данных обычно хранятся в структурах. Хотя структура обычно содержит несколько членов, структуры, как правило, сортируются только по одному полю-члену, который используется в качестве ключа сортировки. За исключением выбора ключа, приемы сортировки структур ничем не отличаются от приемов сортировки других типов данных.
<p class="tj">Чтобы проиллюстрировать пример сортировки структур, давайте создадим структуру под называнием <kbd>address</kbd>, в которой можно хранить почтовый адрес. Подобная структура может применяться в программе почтовой рассылки. Описание структуры <kbd>address</kbd> показано ниже:
<pre>
struct address {
  char name[40];   /* имя */
  char street[40]; /* улица */
  char city[20];   /* город */
  char state[3];   /* штат */
  char zip[11];    /* индекс */
};
</pre>
<p class="tj">Поскольку представляется разумным организовать список адресов в виде массива структур, в данном примере предположим, что процедура сортировки будет сортировать массив структур типа <kbd>address</kbd>. Такая процедура показана ниже. Она сортирует адреса по почтовому индексу.
<pre>
/* Быстрая сортировка структур типа фвкуыы. */
void quick_struct(struct address items[], int count)
{
  qs_struct(items,0,count-1);
}
void qs_struct(struct address items[], int left, int right)
{
  register int i, j;
  char *x;
  struct address temp;
  i = left; j = right;
  x = items[(left+right)/2].zip;
  do {
    while((strcmp(items[i].zip,x) &lt; 0) && (i &lt; right)) i++;
    while((strcmp(items[j].zip,x) &gt; 0) && (j &gt; left)) j--;
    if(i &lt;= j) {
      temp = items[i];
      items[i] = items[j];
      items[j] = temp;
      i++; j--;
    }
  } while(i &lt;= j);
  if(left &lt; j) qs_struct(items, left, j);
  if(i &lt; right) qs_struct(items, i, right);
}
</pre>
<hr><a href="../main.htm#21">Содержание</a> | <a href="2108.htm">&lt;&lt;&lt;</a> | <a href="2110.htm">&gt;&gt;&gt;</a>


</body>
</html>
