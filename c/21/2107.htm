<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Улучшенные алгоритмы сортировки - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head><body>
<a href="../main.htm#21">Содержание</a> | <a href="2106.htm">&lt;&lt;&lt;</a> | <a href="2108.htm">&gt;&gt;&gt;</a><hr>
<h1>Улучшенные алгоритмы сортировки</h1>
<p class="tj">Все алгоритмы, рассмотренные в предыдущих разделах, имеют один фатальный недостаток — время их выполнения имеет порядок <em>n</em><sup>2</sup>. Это делает сортировку больших объемов данных очень медленной. По существу, в какой-то момент эти алгоритмы становятся слишком медленными, чтобы их применять<sup><a href="#11" id="1">[1]</a></sup>. К сожалению, страшные истории о "сортировках, которые продолжались три дня", зачастую реальны. Когда сортировка занимает слишком много времени, причиной этому обычно является неэффективность использованного в ней алгоритма. Тем не менее, первой реакцией в такой ситуации часто становится оптимизация кода вручную, возможно, путем переписывания его на ассемблере. Несмотря на то, что ручная оптимизация иногда ускоряет процедуру на постоянный множитель<sup><a href="#22" id="2">[2]</a></sup>, если алгоритм сортировки не эффективен, сортировка всегда будет медленной независимо от того, насколько оптимально написан код. Следует помнить, если время работы процедуры пропорционально <em>n</em><sup>2</sup>, то увеличение скорости кода или компьютера даст лишь небольшое улучшение<sup><a href="#33" id="3">[3]</a></sup>, поскольку время выполнения увеличивается как <em>n</em><sup>2</sup>. (На самом деле, кривая <em>n</em><sup>2</sup> на рис. 21.1 (пузырьковая сортировка) растянута вправо, но в остальном соответствует действительности.) Существует правило: если используемый в программе алгоритм слишком медленный сам по себе, никакой объем ручной оптимизации не сделает программу достаточно быстрой. Решение заключается в применении лучшего алгоритма сортировки.
<p class="tj">Ниже описаны два прекрасных метода сортировки. Первый называется <em>сортировкой Шелла</em>. Второй — <em>быстрая сортировка</em> — обычно считается самым лучшим алгоритмом сортировки. Оба метода являются более совершенными способами сортировки и имеют намного лучшую общую производительность, чем любой из приведенных выше простых методов.
<h2>Сортировка Шелла</h2>
<p class="tj">Сортировка Шелла называется так по имени своего автора, Дональда Л. Шелла (Donald Lewis Shell)<sup><a href="#44" id="4">[4]</a></sup>. Однако это название закрепилось, вероятно, также потому, что действие этого метода часто иллюстрируется рядами морских раковин, перекрывающих друг друга (по-английски "shell" — "раковина"). Общая идея заимствована из сортировки вставками и основывается на уменьшении шагов<sup><a href="#55" id="5">[5]</a></sup>. Рассмотрим диаграмму на рис. 21.2. Сначала сортируются все элементы, отстоящие друг от друга на три позиции. Затем сортируются элементы, расположенные на расстоянии двух позиций. Наконец, сортируются все соседние элементы.</p>
<table class="table">
<caption class="bottom"><p class="tj"><em>Рис. 21.2. Сортировка Шелла</em>
<tr><td>
<pre>
Проход 1     f   d   a   c   b   e
             \___\___\___/   /   /
                  \___\_____/   /
                       \_______/
Проход 2     c   b   a   f   d   e
             \___\___|___|___/   /
                  \______|______/
Проход 3     a   b   c   d   e   f
             |___|___|___|___|___|
Результат    <strong>a   b   c   d   e   f</strong>
</pre>
</table>
<p class="tj">То, что этот метод дает хорошие результаты, или даже то, что он вообще сортирует массив, увидеть не так просто. Тем не менее, это верно. Каждый проход сортировки распространяется на относительно небольшое количество элементов либо на элементы, расположенные уже в относительном порядке. Поэтому сортировка Шелла эффективна, а каждый проход повышает упорядоченность<sup><a href="#66" id="6">[6]</a></sup>.
<p class="tj">Конкретная последовательность шагов может быть и другой. Единственное правило состоит в том, чтобы последний шаг был равен 1. Например, такая последовательность:
<p class="t">9, 5, 3, 2, 1
<p class="t">дает хорошие результаты и применяется в показанной здесь реализации сортировки Шелла. Следует избегать последовательностей, которые являются степенями числа 2 — по математически сложным соображениям они уменьшают эффективность сортировки (но сортировка по-прежнему работает!).
<pre>
/* Сортировка Шелла. */
void shell(char *items, int count)
{
  register int i, j, gap, k;
  char x, a[5];
  a[0]=9; a[1]=5; a[2]=3; a[3]=2; a[4]=1;
  for(k=0; k &lt; 5; k++) {
    gap = a[k];
    for(i=gap; i &lt; count; ++i) {
      x = items[i];
      for(j=i-gap; (x &lt; items[j]) && (j &gt;= 0); j=j-gap)
        items[j+gap] = items[j];
      items[j+gap] = x;
    }
  }
}
</pre>
<p class="tj">Вы могли заметить, что внутренний цикл <kbd>for</kbd> имеет два условия проверки. Очевидно, что сравнение <kbd>x&lt;items[j]</kbd> необходимо для процесса сортировки. Выражение <kbd>j&gt;=0</kbd> предотвращает выход за границу массива <kbd>items</kbd>. Эти дополнительные проверки в некоторой степени понижают производительность сортировки Шелла.
<p class="tj">В слегка модифицированных версиях данного метода сортировки применяются специальные элементы массива, называемые <em>сигнальными метками</em>. Они не принадлежат к собственно сортируемому массиву, а содержат специальные значения, соответствующие наименьшему возможному и наибольшему возможному элементам<sup><a href="#77" id="7">[7]</a></sup>. Это устраняет необходимость проверки выхода за границы массива. Однако применение сигнальных меток элементов требует конкретной информации о сортируемых данных, что уменьшает универсальность функции сортировки.
<p class="tj">Анализ сортировки Шелла связан с очень сложными математическими задачами, которые выходят далеко за рамки этой книги. Примите на веру, что время сортировки пропорционально
<p class="t"><em>n</em><sup>1,2</sup>
<p class="t">при сортировке <em>n</em> элементов<sup><a href="#88" id="8">[8]</a></sup>. А это уже существенное улучшение по сравнению с сортировками порядка <em>n</em><sup>2</sup>. Чтобы понять, насколько оно велико, обратитесь к рис. 21.3, на котором показаны графики функций <em>n</em><sup>2</sup> и <em>n</em><sup>1,2</sup>. Тем не менее, не стоит чрезмерно восхищаться сортировкой Шелла — быстрая сортировка еще лучше.</p>
<table class="table">
<caption class="bottom"><p class="tj"><em>Рис. 21.3. Попытка наглядного представления кривых n<sup>2</sup> и n<sup>1,2</sup>. Хотя вычертить эти кривые с точным соблюдением масштаба на каком-нибудь значимом для целей сортировки интервале изменения количества записей (n), например, на интервале от 0 до 1000, не представляется возможным, получить представление о поведении этих кривых можно с помощью графиков функций у=(n/100)<sup>2</sup> и у=(n/100)<sup>1,2</sup>. Для сравнения построен также график прямой у=n/100. Кроме того, чтобы получить представление о росте этих кривых, можно на оси ординат принять логарифмический масштаб, — это все равно, что начертить логарифмы этих функций</em>
<tr><td align="center"><img src="../work/pic21_3_1.png" alt="y=a*(n/100)^b"><p><br><p><img src="../work/pic21_3_2.png" alt="y=a*log10(n)"></td>
</table>
<h2>Быстрая соритировка</h2>
<p class="tj">Быстрая сортировка, придуманная Ч. А. Р. Хоаром<sup><a href="#99" id="9">[9]</a></sup> (Charles Antony Richard Hoare) и названная его именем, является самым лучшим методом сортировки из представленных в данной книге и обычно считается лучшим из существующих в настоящее время алгоритмом сортировки общего назначения. В ее основе лежит сортировка обменами — удивительный факт, учитывая ужасную производительность пузырьковой сортировки!
<p class="tj">Быстрая сортировка построена на идее деления. Общая процедура заключается в том, чтобы выбрать некоторое значение, называемое <em>компарандом</em> (comparand)<sup><a href="#1010" id="010">[10]</a></sup>, а затем разбить массив на две части. Все элементы, большие или равные компаранду, перемещаются на одну сторону, а меньшие — на другую. Потом этот процесс повторяется для каждой части до тех пор, пока массив не будет отсортирован. Например, если исходный массив состоит из символов <strong>fedacb</strong>, а в качестве компаранда используется символ <strong>d</strong>, первый проход быстрой сортировки переупорядочит массив следующим образом:
<pre>
Начало       <strong>f e d a c b</strong>
Проход 1     <strong>b c a d e f</strong>
</pre>
<p class="tj">Затем сортировка повторяется для обеих половин массива, то есть <strong>bса</strong> и <strong>def</strong>. Как вы видите, этот процесс по своей сути рекурсивный, и, действительно, в чистом виде быстрая сортировка реализуется как рекурсивная функция<sup><a href="#1111" id="011">[11]</a></sup>.
<p class="tj">Значение компаранда можно выбирать двумя способами — случайным образом либо усреднив небольшое количество значений из массива. Для оптимальной сортировки необходимо выбирать значение, которое расположено точно в середине диапазона всех значений. Однако для большинства наборов данных это сделать непросто. В худшем случае выбранное значение оказывается одним из крайних. Тем не менее, даже в этом случае быстрая сортировка работает правильно. В приведенной ниже версии быстрой сортировки в качестве компаранда выбирается средний элемент массива.
<pre>
/* Функция, фызывающая функцию быстрой сортировки. */
void quick(char *items, int count)
{
  qs(items, 0, count-1);
}
/* Быстрая сортировка. */
void qs(char *items, int left, int right)
{
  register int i, j;
  char x, y;
  i = left; j = right;
  x = items[(left+right)/2]; /* выбор компаранда */
  do {
    while((items[i] &lt; x) && (i &lt; right)) i++;
    while((x &lt; items[j]) && (j &gt; left)) j--;
    if(i &lt;= j) {
      y = items[i];
      items[i] = items[j];
      items[j] = y;
      i++; j--;
    }
  } while(i &lt;= j);
  if(left &lt; j) qs(items, left, j);
  if(i &lt; right) qs(items, i, right);
}
</pre>
<p class="tj">В этой версии функция <kbd>quick()</kbd> готовит вызов главной сортирующей функции <kbd>qs()</kbd>. Это обеспечивает общий интерфейс с параметрами <kbd>items</kbd> и <kbd>count</kbd>, но несущественно, так как можно вызывать непосредственно функцию <kbd>qs()</kbd> с тремя аргументами.
<p class="tj">Получение количества сравнений и обменов, которые выполняются при быстрой сортировке, требует математических выкладок, которые выходят за рамки данной книги. Тем не менее, среднее количество сравнений равно
<p class="t"><em>n</em> log <em>n</em>
<p class="t">а среднее количество обменов примерно равно
<p class="t"><em>n</em>/6 log <em>n</em>
<p class="tj">Эти величины намного меньше соответствующих характеристик рассмотренных ранее алгоритмов сортировки.
<p class="tj">Необходимо упомянуть об одном особенно проблематичном аспекте быстрой сортировки. Если значение компаранда в каждом делении равно наибольшему значению, быстрая сортировка становится "медленной сортировкой" со временем выполнения порядка <em>n</em><sup>2</sup>. Поэтому внимательно выбирайте метод определения компаранда. Этот метод часто определяется природой сортируемых данных. Например, в очень больших списках почтовой рассылки, в которых сортировка происходит по почтовому индексу, выбор прост, потому что почтовые индексы довольно равномерно распределены — компаранд можно определить с помощью простой алгебраической функции. Однако в других базах данных зачастую лучшим выбором является случайное значение. Популярный и довольно эффективный метод — выбрать три элемента из сортируемой части массива и взять в качестве компаранда значение, расположенное между двумя другими.
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Конечно, это не означает, что функция <em>f(n)=n<sup>2</sup></em> в какой-то точке возрастает скачкообразно. Вовсе нет! Просто при увеличении размера массива n меняется характер сортировки, из <em>внутренней</em> она <em>фактически</em> становится <em>внешней</em>, когда массив не помещается в оперативной памяти и начинается интенсивная подкачка страниц, а за ней пробуксовывание механизма виртуальной памяти. Вот эти-то события действительно могут наступить внезапно, и тогда может показаться, что незначительное увеличение сортируемого массива или просто добавление какой-либо совершенно незначительной задачи приведет к катастрофическому увеличению времени сортировки (например в десятки раз!).
<p class="tj"><sup><a href="#2" id="22">[2]</a></sup>Отдельные программисты — "любители рассказов о рыбной ловле" — клянутся об увеличении эффективности сначала наполовину, затем вдвое-втрое, к середине рассказа — на порядок, а к концу рассказа — на несколько порядков. (Такое не получается даже в специально подобранных примерах для рекламного проспекта по языку Ассемблера.) На самом деле производительность может даже упасть. В лучшем случае удается повысить ее на 10-12% для реально значимых производственных задач. При этом чем сложнее алгоритм, тем сложнее переписать его на Ассемблере и тем проще сделать в нем ошибку при переписывании, а тем более сложнее ее найти. Кроме того, следует учитывать и такой фактор: например, программу писал какой-то квалифицированный программист, который выбрал простой (но не очень эффективный — при чем об этом он знал) алгоритм потому, что менеджеры настаивали на скорейшем завершении программы, а оптимизацию этой программы те же менеджеры поручат весьма не самым квалифицированным специалистам! Эффект действительно будет на несколько порядков больше, но в совершенно противоположную сторону! Ведь с таким же успехом для "улучшения" трагедий Шекспира за пишущие машинки можно было усадить стадо обезьян!
<p class="tj"><sup><a href="#3" id="33">[3]</a></sup>Действительно, чтобы увеличить в <em>m</em> раз размер сортируемого массива при сохранении времени сортировки, быстродействие процессора придется увеличить в <em>m</em><sup>2</sup> раз при условии, что время доступа к элементам массива не увеличится, т.е. не уменьшится, например, эффективность подкачки страниц.
<p class="tj"><sup><a href="#4" id="44">[4]</a></sup>Считается, что Дональд Л. Шелл описал свой метод сортировки 28 июля 1959 года. Данный метод классифицируется как <em>слияние с обменом</em>; часто называется также <em>сортировкой с убывающим шагом</em>.
<p class="tj"><sup><a href="#5" id="55">[5]</a></sup><em>Шаг</em> — расстояние между сортируемыми элементами на конкретном этапе сортировки.
<p class="tj"><sup><a href="#6" id="66">[6]</a></sup>Т.е. уменьшает количество беспорядков (инверсий).
<p class="tj"><sup><a href="#7" id="77">[7]</a></sup>-&#8734; и +&#8734;.
<p class="tj"><sup><a href="#8" id="88">[8]</a></sup>Вообще говоря, время сортировки Шелла зависит от последовательности шагов. (Впрочем, минимум равен, конечно, <em>n</em>&#160;log<sub>2</sub><em>n</em>.) Оптимальная последовательность не известна до сих пор. Дональд Кнут исследовал различные последовательности (не забыв и последовательность Фибоначчи). Фактически он пришел к выводу, что в определении наилучшей последовательности есть какое-то "колдовство". В 1969 г. Воган Пратт обнаружил, что <em>если все шаги выбираются из множества чисел вида 2<sup>p</sup>3<sup>q</sup>, меньших n, то время работы будет порядка n(log n)<sup>2</sup></em>. А.А. Папернов и Г.В. Стасевич в 1965 г. доказали, что максимальное время сортировки Шелла не превосходит О(n<sup>1,5</sup>), причем уменьшить показатель 1,5 нельзя. Большое число экспериментов с сортировкой Шелла провели Джеймс Петерсон и Дэвид Л. Рассел в Стэнфордском университете в 1971 г. Они пытались определить среднее число перемещений при 100&#8804;<em>n</em>&#8804;250`000 для последовательно сти шагов 2<sup>k</sup>-1. Наиболее подходящими формулами оказались 1,21<em>n</em><sup>1,26</sup> и ,39<em>n</em>(ln&#160;<em>n</em>)-2,33<em>n</em>&#160;ln&#160;<em>n</em>. Но при изменении диапазона n оказалось, что коэффициенты в представлении степенной функцией практически не изменяются, а коэффициенты в логарифмическом представлении изменяются довольно резко. Поэтому естественно предположить, что именно степенная функция описывает истинное асимптотическое поведение сортировки Шелла.
<p class="tj"><sup><a href="#9" id="99">[9]</a></sup>Встречается также написание Ч. Э. Р. Хоор.
<p class="tj"><sup><a href="#010" id="1010">[10]</a></sup><em>Компаранд</em> — операнд в операции сравнения. Иногда называется также <em>основой</em> и <em>критерием разбиения</em>.
<p class="tj"><sup><a href="#011" id="1111">[11]</a></sup>Если хотите избежать рекурсии, не волнуйтесь, все очень легко переписывается даже для Фортрана IV, в упомянутой ранее литературе вы без труда найдете нужный нерекурсивный вариант.
</blockquote>
<p>
</p>
<hr><a href="../main.htm#21">Содержание</a> | <a href="2106.htm">&lt;&lt;&lt;</a> | <a href="2108.htm">&gt;&gt;&gt;</a>
</body>
</html>
