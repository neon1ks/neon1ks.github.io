<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Функция scanf - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#13">Содержание</a> | <a href="13.htm#00">Глава 13</a><hr>
<h1>Функция scanf</h1>
<pre>
#include &lt;stdio.h&gt;
int scanf(const char *<em>format</em>, ...);
</pre>
<p class="tj">Функция <kbd>scanf()</kbd> представляет собой процедуру ввода общего назначения, которая читает поток <kbd>stdin</kbd> и сохраняет информацию в переменных, перечисленных в списке аргументов. Она может читать все встроенные типы данных и автоматически преобразовывать их в соответствующий внутренний формат.
<p class="tj">В версии C99 к параметру <em>format</em> применен квалификатор <kbd>restrict</kbd>.
<p class="tj">Управляющая строка, задаваемая параметром <em>format</em>, состоит из символов трех категорий:
<ul class="square">
<li>спецификаторов формата;<br>
<li>пробельных символов;<br>
<li>символов, отличных от пробельных.<br>
</ul>
<p class="tj">Спецификации формата начинаются знаком <kbd>%</kbd> и сообщают функции <kbd>scanf()</kbd> тип данного, которое будет прочитано. Спецификации формата приведены в таблице 13.3. Например, по спецификации <kbd>%s</kbd> будет прочитана строка, а по спецификации <kbd>%d</kbd> — целое значение. Строка форматирования читается слева направо, и спецификации формата сопоставляются аргументам в порядке их перечисления в списке аргументов.</p>
<table class="table table-bordered">
<caption><strong>Таблица 13.3. Спецификации формата функции scanf()</strong></caption>
<tr><th><em>Код</em><th><em>Назначение</em>
<tr><td><kbd>%a</kbd><td>Читает значение с плавающей точкой (только C99)
<tr><td><kbd>%A</kbd><td>Аналогично коду <kbd>%a</kbd> (только C99)
<tr><td><kbd>%c</kbd><td>Читает один символ
<tr><td><kbd>%d</kbd><td>Читает десятичное целое
<tr><td><kbd>%i</kbd><td>Читает целое в любом формате (десятичное, восьмеричное или шестнадцатеричное)
<tr><td><kbd>%e</kbd><td>Читает число с плавающей точкой
<tr><td><kbd>%E</kbd><td>Аналогично коду <kbd>%e</kbd>
<tr><td><kbd>%f</kbd><td>Читает число с плавающей точкой
<tr><td><kbd>%F</kbd><td>Аналогично коду <kbd>%f</kbd> (только С99)
<tr><td><kbd>%g</kbd><td>Читает число с плавающей точкой
<tr><td><kbd>%G</kbd><td>Аналогично коду <kbd>%g</kbd>
<tr><td><kbd>%o</kbd><td>Читает восьмеричное число
<tr><td><kbd>%s</kbd><td>Читает строку
<tr><td><kbd>%x</kbd><td>Читает шестнадцатеричное число
<tr><td><kbd>%X</kbd><td>Аналогично коду <kbd>%x</kbd>
<tr><td><kbd>%p</kbd><td>Читает указатель
<tr><td><kbd>%n</kbd><td>Принимает целое значение, равное количеству прочитанных до сих пор символов
<tr><td><kbd>%u</kbd><td>Читает десятичное целое без знака
<tr><td><kbd>%[]</kbd><td>Просматривает набор символов
<tr><td><kbd>%%</kbd><td>Читает знак процента
</table>
<p class="tj">По умолчанию спецификации <kbd>a</kbd>, <kbd>f</kbd>, <kbd>e</kbd> и <kbd>g</kbd> заставляют функцию <kbd>scanf()</kbd> присваивать данные переменным типа <kbd>float</kbd>. Если перед одной из этих спецификаций поставить модификатор <kbd>l</kbd>, функция <kbd>scanf()</kbd> присвоит прочитанные данные переменной типа <kbd>double</kbd>. Использование же модификатора <kbd>L</kbd> означает, что полученное значение присвоится переменной типа <kbd>long double</kbd>.
<p class="tj">Современные компиляторы, поддерживающие добавленные в 1995 году средства работы с двухбайтовыми символами, позволяют к спецификации <kbd>c</kbd> применить модификатор <kbd>l</kbd>; тогда будет считаться, что соответствующий указатель указывает на двухбайтовый символ (т.е. на данное типа <kbd>whcar_t</kbd>). Модификатор <kbd>l</kbd> также можно использовать с кодом формата <kbd>s</kbd>; тогда будет считаться, что соответствующий указатель указывает на строку двухбайтовых символов. Кроме того, модификатор <kbd>l</kbd> можно использовать для того, чтобы указать, что набор сканируемых символов состоит из двухбайтовых символов.
<p class="tj">Если в строке форматирования встретится разделитель, то функция <kbd>scanf()</kbd> пропустит один или несколько разделителей во входном потоке. Под разделителем, или пробельным символом, подразумевается пробел, символ табуляции или разделитель строк (символ новой строки). По сути, наличие одного разделителя в управляющей строке приведет к тому, что функция <kbd>scanf()</kbd> будет читать, не сохраняя, любое количество (возможно, даже нулевое) разделителей до первого символа, отличного от разделителя.
<p class="tj">Если в строке форматирования встретился символ, отличный от разделителя, то функция <kbd>scanf()</kbd> прочитает и отбросит его. Например, если в строке форматирования встретится <kbd>%d</kbd>, <kbd>%d</kbd>, то функция <kbd>scanf()</kbd> сначала прочитает целое значение, затем прочитает и отбросит запятую и, наконец, прочитает еще одно целое. Если заданный символ не найден, функция <kbd>scanf()</kbd> завершает работу.
<p class="tj">Все переменные, получающие значения с помощью функции <kbd>scanf()</kbd>, должны передаваться посредством своих адресов. Это значит, что все аргументы должны быть указателями на переменные.
<p class="tj">Элементы входного потока должны быть разделены пробелами, символами табуляции или разделителями строк. Такие символы, как запятая, точка с запятой и т.п., не распознаются в качестве разделителей. Это означает, что оператор
<pre>
scanf("%d%d", &r, &c);
</pre>
примет значения, введенные как <kbd>10 20</kbd>, но откажется от последовательности символов <kbd>10, 20</kbd>.
<p class="tj">Символ <kbd>*</kbd>, стоящий после знака <kbd>%</kbd> и перед кодом формата, прочитает данные заданного типа, но запретит их присваивание. Следовательно, оператор
<pre>
scanf("%d%*c%d", &x, &y);
</pre>
при вводе данных в виде <kbd>10/20</kbd> поместит значение 10 в переменную <kbd>x</kbd>, отбросит знак деления и присвоит значение 20 переменной <kbd>у</kbd>.
<p class="tj">Команды форматирования могут содержать модификатор максимальной длины поля. Он представляет собой целое число, располагаемое между знаком <kbd>%</kbd> и кодом формата, которое ограничивает количество читаемых для всех полей символов. Например, если в переменную <kbd>address</kbd> нужно прочитать не более 20 символов, используется следующий оператор.
<pre>
scanf("%20s", address);
</pre>
<p class="tj">Если входной поток содержит более 20 символов, то при последующем обращении к операции ввода чтение начнется с того места, в котором "остановился" предыдущий вызов функции <kbd>scanf()</kbd>. Если разделитель встретится раньше, чем достигнута максимальная длина поля, ввод данных завершится. В этом случае функция <kbd>scanf()</kbd> переходит к чтению следующего поля.
<p class="tj">Хотя пробелы, символы табуляции и разделители строк используются в качестве разделителей полей, при чтении одиночного символа они читаются подобно любому другому символу. Например, если входной поток состоит из символов <kbd>x у</kbd>, то оператор
<pre>
scanf("%c%c%c", &a, &b, &c);
</pre>
поместит символ x в переменную <kbd>а</kbd>, пробел — в переменную <kbd>b</kbd>, а символ у — в переменную <kbd>с</kbd>.
<p class="tj">Помните, что любые символы управляющей строки (включая пробелы, символы табуляции и новой строки), не являющиеся спецификациями формата, используются для установки соответствия и отбрасывания символов из входного потока. Любой соответствующий им символ отбрасывается. Например, если поток ввода выглядит, как <kbd>10t20</kbd>, оператор
<pre>
scanf("%dt%d", &x, &y);
</pre>
присвоит переменной <kbd>x</kbd> значение 10, а переменной <kbd>у</kbd> — значение 20. Символ <kbd>t</kbd> отбрасывается, так как он присутствует в управляющей строке.
<p class="tj">Функция <kbd>scanf()</kbd> поддерживает спецификатор формата общего назначения, называемый <em>набором сканируемых символов (scanset)</em>. В этом случае определяется набор символов, которые могут быть прочитаны функцией <kbd>scanf()</kbd> и присвоены соответствующему массиву символов. Для определения такого набора символы, подлежащие сканированию, необходимо заключить в квадратные скобки. Открывающая квадратная скобка должна следовать сразу за знаком процента. Например, следующий набор сканируемых символов указывает на то, что необходимо читать только символы <kbd>A</kbd>, <kbd>B</kbd> и <kbd>C</kbd>.
<pre>
%[ABC]
</pre>
<p class="tj">При использовании набора сканируемых символов функция <kbd>scanf()</kbd> продолжает читать символы и помещать их в соответствующий массив символов до тех пор, пока не встретится символ, отсутствующий в заданном наборе. Соответствующая набору переменная должна быть указателем на массив символов. При возврате из функции <kbd>scanf()</kbd> этот массив будет содержать строку из прочитанных символов, завершающуюся символом конца строки.
<p class="tj">Если первый символ в наборе является знаком <kbd>^</kbd>, то получаем обратный эффект: входное поле читается до тех пор, пока не встретится символ из заданного набора сканируемых символов, т.е. знак <kbd>^</kbd> заставляет функцию <kbd>scanf()</kbd> читать только те символы, которые отсутствуют в наборе сканируемых символов.
<p class="tj">Во многих реализациях допускается задавать диапазон с помощью дефиса. Например, функция <kbd>scanf</kbd>(), встречая набор сканируемых символов в виде <kbd>%[A-z]</kbd>, будет читать символы, попадающие в диапазон от А до Z.
<p class="tj">Важно помнить, что в наборе сканируемых символов различаются прописные и строчные буквы. Следовательно, чтобы сканировать как прописные, так и строчные буквы, в наборе сканируемых символов придется задать их отдельно.
<p class="tj">Функция <kbd>scanf()</kbd> возвращает число, равное количеству полей, для которых успешно присвоены значения. К этим полям не относятся поля, которые были прочитаны, но присвоение не состоялось в связи с использованием модификатора <kbd>*</kbd>, подавляющего присваивание. При обнаружении ошибки до присвоения значения первого поля функция <kbd>scanf()</kbd> возвращает значение <kbd>EOF</kbd>.
<h2>Модификаторы формата, добавленные к функции scanf() Стандартом C99</h2>
<p class="tj">В версии C99 для использования в функции <kbd>scanf()</kbd> добавлены модификаторы формата <kbd>hh</kbd>, <kbd>ll</kbd>, <kbd>j</kbd>, <kbd>z</kbd> и <kbd>t</kbd>. Модификатор <kbd>hh</kbd> можно применять к спецификациям <kbd>d</kbd>, <kbd>i</kbd>, <kbd>о</kbd>, <kbd>u</kbd>, <kbd>x</kbd> и <kbd>n</kbd>. Он означает, что соответствующий аргумент является указателем на значение типа <kbd>signed char</kbd> или <kbd>unsigned char</kbd>. Модификатор <kbd>ll</kbd> также можно применять к спецификациям <kbd>d</kbd>, <kbd>i</kbd>, <kbd>о</kbd>, <kbd>u</kbd>, <kbd>x</kbd> и <kbd>n</kbd>. Он означает, что соответствующий аргумент является указателем на значение типа <kbd>signed long long int</kbd> или <kbd>unsigned long long int</kbd>.
<p class="tj">Moдификaтop фopмaтa <kbd>j</kbd>, кoтopый пpимeняeтcя к cпeцификaциям <kbd>d</kbd>, <kbd>i</kbd>, <kbd>о</kbd>, <kbd>u</kbd>, <kbd>х</kbd> и <kbd>n</kbd> означает, что соответствующий аргумент является указателем на значение типа <kbd>intmax_t</kbd> или <kbd>uintmax_t</kbd>. Эти типы объявлены в заголовке <kbd>&lt;stdint.h&gt;</kbd> и служат для хранения целых максимально возможной разрядности.
<p class="tj">Модификатор формата <kbd>z</kbd>, который применяется к спецификациям <kbd>d</kbd>, <kbd>i</kbd>, <kbd>о</kbd>, <kbd>u</kbd>, <kbd>х</kbd> и <kbd>n</kbd> означает, что соответствующий аргумент является указателем на объект типа <kbd>size_t</kbd>. Этот тип объявлен в заголовке <kbd>&lt;stddef.h&gt;</kbd> и служит для хранения результата операции <kbd>sizeof</kbd>.
<p class="tj">Модификатор формата <kbd>t</kbd>, который применяется к спецификациям <kbd>d</kbd>, <kbd>i</kbd>, <kbd>о</kbd>, <kbd>u</kbd>, <kbd>х</kbd> и <kbd>n</kbd> означает, что соответствующий аргумент является указателем на объект типа <kbd>ptrdiff_t</kbd>. Этот тип объявлен в заголовке <kbd>&lt;stddef.h&gt;</kbd> и служит для хранения значения разности между двумя указателями.
<h2>Пример</h2>
<p class="tj">Действие данных операторов <kbd>scanf()</kbd> объясняется в комментариях.
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
  char str[80], str2[80];
  int i;
  /* читается строка и целое значение */
  scanf("%s%d", str, &i);
  /* в переменную str считывается не более 79 символов */
  scanf("%79s", str);
  /* целое, расположенное между двумя строками, пропускается */
  scanf("%s%*d%s", str, str2);
  return 0;
}
</pre>
<h2>Зависимые функции</h2>
<a href="printf.htm">printf()</a>  <a href="fscanf.htm">fscanf()</a>
<hr><a href="../main.htm#13">Содержание</a> | <a href="13.htm#00">Глава 13</a>


</body></html>