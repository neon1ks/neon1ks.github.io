<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Функция sprintf - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#13">Содержание</a> | <a href="13.htm#00">Глава 13</a><hr>
<h1>Функция sprintf</h1>
<pre>
#include &lt;stdio.h&gt;
int sprintf(char *<em>buf</em>, const char *<em>format</em>, ...);
</pre>
<p class="tj">Функция <kbd>sprintf()</kbd> идентична функции <kbd>printf()</kbd> за исключением того, что поток вывода записывается в массив, адресуемый указателем <em>buf</em>, а не в стандартный поток <kbd>stdout</kbd>. По окончании работы функции этот массив будет завершаться символом конца строки (нуль-символом). Подробности рассматриваются в разделе, посвященном описанию функции <kbd>printf</kbd>.
<p class="tj">В версии C99 к параметрам <em>buf</em> и <em>format</em> применен квалификатор <kbd>restrict</kbd>.
<p class="tj">Возвращаемое значение равно числу символов, действительно помещенных в массив.
<p class="tj">Важно понимать, что функция <kbd>sprintf()</kbd> не обеспечивает никакой проверки переполнения массива, адресуемого указателем <em>buf</em>. Это значит, что массив будет переполнен, если объем выводимых символов превысит длину массива. В качестве альтернативного решения рассмотрите применение функции <kbd>snprintf()</kbd>.
<h2>Пример</h2>
<p class="tj">После выполнения этого фрагмента программы элементам массива <kbd>str</kbd> значения будут присвоены таким образом, что получится строка:
<pre>один 2 3</pre>
<pre>
char str[80];
sprintf(str, "%s %d %c", "один", 2, '3');
</pre>
<h2>Зависимые функции</h2>
<a href="printf.htm">printf()</a>  <a href="fsprintf.htm">fsprintf()</a>
<p>
</p>
<hr><a href="../main.htm#13">Содержание</a> | <a href="13.htm#00">Глава 13</a>


</body></html>