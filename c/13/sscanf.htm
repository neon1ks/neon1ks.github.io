<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Функция sscanf - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head><body>
<a href="../main.htm#13">Содержание</a> | <a href="13.htm#00">Глава 13</a><hr>
<h1>Функция sscanf</h1>
<pre>
#include &lt;stdio.h&gt;
int sscanf(const char *<em>buf</em>, const char *<em>format</em>, ...);
</pre>
<p class="tj">Функция <kbd>sscanf()</kbd> идентична функции <kbd>scanf()</kbd>, но данные читаются из массива, адресуемого параметром <em>buf</em>, а не из стандартного потока ввода <kbd>stdin</kbd>. Подробности приводятся в разделе <kbd>scanf</kbd>.
<p class="tj">В версии C99 к параметрам <em>buf</em> и <em>format</em> применен квалификатор <kbd>restrict</kbd>.
<p class="tj">Значение, возвращаемое функцией, равно количеству переменных, которым реально были присвоены значения. К ним не относятся поля, опущенные из-за использования модификатора команды форматирования *. Нулевое значение свидетельствует о том, что ни одно поле не было присвоено, а значение <kbd>EOF</kbd> сигнализирует об ошибке, обнаруженной до первого присваивания.
<h2>Пример</h2>
<p class="tj">Данная программа выводит на экран сообщение
<pre>привет 1</pre>
<pre>
#include &lt;stdio.h&gt;
int main(void)
{
  char str[80];
  int i;
  sscanf("привет 1 2 3 4 5", "%s%d", str, &i);
  printf("%s %d", str, i);
  return 0;
}
</pre>
<h2>Зависимые функции</h2>
<a href="scanf.htm">scanf()</a>  <a href="fscanf.htm">fscanf()</a>
<p>
</p>
<hr><a href="../main.htm#13">Содержание</a> | <a href="13.htm#00">Глава 13</a>
</body></html>