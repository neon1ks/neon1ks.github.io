<!DOCTYPE HTML>
<html lang="ru">
<head>
<title>Использование программы MAKE - cправочник по Си</title>
<meta charset="utf-8">
<link rel="stylesheet" href="../work/css.css">
</head>
<body>


<a href="../main.htm#27">Содержание</a> | <a href="2702.htm">&lt;&lt;&lt;</a> | <a href="2704.htm">&gt;&gt;&gt;</a><hr>
<h1>Использование программы MAKE</h1>
<p class="tj">При создании больших программ разработчиков подстерегает ошибка иного рода, которая проявляется в основном на стадии разработки, но может завести такой проект почти в глухой тупик. Такая ошибка возникает в тех случаях, когда при компиляции и компоновке программы один или несколько файлов ресурсов оказываются устаревшими по сравнению с соответствующими объектными файлами. Если такое случится, то полученная в результате исполняемая программа не будет функционировать так, как предусмотрено в последней реализации исходного кода. Наверно каждый, кто когда-либо участвовал в создании или сопровождении большого программного проекта, сталкивался с подобной проблемой. Чтобы помочь избежать обескураживающих ошибок подобного типа, большинство компиляторов С имеют в своем составе утилиту под названием МАКЕ, которая помогает синхронизировать файлы ресурсов и объектные файлы. (Точное название МАКЕ-утилиты, соответствующей вашему компилятору, может немного отличаться от МАКЕ, поэтому для большей уверенности проверьте себя по документации, прилагаемой к компилятору.)
<p class="tj">Программа МАКЕ автоматизирует процесс перекомпиляции крупных программ, скомпонованных из нескольких файлов. Очень часто в процессе разработки программы во многие файлы вносится масса незначительных изменений. После этого программа повторно компилируется и тестируется. К сожалению, довольно легко забыть, какие именно файлы нуждаются в перекомпиляции. В такой ситуации вы можете или перекомпилировать все файлы и потерять массу времени, или случайно пропустить файл, который обязательно необходимо перекомпилировать. А это, в свою очередь, может повлечь за собой необходимость в дополнительной, иногда многочасовой, отладке. Программа МАКЕ решает эту проблему посредством автоматической перекомпиляции только тех файлов, которые претерпели изменения.
<p class="tj">Примеры, приведенные в этом разделе, совместимы с программами МАКЕ, поставляемыми вместе с Microsoft C/C++. На сегодняшний день, Microsoft-версия программы МАКЕ носит название NMAKE. Эти примеры будут также работать со многими другими широко распространенными МАКЕ-утилитами, а общие концепции, описанные здесь, применимы для всех МАКЕ-программ.</p>
<table class="table table-bordered">
<tr><td class="tdnote">На заметку<td class="tj">В последние годы программы МАКЕ стали очень изощренными. Примеры, приведенные здесь, иллюстрируют только основные возможности МАКЕ. Стоит подробнее изучить утилиту МАКЕ, поддерживаемую вашим компилятором. Она может содержать такие функциональные особенности, которые окажутся исключительно полезными в вашей среде разработки.
</table>
<p class="tj">В своей работе утилита МАКЕ руководствуется сборочным файлом проекта или так называемым <em>make-файлом</em>, который содержит перечень выходных файлов (target files), зависимых файлов (dependent files) и команд. Для генерации <em>выходного файла</em> необходимо наличие <em>файлов, от которых он зависит</em>. Например, от Т.С <em>зависит</em> файл T.OBJ, поскольку Т.С необходим для создания T.OBJ. В процессе работы утилиты МАКЕ производится сравнение даты выходного файла с датой файла, от которого он зависит. (В данном случае под термином "дата" подразумевается и календарная дата, и время.) Если выходной файл старше, т.е. имеет более позднюю дату создания, чем файл, от которого он зависит (или если выходной файл вообще отсутствует), выполняется указанная последовательность команд. Если эта последовательность команд использует выходные файлы, при построении которых используются файлы, от которых они зависят, то при необходимости модифицируются также и эти используемые файлы<sup><a href="#11" id="1">[1]</a></sup>. Когда процесс МАКЕ завершится, все выходные файлы будут обновлены. Следовательно, в правильно построенном сборочном файле проекта все исходные файлы, которые требуют компиляции, автоматически компилируются и компонуются, образуя новый исполняемый модуль. Таким образом, данная утилита следит, чтобы все изменения в исходных файлах были отражены в соответствующих им объектных файлах.
<p class="tj">В общем виде make-файл выглядит следующим образом:
<pre>
target_file1: dependent_file list
  command_sequence
target_file2: dependent_file list
  command_sequence
target_file3: dependent_file list
  command_sequence
.
.
.
target_fileN: dependent_file list
  command_sequence
</pre>
<p class="tj">Имя выходного файла должно начинаться в крайней левой позиции; за ним должно следовать двоеточие и список файлов, от которых он зависит. Последовательность команд, соответствующая каждому выходному файлу, должна предваряться как минимум одним пробелом или одним знаком табуляции. Перед комментариями должен стоять знак #, а сами комментарии могут следовать за списком зависимых файлов и/или последовательностью команд. Кроме того, их можно написать в отдельных строках. Спецификации выходных файлов должны отделяться друг от друга по крайней мере одной пустой строкой.
<p class="tj">Самое главное при работе с make-файлом — учитывать следующую особенность: выполнение make-файла заканчивается сразу после того, как удастся обработать первую же цепочку зависимостей. Это означает, что необходимо разрабатывать свои make-файлы таким образом, чтобы зависимости составляли иерархическую структуру. Запомните, что ни одна зависимость не будет считаться успешно обработанной до тех пор, пока все подчиненные ей зависимости (т.е. зависимости более низкого уровня) не будут разрешены.
<p class="tj">Чтобы лучше понять, как работает утилита МАКЕ, давайте рассмотрим очень простую программу. Она состоит из четырех файлов под названием TEST.H, TEST.C, TEST2.C и TEST3.C. Рис. 27.2 иллюстрирует данную ситуацию. (Чтобы лучше понять, о чем идет речь, введите каждую часть программы в указанные файлы.)
<pre>
<strong>TEST.H</strong>
extern int count;
<strong>TEST.C</strong>
#include &lt;stdio.h&gt;
void test2(void), test3(void);
int count = 0;
int main(void)
{
  printf("count = %d\n", count);
  test2( );
  printf("count = %d\n", count);
  test3( );
  printf("count = %d\n", count);
  return 0;
}
<strong>TEST2.C</strong>
#include &lt;stdio.h&gt;
#include "test.h"
void test2(void)
{
  count = 30;
}
<strong>TEST3.C</strong>
#include &lt;stdio.h&gt;
#include "test.h"
void test3(void)
{
  count = -100;
}
<em>Рис. 27.2. Простая программа, состоящая из четырех файлов</em>
</pre>
<p class="tj">Если в своей работе вы используете Visual C++, следующий make-файл перекомпилирует данную программу после того, как вы внесете в них какие-нибудь изменения:
<pre>
test.exe:  test.h test.obj test2.obj test3.obj
        cl test.obj test2.obj test3.obj
test.obj: test.c test.h
        cl -c test.c
test2.obj: test2.c test.h
        cl -c test2.c
test3.obj: test3.c test.h
        cl -c test3.c
</pre>
<p class="tj">По умолчанию программа MAKE выполняет директивы, содержащиеся в файле под названием MAKEFILE. Однако, как правило, разработчики предпочитают применять другие имена для своих сборочных файлов проекта. Задать другое имя make-файла можно с помощью опции <kbd>-f</kbd> в командной строке. Например, если упоминавшийся ранее make-файл называется TEST, то, чтобы с помощью программы NMAKE фирмы Microsoft скомпилировать необходимые модули и создать исполняемый модуль, в командной строке следует набрать нечто подобное следующей строке:
<pre>nmake -f test</pre>
<p class="tj">(Эта команда подходит для программы NMAKE фирмы Microsoft. Если вы пользуетесь другой утилитой МАКЕ, возможно, придется использовать другое имя опции.)
<p class="tj">Очень большое значение в сборочном файле проекта имеет очередность спецификаций, поскольку, как уже упоминалось ранее, МАКЕ прекращает выполнение содержащихся в файле директив сразу после того, как она полностью обработает первую зависимость<sup><a href="#22" id="2">[2]</a></sup>. Например, допустим, что ранее упоминавшийся make-файл был изменен, так что он стал выглядеть следующим образом:
<pre>
# Это неправильный make-файл.
test.obj: test.c test.h
        cl -c test.c
test2.obj: test2.c test.h
        cl -c test2.c
test3.obj: test3.c test.h
        cl -c test3.c
test.exe: test.h test.obj test2.obj test3.obj
        cl test.obj test2.obj test3.obj
</pre>
<p class="tj">Теперь работа будет выполнена неправильно, если файл TEST.H (или любой другой исходный файл) будет изменен. Это происходит потому, что последняя директива (которая создает новый TEST.EXE) больше не будет выполняться.
<h2>Использование макросов в MAKE</h2>
<p class="tj">МАКЕ позволяет определять макросы в make-файле. Имена этих макросов являются просто метками-заполнителями информации, которая в действительности будет определена или в командной строке, или в макроопределении из make-файла. Общая форма определения макроса следующая:
<pre><em>имя_макроса=определение</em></pre>
<p class="tj">Если в макроопределении используется символ пробела, то такое определение следует заключить в двойные кавычки.
<p class="tj">После определения макроса его можно использовать в make-файле следующим образом:
<pre><em>$(имя_макроса)</em></pre>
<p class="tj">Вместо каждого вхождения такого оператора подставляется его макроопределение. Например, в следующем make-файле макрос <kbd>LIBFIL</kbd> позволяет указать редактору связей библиотеку:
<pre>
LIBFIL = graphics.lib
prog.exe: prog.obj prog2.obj prog3.obj
        cl prog.obj prog2.obj prog3.obj $(LIBFIL)
</pre>
<p class="tj">Многие МАКЕ-программы имеют дополнительные функциональные возможности, поэтому очень важно внимательно познакомиться с документацией, поставляемой вместе с компилятором.
<p><img src="../work/sup.bmp" alt="----------">
<blockquote>
<p class="tj"><sup><a href="#1" id="11">[1]</a></sup>Все происходит как при вычислении сложной функции: сначала вычисляются аргументы, от которых она зависит, а если они, в свою очередь, являются сложными функциями, то при необходимости сначала вычисляются их аргументы и т.д.
<p class="tj"><sup><a href="#2" id="22">[2]</a></sup>Т.е. как только построит первый зависимый файл.
</blockquote>
<p>
</p>
<hr><a href="../main.htm#27">Содержание</a> | <a href="2702.htm">&lt;&lt;&lt;</a> | <a href="2704.htm">&gt;&gt;&gt;</a>


</body>
</html>
